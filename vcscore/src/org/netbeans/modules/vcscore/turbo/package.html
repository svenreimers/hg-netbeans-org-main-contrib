<h2>The VCS File Attributes Implementation</h2>

The implementation speedups VCS status access for
remote repositories. It caches last know repository
state. The state is assumed to not change too often.
Note that final state check reponsibility is on
particular VCS command. It's by nature distributed system
and no shared state information exists.
E.g. <code>cvs commit</code> must fail if someone have
commited the same file into repository 1ms before.

<p>
The {@link Turbo} and {@link IgnoreList} implementaions have two main abstract goals:
<ul>
<li>reliability (#39817), here achieved by simplicity
<li>performance and scalability (#41012) similar to local operations
</ul>

<p>
They are responsible for:
<ul>
<li>STATUS: keeping last known status (up-to-date, localy modified, ....)
<li>UNKNOWN: model unknown status
<li>NOTIFICATIONS: support external status change listeners
<li>UPDATED_ON: holding retrieval date of last known status
<li>LEVELS: client can put strategy contraints
<li>IGNORELIST: keep merged .ignorelists
<ul>

<h3>Simplifications</h3>

It works over {@link FileSystem} it's expected that we do not need
to store FilePropeties for non FileObjects. It's safe
to call <code>findResource(path)</code> in FileSystem
implementation except <code>children(folderName)</code> method.

<p>
Memory layer is not hierachical but two simple plain maps
FileObject to FilePropeties. Refs map content is driven by
FileReference lifetime. Cache map holds few recent
values for unreachable fileobjects.

<p>
Threading - no extra thread is spawned. All operation are
done synchronously. Clients are warned that some methods
can hang forever. It may need to be fixed in future by setting
timeouts (and possibly killing worker threads). However client's
interface will stay the same.

<p>
Debuggibility - small contract containing mainly methods without
behaviour modification parameters (i.e. dedicate methods instead
of one method taking a strategy constant passed all around and
invisible on thread dumps). Some asserts scattered all around code.

<p>
No pluggability. There is only one implementation without
possibility to plug-in different one (vs. the original approach
allowing for diferent cache implementation for javacvs filesystem).
It could be hopefully dropped on request. Important advantage remains -
simple contract counting few methods.

<h3>Status</h3>

WORK IN PROGRESS - SHARING IDEA

<p>
Existing client code contains new code paths guarded by <code>Turbo.implemented()</code>
checks. These are not ready to be used right now. There are still missing
following client code (filesystem and commands) conversions
(it obviously excludes cache and caching packages):
<ul>
  <li>objectidentity package implements CacheHandlerListener, there is nothing like that in
     simplified implementation
  <li>VcsFileSystem.getRealStatus() used in search, it also implements CacheHandlerListener
     to perform refresh
  <li>VcsFilesystem.List.children() support for filtering out DEAD and scheduled files.
      InList context we cannot use FileObject keyed access. Try VisibilityQuery approach.
  <li>RefreshCommandSupport in VCSFileSystem annotation and cvscore.cmdline formatting
  <li>status management translating abstract statuses to profile specifics statuses and vice versa
</ul>

<p>
Documenatation and tests are missing... Special test VCS profile should be
created. It allows backdoor operations - programatically setting its state.
It allows to simulate various situations.
