/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 *
 * Copyright 2008 Sun Microsystems, Inc. All rights reserved.
 *
 * The contents of this file are subject to the terms of either the GNU
 * General Public License Version 2 only ("GPL") or the Common
 * Development and Distribution License("CDDL") (collectively, the
 * "License"). You may not use this file except in compliance with the
 * License. You can obtain a copy of the License at
 * http://www.netbeans.org/cddl-gplv2.html
 * or nbbuild/licenses/CDDL-GPL-2-CP. See the License for the
 * specific language governing permissions and limitations under the
 * License.  When distributing the software, include this License Header
 * Notice in each file and include the License file at
 * nbbuild/licenses/CDDL-GPL-2-CP.  Sun designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Sun in the GPL Version 2 section of the License file that
 * accompanied this code. If applicable, add the following below the
 * License Header, with the fields enclosed by brackets [] replaced by
 * your own identifying information:
 * "Portions Copyrighted [year] [name of copyright owner]"
 *
 * If you wish your version of this file to be governed by only the CDDL
 * or only the GPL Version 2, indicate your decision by binary_adding_operator
 * "[Contributor] elects to include this software in this distribution
 * under the [CDDL or GPL Version 2] license." If you do not indicate a
 * single choice of license, a recipient has the option to distribute
 * your version of this file under either the CDDL, the GPL Version 2 or
 * to extend the choice of license to its licensees as provided above.
 * However, if you add GPL Version 2 code and therefore, elected the GPL
 * Version 2 license, then the option applies only if the new code is
 * made subject to such option by the copyright holder.
 *
 * Contributor(s):
 *
 * Portions Copyrighted 2008 Sun Microsystems, Inc.
 */
package org.netbeans.modules.ada.editor.parser;

import java.util.*;
import org.netbeans.modules.ada.editor.lexer.Ada95ASTLexer;
import org.netbeans.modules.ada.editor.ast.*;
import org.netbeans.modules.ada.editor.ast.nodes.*;

parser code {:
    protected final static Integer PUBLIC = new Integer(BodyDeclaration.Modifier.PUBLIC);
    protected final static Integer PRIVATE = new Integer(BodyDeclaration.Modifier.PRIVATE);
    protected final static Integer TAGGED = new Integer(BodyDeclaration.Modifier.TAGGED);
    protected final static Integer LIMITED = new Integer(BodyDeclaration.Modifier.LIMITED);
    protected final static Integer ABSTRACT = new Integer(BodyDeclaration.Modifier.ABSTRACT);

    private ErrorStrategy defaultStrategy = new DefaultErrorStrategy();;
    private ErrorStrategy errorStrategy = defaultStrategy;

    private ParserErrorHandler errorHandler = null;

    public void setErrorHandler (ParserErrorHandler handler) {
        this.errorHandler = handler;
    }

    public ParserErrorHandler getErrorHandler () {
        return this.errorHandler;
    }

/*
    public Dispatch createDispatch(VariableBase dispatcher, VariableBase property) {
        Dispatch dispatch = null;
	if (property instanceof Variable) {
	   dispatch = new FieldAccess(dispatcher.getStartOffset(), property.getEndOffset(), dispatcher, (Variable)property);
	} else if (property instanceof FunctionInvocation) {
	   dispatch = new MethodInvocation(dispatcher.getStartOffset(), property.getEndOffset(), dispatcher, (FunctionInvocation)property);
	} else if (property instanceof ProcedureInvocation) {
	   dispatch = new MethodInvocation(dispatcher.getStartOffset(), property.getEndOffset(), dispatcher, (ProcedureInvocation)property);
	} else {
	   throw new IllegalArgumentException();
	}
        return dispatch;
    }
*/

    public List setModifier(List items, int modifier) {
        List list = new LinkedList();
        for (Iterator iter = items.iterator(); iter.hasNext();) {
            final Object next = iter.next();
            if (next instanceof TypeDeclaration) {
                ((TypeDeclaration)next).setModifier(modifier);
                list.add(next);
            } else if (next instanceof MethodDeclaration) {
                ((MethodDeclaration)next).setModifier(modifier);
                list.add(next);
            } else if (next instanceof FieldsDeclaration) {
                ((FieldsDeclaration)next).setModifier(modifier);
                list.add(next);
            } else {
                list.add(next);
            }
        }
        return list;
    }

    interface ErrorStrategy {
        public boolean errorRecovery(boolean debug) throws Exception;
    }

    class DefaultErrorStrategy implements ErrorStrategy {

        public boolean errorRecovery(boolean debug) throws Exception {
            return Ada95ASTParser.super.error_recovery(debug);
        }
    }

    /**
     * Attempt to recover from a syntax error.  This returns false if recovery fails,
     * true if it succeeds.
     * @param debug should we produce debugging messages as we parse.
     */
    @Override
    protected boolean error_recovery(boolean debug) throws java.lang.Exception {
        return errorStrategy.errorRecovery(debug);
    }

    /**
     * Report a non fatal error (or warning).  This method takes a message
     * string and an additional object (to be used by specializations implemented in subclasses).
     * The super class prints the message to System.err.
     * @param message an error message.
     * @param info    an extra object reserved for use by specialized subclasses.
     */
    @Override
    public void report_error(String message, Object info) {
        System.out.print("report_eror"  + message);
    }	

    /**
     * This method is called when a syntax error has been detected and recovery is about to be invoked.
     * The super class just emit a "Syntax error" error message.
     * @param cur_token the current lookahead Symbol.
     */
    @Override
    public void syntax_error(java_cup.runtime.Symbol cur_token) {
        java_cup.runtime.Symbol symbol = (java_cup.runtime.Symbol)stack.peek();
        int state = symbol.parse_state;
        short[] rowOfProbe = action_tab[state];
        if (errorHandler != null) {
            errorHandler.handleError(ParserErrorHandler.Type.SYNTAX_ERROR, rowOfProbe, cur_token, symbol);
        }
     }

    /**
     * This method is called when a syntax error has been detected during action.
     * @param message an error message.
     */
    public void message_error(String message) {
        java_cup.runtime.Symbol symbol = (java_cup.runtime.Symbol)stack.peek();
        if (errorHandler != null) {
            errorHandler.handleError(ParserErrorHandler.Type.SYNTAX_ERROR, symbol, message);
        }
     }

     /**
     * Report a fatal error.  This method takes a message string and an additional object
     * (to be used by specializations implemented in subclasses).
     * The super class reports the error then throws an exception.
     * @param message an error message.
     * @param info    an extra object reserved for use by specialized subclasses.
     */
    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        if (errorHandler != null) {
            errorHandler.handleError(ParserErrorHandler.Type.FATAL_PARSER_ERROR, null, cur_token, null);
        }
    }

    @Override
    protected int error_sync_size() {
        return 1;
    }

:}


/*********************************************************
 *                                                       *
 * Ada 95 (LALR) AST Parser, based on:                   *
 *                                                       *
 * 1. Ada Reference Manual                               *
 *    ISO/IEC 8652:1995(E)                               *
 *    with Technical Corrigendum 1                       *
 *    Language and Standard Libraries                    *
 *    Copyright © 1992,1993,1994,1995 Intermetrics, Inc. *
 *    Copyright © 2000 The MITRE Corporation, Inc.       *
 * 2. http://www.adaic.com/standards/95lrm/grammar9x.y   *
 *                                                       *
 * Author: Andrea Lucarelli                              *
 * Parser Generator: JavCup                              *
 *                                                       *
 *********************************************************/

/*************************
 * JavaCup Terminals     *
 *************************/

//
// Ada 95 keywords
//
terminal ABORT;
terminal ABS;
terminal ABSTRACT;
terminal ACCESS;
terminal ACCEPT;
terminal ALIASED;
terminal ALL;
terminal AND;
terminal ARRAY;
terminal AT;
terminal BEGIN;
terminal BODY;
terminal CONSTANT;
terminal CASE;
terminal DECLARE;
terminal DELAY;
terminal DELTA;
terminal DIGITS;
terminal DO;
terminal ELSE;
terminal ELSIF;
terminal END;
terminal ENTRY;
terminal EXCEPTION;
terminal EXIT;
terminal FOR;
terminal FUNCTION;
terminal GENERIC;
terminal GOTO;
terminal IF;
terminal IN;
terminal IS;
terminal LIMITED;
terminal LOOP;
terminal MOD;
terminal NEW;
terminal NOT;
terminal NULL;
terminal OF;
terminal OR;
terminal OTHERS;
terminal OUT;
terminal PACKAGE;
terminal PRAGMA;
terminal PRIVATE;
terminal PROCEDURE;
terminal PROTECTED;
terminal RETURN;
terminal REVERSE;
terminal RAISE;
terminal RANGE;
terminal RECORD;
terminal REM;
terminal RENAMES;
terminal REQUEUE;
terminal SELECT;
terminal SEPARATE;
terminal SUBTYPE;
terminal TAGGED;
terminal TASK;
terminal TERMINATE;
terminal THEN;
terminal TYPE;
terminal UNTIL;
terminal USE;
terminal WHEN;
terminal WHILE;
terminal WITH;
terminal XOR;

// 2.2 Lexical Elements, Separators, and Delimiters

//
// delimiters
//
terminal AMP;
terminal TICK;
terminal LPAREN;
terminal RPAREN;
terminal STAR;
terminal PLUS;
terminal COMMA;
terminal MINUS;
terminal DOT;
terminal SLASH;
terminal COLON;
terminal SEMICOLON;
terminal GT;
terminal EQ;
terminal LT;
terminal BAR;

//
// compound delimiters
//
terminal ARROW;
terminal DOT_DOT;
terminal EXPON;
terminal ASSIGNMENT;
terminal INEQ;
terminal GTEQ;
terminal LTEQ;
terminal LTLT;
terminal GTGT;
terminal BOX;

//
// others tokens
//
// ??? terminal String OPERATOR_SYMBOL;
terminal String CHAR_LITERAL;    // 2.1 Character Set
terminal String IDENTIFIER;      // 2.3 Identifiers
terminal String DECIMAL_LITERAL; // 2.4.1 Decimal Literals
terminal String BASED_LITERAL;   // 2.4.2 Based Literals
terminal String STRING_LITERAL;  // 2.6 String Literals


/*************************
 * JavaCup Non terminals *
 *************************/

// 3.1 Declarations
non terminal Statement               declaration;
non terminal List                    fields_declaration;
non terminal Statement               type_declaration;
non terminal Statement               subprog_declaration;
non terminal Identifier              defining_identifier;

// 3.11 Declarative Parts
non terminal List                    declarative_items_opt;
non terminal List                    declarative_item_list;
non terminal Statement               declarative_item;
non terminal List                    declarative_part;
non terminal List                    declarative_item_or_body_s1;
non terminal List                    private_part;
non terminal Statement               proper_body;
non terminal Statement               task_body;

// 3.2.1 Type Declarations
non terminal Expression              type_definition;

// 3.2.2 Subtype Declarations
non terminal Statement               subtype_declaration;
non terminal TypeName                subtype_indication;

// 3.3.1 Object Declarations
non terminal List                    object_declaration;
non terminal List                    defining_identifier_list;
non terminal Variable.Kind           object_qualifier_opt;

// 3.3.2 Number Declarations
non terminal List                    number_declaration;

// 4.1 Names
non terminal String                  name;
non terminal String                  simple_name;

// 4.1.3 Selected Components
non terminal String                  selected_component;

// 4.4 Expressions
non terminal Expression              expression;
non terminal Expression              relation;
non terminal Expression              simple_expression;
non terminal Expression              term;
non terminal Expression              factor;
non terminal Expression              primary;

// 4.5 Operators and Expression Evaluation
non terminal String                  logical_operator;
non terminal String                  relational_operator;
non terminal UnaryOperation.Operator binary_adding_operator;
non terminal UnaryOperation.Operator unary_adding_operator;
non terminal String                  multiplying_operator;

// 4.7 Qualified Expressions
non terminal Expression              qualified_expression;

// 5.1 Simple and Compound Statements - Sequences of Statements
non terminal List                    sequence_of_statements;
non terminal Statement               simple_statement;
non terminal Statement               compound_statement;
non terminal Statement               null_statement;

// 5.2 Assignment Statements
non terminal Statement               assignment_statement;

// 5.3 If Statements
non terminal IfStatement             if_statement;
non terminal List[]                  cond_clause_s;
non terminal Expression              condition;
non terminal Block                   else_opt;

// 5.4 Case Statements
non terminal CaseStatement           case_statement;
non terminal List                    alternative_s;
non terminal CaseWhen                alternative;

// 5.5 Loop Statements
non terminal LoopStatement           loop_statement;
non terminal Block                   basic_loop;
non terminal Expression              iteration;

// 5.6 Block Statements
non terminal BlockStatement          block_statement;
non terminal Block                   block_declarative;
non terminal Block                   block_body;

// 5.7 Exit Statements
non terminal Statement               exit_statement;
non terminal String                  name_opt;

// 5.8 Goto Statements
non terminal Statement               goto_statement;

// 6.1 Subprogram Declarations
non terminal SubprogramSpecification subprogram_specification;
non terminal SubprogramSpecification generic_subp_inst;
non terminal MethodDeclaration       subprogram_body;
non terminal List                    param_s;
non terminal List                    formal_part_opt;
non terminal List                    formal_part;
non terminal List                    param;
non terminal FormalParameter.Mode    mode;
non terminal String                  designator;
non terminal String                  operator_symbol;

// 6.5 Return Statements
non terminal Statement               return_statement;

// 7.1 Package Specifications and Declarations
non terminal Statement               package_declaration;
non terminal Statement               package_specification;
			        
// 7.2 Package Bodies	        
non terminal Statement               package_body;
non terminal Statement               body;

// 7.3 Private Types and Private Extensions
non terminal PrivateType             private_type_declaration;
non terminal Integer                 tagged_opt;
non terminal Integer                 limited_opt;

// 8.4 Use Clauses
non terminal Statement               use_clause;
non terminal List                    package_name_list;
non terminal List                    subtype_mark_list;

// 8.5 Renaming Declarations
non terminal Statement               renaming_declaration;
non terminal Statement               rename_unit;

// 9.4 Protected Units and Protected Objects
non terminal Statement               protected_body;

// 9.6 Delay Statements, Duration, and Time
non terminal Statement               delay_statement;

// 9.8 Abort of a Task - Abort of a Sequence of Statements
non terminal Statement               abort_statement;
non terminal List                    task_name_list;

// 10.1.1 Compilation Units - Library Units
non terminal Program                 compilation;
non terminal List                    compilation_units;
non terminal Statement               compilation_unit;
non terminal Statement               unit;

// 10.1.2 Context Clauses - With Clauses
non terminal Statement               context_clause;
non terminal Statement               with_clause;
non terminal List                    library_unit_name_list;

// 10.1.3 Subunits of Compilation Units
non terminal Statement               body_stub;

// 11.3 Raise Statements
non terminal Statement               raise_statement;

// 12.1 Generic Declarations
non terminal Statement               generic_declaration;

// 13.8 Machine Code Insertions
non terminal Statement               code_statement;


// TBD sections
non terminal String                  compound_name;
non terminal String                  compound_name_opt;
non terminal TypeName                object_subtype_def;
non terminal Expression              init_opt;
non terminal Statement               type_decl;
non terminal Expression              type_completion;
non terminal String                  subtype_mark;
non terminal List                    handled_stmt_s;
non terminal Statement               statement;
non terminal Statement               subunit;
non terminal String                  id_opt;
non terminal Statement               unlabeled;
non terminal Expression              literal;
non terminal Expression              parenthesized_primary;
non terminal Expression              when_opt;
non terminal Statement               procedure_call_statement;
non terminal String                  used_char;
non terminal Expression              choice_s;
non terminal String                  label_opt;
non terminal String                  attribute;
non terminal String                  indexed_comp; // TODO: must be change it
non terminal Expression              value_s;
non terminal Expression              discrete_range;
non terminal Expression              range;

// TBD RM sections and types
non terminal     pragma;
non terminal     pragma_arg_s;
non terminal     pragma_arg;
non terminal     pragma_s;
non terminal     task_decl;
non terminal     prot_decl;
non terminal     exception_decl;
non terminal     discrim_part_opt;
non terminal     discrim_part;
non terminal     enumeration_type;
non terminal     integer_type;
non terminal     real_type;
non terminal     array_type;
non terminal     record_type;
non terminal     access_type;
non terminal     derived_type;
non terminal     constraint;
non terminal     range_constraint;
non terminal     decimal_digits_constraint;
non terminal     range_constr_opt;
non terminal     record_def;
non terminal     enum_id_s;
non terminal     enum_id;
non terminal     range_spec;
non terminal     range_spec_opt;
non terminal     float_type;
non terminal     fixed_type;
non terminal     unconstr_array_type;
non terminal     constr_array_type;
non terminal     index_s;
non terminal     index;
non terminal     component_subtype_def;
non terminal     aliased_opt;
non terminal     iter_index_constraint;
non terminal     iter_discrete_range_s;
non terminal     comp_list;
non terminal     comp_decl_s;
non terminal     comp_decl;
non terminal     variant_part_opt;
non terminal     variant_part;
non terminal     discrim_spec_s;
non terminal     discrim_spec;
non terminal     access_opt;
non terminal     variant_s;
non terminal     variant;
non terminal     choice;
non terminal     discrete_with_range;
non terminal     prot_opt;
non terminal     rep_spec;
non terminal     declarative_item_or_body;
non terminal     attribute_id;
non terminal     value;
non terminal     comp_assoc;
non terminal     aggregate;
non terminal     value_s_2;
non terminal     short_circuit;
non terminal     membership;
non terminal     allocator;
non terminal     label;
non terminal     requeue_stmt;
non terminal     accept_stmt;
non terminal     select_stmt;
non terminal     iter_part;
non terminal     reverse_opt;
non terminal     except_handler_part_opt;
non terminal     except_handler_part;
non terminal     generic_package_instantiation;
non terminal     body_opt;
non terminal     generic_formal_part;
non terminal     task_spec;
non terminal     task_def;
non terminal     entry_decl_s;
non terminal     rep_spec_s;
non terminal     task_private_opt;
non terminal     prot_spec;
non terminal     prot_def;
non terminal     prot_op_decl_s;
non terminal     prot_private_opt;
non terminal     prot_elem_decl_s;
non terminal     prot_op_decl;
non terminal     entry_decl;
non terminal     prot_elem_decl;
non terminal     prot_op_body_s;
non terminal     prot_op_body;
non terminal     entry_body;
non terminal     entry_body_part;
non terminal     accept_hdr;
non terminal     entry_call;
non terminal     entry_name;
non terminal     select_wait;
non terminal     async_select;
non terminal     timed_entry_call;
non terminal     cond_entry_call;
non terminal     guarded_select_alt;
non terminal     or_select;
non terminal     select_alt;
non terminal     stmts_opt;
non terminal     delay_or_entry_alt;
non terminal     private_opt;
non terminal     exception_handler;
non terminal     except_choice_s;
non terminal     except_choice;
non terminal     generic_formal;
non terminal     generic_discrim_part_opt;
non terminal     generic_type_def;
non terminal     subp_default;
non terminal     generic_derived_type;
non terminal     generic_inst;
non terminal     attrib_def;
non terminal     record_type_spec;
non terminal     address_spec;
non terminal     align_opt;
non terminal     comp_loc_s;

/*************************
 * JavaCup precedence    *
 *************************/

//precedence left OR;
//precedence left XOR;
//precedence left AND;

//precedence left SEMICOLON;

//precedence left ELSIF;
//precedence left ELSE;
//precedence left END IF;

///////////////////////////////////////////////////////////////////////////////
// start with root symbol 
//
start with compilation;

/*****************
 *               *
 * Ada 95 syntax *
 *               *
 *****************/

///////////////////////////////////////////////////////////////////////////////
// 2.8 Pragmas
//
pragma  ::= PRAGMA IDENTIFIER SEMICOLON
	| PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
	;

pragma_arg_s ::= pragma_arg
	| pragma_arg_s COMMA pragma_arg
	;

pragma_arg ::= expression
	| simple_name ARROW expression
	;

pragma_s ::=
	| pragma_s pragma
	;

///////////////////////////////////////////////////////////////////////////////
// 3.1 Declarations
//
fields_declaration ::=
object_declaration:statement
{:
	RESULT = statement;
:}
| number_declaration:statement
{:
	RESULT = statement;
:}
;

type_declaration ::=
type_decl:statement
{:
	RESULT = statement;
:}
| subtype_declaration:statement
{:
	RESULT = statement;
:}
;

declaration ::=
task_decl
| prot_decl
| exception_decl
| renaming_declaration:statement
{:
	RESULT = statement;
:}
| generic_declaration:statement
{:
	RESULT = statement;
:}
| body_stub:statement
{:
	RESULT = statement;
:}
| error:theError SEMICOLON // error statement
{:
    ASTError error = new ASTError(theErrorleft, theErrorright);
    RESULT = error;
:}
;

defining_identifier ::=
IDENTIFIER:id
{:
    Identifier identifier = new Identifier(idleft, idright, id);
    RESULT = identifier;
:}
;

///////////////////////////////////////////////////////////////////////////////
// 3.3.1 Object Declarations
//
object_declaration ::= 
defining_identifier_list:identifierList COLON object_qualifier_opt:varKind object_subtype_def:subtype init_opt:init SEMICOLON
{:
    List list = new LinkedList();
    for (Object identifier : identifierList) {
        Variable variable = new Variable (((Identifier)identifier).getStartOffset(), ((Identifier)identifier).getEndOffset(), (Identifier)identifier, varKind, subtype);
        list.add(new ASTNode[] {variable, init});
    }
    RESULT = list;
:}
;

defining_identifier_list ::= 
defining_identifier:identifier
{:
    List identifierList = new LinkedList();
    identifierList.add(identifier);
    RESULT = identifierList;
:}
| defining_identifier_list:identifierList COMMA defining_identifier:identifier
{:
    identifierList.add(identifier);
    RESULT = identifierList;
:}
;

object_qualifier_opt ::=
{:
    RESULT = Variable.Kind.DEFAULT;
:}
| ALIASED
{:
    RESULT = Variable.Kind.ALIASED;
:}
| CONSTANT
{:
    RESULT = Variable.Kind.CONSTANT;
:}
| ALIASED CONSTANT
{:
    RESULT = Variable.Kind.ALIASED_CONSTANT;
:}
;

object_subtype_def ::= 
subtype_indication:subtype
{:
    RESULT = subtype;
:}
| array_type:array
;

init_opt ::=
{:
    RESULT = null;
:}
| ASSIGNMENT expression:expr
{:
    RESULT = expr;
:}
;

///////////////////////////////////////////////////////////////////////////////
// 3.3.2 Number Declarations
//
number_declaration ::= 
defining_identifier_list:identifierList COLON CONSTANT ASSIGNMENT expression:init SEMICOLON
{:
    List list = new LinkedList();
    for (Object identifier : identifierList) {
        Variable variable = new Variable (((Identifier)identifier).getStartOffset(), ((Identifier)identifier).getEndOffset(), (Identifier)identifier, Variable.Kind.CONSTANT);
        list.add(new ASTNode[] {variable, init});
    }
    RESULT = list;
:}
;

type_decl ::= 
TYPE:token defining_identifier:identifier discrim_part_opt type_completion:typeCompletion SEMICOLON:end
{:
    TypeDeclaration type = new TypeDeclaration (tokenleft, endright, identifier, typeCompletion);
    RESULT = type;
:}
;

discrim_part_opt ::=
	| discrim_part
	| LPAREN BOX RPAREN
	;

type_completion ::=
// empty
{:
    RESULT = null;
:}
| IS type_definition:typeDef
{:
    RESULT = typeDef;
:}
;

type_definition ::=
enumeration_type 
| integer_type
| real_type
| array_type
| record_type
| access_type
| derived_type
| private_type_declaration:privateType
{:
    RESULT = privateType;
:}
;

///////////////////////////////////////////////////////////////////////////////
// 3.2.2 Subtype Declarations
//
subtype_declaration ::=
SUBTYPE:token defining_identifier:identifier IS subtype_indication:subtypeIndication SEMICOLON:end
{:
    SubtypeDeclaration type = new SubtypeDeclaration (tokenleft, endright, identifier, subtypeIndication);
    RESULT = type;
:}
;

subtype_indication ::= 
name:name constraint
{:    
    Identifier identifier = new Identifier(nameleft, nameright, name);
    TypeName type = new TypeName (nameleft, nameright, identifier);
    RESULT = type;
:}
| name:name
{:    
    Identifier identifier = new Identifier(nameleft, nameright, name);
    TypeName type = new TypeName (nameleft, nameright, identifier);
    RESULT = type;
:}
;

constraint ::= range_constraint
	| decimal_digits_constraint
	;

decimal_digits_constraint ::= DIGITS expression range_constr_opt
	;

derived_type ::= NEW subtype_indication
	| NEW subtype_indication WITH PRIVATE
	| NEW subtype_indication WITH record_def
	| ABSTRACT NEW subtype_indication WITH PRIVATE
	| ABSTRACT NEW subtype_indication WITH record_def
	;

range_constraint ::= RANGE range
	;

range ::=
simple_expression:simple_expr DOT_DOT simple_expression
{:
    RESULT = simple_expr;
:}
| name TICK RANGE
| name:name TICK RANGE LPAREN expression:expr RPAREN
{:
    RESULT = expr;
:}
;

enumeration_type ::= LPAREN enum_id_s RPAREN
        ;

enum_id_s ::= enum_id
	| enum_id_s COMMA enum_id
	;

enum_id ::= IDENTIFIER
	| CHAR_LITERAL
	;

integer_type ::= range_spec
	| MOD expression
	;
	

range_spec ::= range_constraint
	;

range_spec_opt ::=
	| range_spec
	;

real_type ::= float_type
	| fixed_type
	;

float_type ::= DIGITS expression range_spec_opt
	;

fixed_type ::= DELTA expression range_spec
	| DELTA expression DIGITS expression range_spec_opt
	;

array_type ::= unconstr_array_type
	| constr_array_type
	;

unconstr_array_type ::= ARRAY LPAREN index_s RPAREN OF component_subtype_def
	;

constr_array_type ::= ARRAY iter_index_constraint OF component_subtype_def
	;

component_subtype_def ::= aliased_opt subtype_indication
	;

aliased_opt ::= 
	| ALIASED
	;

index_s ::= index
	| index_s COMMA index
	;

index ::= name RANGE BOX
	;

iter_index_constraint ::= LPAREN iter_discrete_range_s RPAREN
	;

iter_discrete_range_s ::= discrete_range
	| iter_discrete_range_s COMMA discrete_range
	;

discrete_range ::=
name range_constr_opt
| range:range
{:
    RESULT = range;
:}
;

range_constr_opt ::=
	| range_constraint
	;

record_type ::= tagged_opt limited_opt record_def
	;

record_def ::= RECORD pragma_s comp_list END RECORD
	| NULL RECORD
	;

tagged_opt ::=
{:
    RESULT = 0;
:}
| TAGGED
{:
    RESULT = Ada95ASTParser.TAGGED;
:}
| ABSTRACT TAGGED
{:
    RESULT = Ada95ASTParser.TAGGED + Ada95ASTParser.ABSTRACT;
:}
;

comp_list ::= comp_decl_s variant_part_opt
	| variant_part pragma_s
	| NULL SEMICOLON pragma_s
	;

comp_decl_s ::= comp_decl
	| comp_decl_s pragma_s comp_decl
	;

variant_part_opt ::= pragma_s
	| pragma_s variant_part pragma_s
	;

comp_decl ::= 
defining_identifier_list COLON component_subtype_def init_opt SEMICOLON
| error:theError SEMICOLON
{:
    ASTError error = new ASTError(theErrorleft, theErrorright);
    RESULT = error;
:}
;

discrim_part ::= LPAREN discrim_spec_s RPAREN
	;

discrim_spec_s ::= discrim_spec
	| discrim_spec_s SEMICOLON discrim_spec
	;

discrim_spec ::= 
defining_identifier_list COLON access_opt subtype_mark init_opt
| error:theError  // error statement
{:
    ASTError error = new ASTError(theErrorleft, theErrorright);
    RESULT = error;
:}
;

access_opt ::=
	| ACCESS
	;

variant_part ::= CASE simple_name IS pragma_s variant_s END CASE SEMICOLON
	;

variant_s ::= variant
	| variant_s variant
	;

variant ::= WHEN choice_s ARROW pragma_s comp_list
	;

choice_s ::= choice
	| choice_s BAR choice
	;

choice ::= expression
	| discrete_with_range
	| OTHERS
	;

discrete_with_range ::= name range_constraint
	| range
	;

access_type ::= ACCESS subtype_indication
	| ACCESS CONSTANT subtype_indication
	| ACCESS ALL subtype_indication
	| ACCESS prot_opt PROCEDURE formal_part_opt
	| ACCESS prot_opt FUNCTION formal_part_opt RETURN subtype_mark
	;

prot_opt ::=
	| PROTECTED
	;

///////////////////////////////////////////////////////////////////////////////
// 3.11 Declarative Parts
//
declarative_part ::=
{:
    RESULT = new LinkedList();
:}
| declarative_item_or_body_s1:statement
{:
    RESULT = statement;
:}
;

declarative_items_opt ::=
// empty
{:
    RESULT = new LinkedList();
:}
| declarative_item_list:declaritiveItemList
{:
    RESULT = declaritiveItemList;
:}
;

declarative_item_list ::=
declarative_item:declaritiveItem
{:
    List declaritiveItemList = new LinkedList();
    declaritiveItemList.add(declaritiveItem);
    RESULT = declaritiveItemList;
:}
| declarative_item_list:declaritiveItemList declarative_item:declaritiveItem
{:
    declaritiveItemList.add(declaritiveItem);
    RESULT = declaritiveItemList;
:}
;

declarative_item ::=
fields_declaration:list
{:
    FieldsDeclaration fieldsDeclaration = new FieldsDeclaration(listleft, listright, list);
    RESULT = fieldsDeclaration;
:}
| type_declaration:statement
{:
    RESULT = statement;
:}
| subprog_declaration:statement
{:
    RESULT = statement;
:}
| package_declaration:statement
{:
    RESULT = statement;
:}
| declaration:statement // todo: to be split
{:
    RESULT = statement;
:}
| use_clause:statement
{:
    RESULT = statement;
:}
| rep_spec
| pragma
;

declarative_item_or_body_s1 ::=
declarative_item_or_body:declaritiveItem
{:
    List declaritiveItemList = new LinkedList();
    declaritiveItemList.add(declaritiveItem);
    RESULT = declaritiveItemList;
:}
| declarative_item_or_body_s1:declaritiveItemList declarative_item_or_body:declaritiveItem
{:
    declaritiveItemList.add(declaritiveItem);
    RESULT = declaritiveItemList;
:}
;

declarative_item_or_body ::=
body:statement
{:
    RESULT = statement;
:}
| declarative_item:statement
{:
    RESULT = statement;
:}
;

body ::=
subprogram_body:statement
{:
    RESULT = statement;
:}
| package_body:statement
{:
    RESULT = statement;
:}
| task_body:statement
{:
    RESULT = statement;
:}
| protected_body:statement
{:
    RESULT = statement;
:}
;

proper_body ::=
subprogram_body:statement
{:
    RESULT = statement;
:}
| package_body:statement
{:
    RESULT = statement;
:}
| task_body:statement
{:
    RESULT = statement;
:}
| protected_body:statement
{:
    RESULT = statement;
:}
;


name ::=
simple_name:name
{:
    RESULT = name;
:}
| indexed_comp:comp
{:
    RESULT = comp;
:}
| selected_component:comp
{:
    RESULT = comp;
:}
| attribute:attr
{:
    RESULT = attr;
:}
| operator_symbol:op
{:
    RESULT = op;
:}
;

subtype_mark ::=
simple_name:name
{:
    RESULT = name;
:}
| subtype_mark:name TICK attribute_id
{:
    // TODO: manage the attribute
    RESULT = name;
:}
| subtype_mark:name DOT simple_name:simpleName
{:
    RESULT = name + "." + simpleName;
:}
;

simple_name ::=
IDENTIFIER:identifier
{:
    RESULT = identifier;
:}
;

compound_name ::=
simple_name:simpleName
{:
    RESULT = simpleName;
:}
| compound_name:compoundName DOT simple_name:simpleName
{:
    RESULT = compoundName + "." + simpleName;
:}
;

library_unit_name_list ::=
compound_name:compoundName
{:
    List nameList = new LinkedList();
    Identifier id = new Identifier(compoundNameleft, compoundNameright, (String)compoundName);
    PackageName packageName = new PackageName(compoundNameleft, compoundNameright, id);
    nameList.add(packageName);
    RESULT = nameList;
:}
| library_unit_name_list:nameList COMMA compound_name:compoundName
{:
    nameList.add(compoundName);
    RESULT = nameList;
:}
;

used_char ::=
CHAR_LITERAL:charLiteral
{:
    RESULT = charLiteral;
:}
;

indexed_comp ::=
name:name LPAREN value_s:index RPAREN:end
{:
    System.out.println ("indexed_comp ::= name => " + name);
    Identifier identifier = new Identifier(nameleft, nameright, name);
    //Variable variable = new Variable (nameleft, nameright, name);
	Variable indexedVar = new ArrayAccess(nameleft, endright, identifier, index, ArrayAccess.Type.VARIABLE_ARRAY);
    //RESULT = indexedVar;
    RESULT = name;
:}
;

value_s ::= value
	| value_s COMMA value
	;

value ::= expression
| comp_assoc
| discrete_with_range
| error:theError /* error statement */
{:
    ASTError error = new ASTError(theErrorleft, theErrorright);
    RESULT = error;
:}
;

///////////////////////////////////////////////////////////////////////////////
// 4.1.3 Selected Components
//
selected_component ::=
name:name DOT simple_name:simpleName
{:
    RESULT = name + "." + simpleName;
:}
| name:name DOT used_char:usedChar
{:
    RESULT = name + "." + usedChar;
:}
| name:name DOT operator_symbol:operator
{:
    RESULT = name + "." + operator;
:}
| name:name DOT ALL:all
{:
    RESULT = name + "." + all;
:}
;

attribute ::=
name:name TICK attribute_id
{:
    RESULT = name;
:}
;

attribute_id ::= IDENTIFIER
	| DIGITS
	| DELTA
	| ACCESS
	;

literal ::=
DECIMAL_LITERAL:dec
{:
	Scalar scalar = new Scalar(decleft, decright, dec, Scalar.Type.INT);
	RESULT = scalar;
:}
| BASED_LITERAL:dec
{:
	Scalar scalar = new Scalar(decleft, decright, dec, Scalar.Type.INT);
	RESULT = scalar;
:}
| used_char:usedChar
{:
	Scalar scalar = new Scalar(usedCharleft, usedCharright, usedChar, Scalar.Type.STRING);
	RESULT = scalar;
:}
| NULL
;

aggregate ::= LPAREN comp_assoc RPAREN
	| LPAREN value_s_2 RPAREN
	| LPAREN expression WITH value_s RPAREN
	| LPAREN expression WITH NULL RECORD RPAREN
	| LPAREN NULL RECORD RPAREN
	;

value_s_2 ::= value COMMA value
	| value_s_2 COMMA value
	;

comp_assoc ::= choice_s ARROW expression
	;


///////////////////////////////////////////////////////////////////////////////
// 4.5 Operators and Expression Evaluation
//
logical_operator ::=
AND
| OR
| XOR
;

short_circuit ::= AND THEN
	| OR ELSE
	;


relational_operator ::=
EQ
| INEQ
| GT
| LTEQ
| LT
| GTEQ
;

membership ::= IN
	| NOT IN
	;

unary_adding_operator ::=
PLUS
{:
    RESULT = UnaryOperation.Operator.PLUS;
:}
| MINUS
{:
    RESULT = UnaryOperation.Operator.MINUS;
:}
;

binary_adding_operator ::= 
PLUS
{:
    RESULT = UnaryOperation.Operator.PLUS;
:}
| MINUS
{:
    RESULT = UnaryOperation.Operator.MINUS;
:}
| AMP
{:
    RESULT = UnaryOperation.Operator.AMP;
:}
;

multiplying_operator ::=
STAR
| SLASH
| MOD
| REM
;

///////////////////////////////////////////////////////////////////////////////
// 4.4 Expressions
//
expression ::=
relation:rel
{:
    System.out.println ("expression ::= relation => " + rel);
	RESULT = rel;
:}
| expression:expr logical_operator relation:rel
{:
    System.out.println ("expression ::= expression => " + expr);
    System.out.println ("expression ::= relation => " + rel);
	RESULT = expr;
:}
| expression:expr short_circuit relation:rel
{:
    System.out.println ("expression ::= expression => " + expr);
    System.out.println ("expression ::= relation => " + rel);
	RESULT = expr;
:}
;

relation ::=
simple_expression:simple_expr
{:
    RESULT = simple_expr;
:}
| simple_expression:simple_expr relational_operator simple_expression
{:
    RESULT = simple_expr;
:}
| simple_expression:simple_expr membership range
{:
    RESULT = simple_expr;
:}
| simple_expression:simple_expr membership name
{:
    RESULT = simple_expr;
:}
;

simple_expression ::=
unary_adding_operator:op term:term
{:
	RESULT = new UnaryOperation(opleft, termright, term, op);
:}
| term:term
{:
    RESULT = term;
:}
| simple_expression:expr binary_adding_operator:op term:term
{:
	RESULT = new UnaryOperation(exprleft, termright, term, op);
:}
;

term ::=
factor:factor
{:
    RESULT = factor;
:}
| term multiplying_operator factor:factor
{:
    RESULT = factor;
:}
;

factor ::=
primary:primary
{:
    RESULT = primary;
:}
| NOT primary:primary
{:
    RESULT = primary;
:}
| ABS primary:primary
{:
    RESULT = primary;
:}
| primary EXPON primary:primary
{:
    RESULT = primary;
:}
;

primary ::=
literal:literal
{:
    System.out.println ("primary ::= literal => " + literal);
    RESULT = literal;
:}
| name:name
{:
    System.out.println ("primary ::= name => " + name);
    Scalar scalar = new Scalar(nameleft, nameright, name, Scalar.Type.STRING);
    RESULT = scalar;
:}
| allocator
| qualified_expression:expr
{:
    System.out.println ("primary ::= qualified_expression => " + expr);
    RESULT = expr;
:}
| parenthesized_primary:expr
{:
    System.out.println ("primary ::= parenthesized_primary => " + expr);
    RESULT = expr;
:}
;

parenthesized_primary ::=
aggregate
| LPAREN expression:expr RPAREN
{:
    RESULT = expr;
:}
;

qualified_expression ::=
name:name TICK parenthesized_primary:expr
{:
    Identifier subtypeMark = new Identifier (nameleft, nameright, name);
    RESULT = new QualifiedExpression (nameleft, exprright, subtypeMark, expr);
:}
;

allocator ::= NEW name
	| NEW qualified_expression
	;

///////////////////////////////////////////////////////////////////////////////
// 5.1 Simple and Compound Statements - Sequences of Statements
//
sequence_of_statements ::=
statement:statement
{:
    List list = new LinkedList();
    list.add(statement);
    RESULT = list;
:}
| sequence_of_statements:list statement:statement
{:
    list.add(statement);
    RESULT = list;
:}
;

statement ::=
unlabeled:statement
{:
    RESULT = statement;
:}
| label statement:statement
{:
    RESULT = statement;
:}
;

unlabeled ::=
simple_statement:statement
{:
    RESULT = statement;
:}
| compound_statement:statement
{:
    RESULT = statement;
:}
| pragma
;

simple_statement ::=
null_statement:statement
{:
    RESULT = statement;
:}
| assignment_statement:statement
{:
    RESULT = statement;
:}
| exit_statement:statement
{:
    RESULT = statement;
:}
| return_statement:statement
{:
    RESULT = statement;
:}
| goto_statement:statement
{:
    RESULT = statement;
:}
| procedure_call_statement:statement
{:
    RESULT = statement;
:}
| delay_statement:statement
{:
    RESULT = statement;
:}
| abort_statement:statement
{:
    RESULT = statement;
:}
| raise_statement:statement
{:
    RESULT = statement;
:}
| code_statement:statement
{:
    RESULT = statement;
:}
| requeue_stmt
| error:theError SEMICOLON /* error statement */
{:
    ASTError error = new ASTError(theErrorleft, theErrorright);
    RESULT = error;
:}
;

compound_statement ::=
if_statement:statement
{:
    RESULT = statement;
:}
| case_statement:statement
{:
    RESULT = statement;
:}
| loop_statement:statement
{:
    RESULT = statement;
:}
| block_statement:statement
{:
    RESULT = statement;
:}
| accept_stmt
| select_stmt
;

label ::= LTLT IDENTIFIER GTGT
	;

null_statement ::= 
NULL:token SEMICOLON:end
{:
    RESULT = new NullStatement(tokenleft, endright);
:}
;

///////////////////////////////////////////////////////////////////////////////
// 5.2 Assignment Statements
//
assignment_statement ::=
name:var ASSIGNMENT expression:expr SEMICOLON
{:
    System.out.println ("assignment_statement ::= var => " + var);
    System.out.println ("assignment_statement ::= expr => " + expr);
    Identifier id = new Identifier(varleft, varright, var);
    Variable variable = new Variable (varleft, varright, (Identifier)id);
    Assignment assignment = new Assignment(varleft, exprright, variable, expr);
    RESULT = assignment;
:}
;

///////////////////////////////////////////////////////////////////////////////
// 5.3 If Statements
//
if_statement ::= 
IF:token cond_clause_s:condList else_opt:iffalse END IF SEMICOLON:end
{:
    Expression innerCondition = null;
    Expression firstCondition = null;
    Statement trueStatement = null;
    Statement falseStatement = iffalse;
		
    for (int i=1 ; i < condList[0].size() ; i++) {
        innerCondition = (Expression)condList[0].get(i);
        trueStatement = (Statement)condList[1].get(i);
        int start = ((Integer)condList[2].get(i)).intValue();
        falseStatement = new IfStatement(start, endright, innerCondition, trueStatement, falseStatement);
    }
    
    firstCondition = (Expression)condList[0].get(0);
    trueStatement = (Statement)condList[1].get(0);
    int start = ((Integer)condList[2].get(0)).intValue();
    IfStatement ifStatement = new IfStatement(tokenleft, endright, firstCondition, trueStatement, falseStatement);		
	
    RESULT = ifStatement;
:}
;

cond_clause_s ::= 
condition:condition THEN:token sequence_of_statements:iftrue
{:
    List listConditions = new LinkedList();
    List listStatements = new LinkedList();
    List listTokens = new LinkedList();

    Block block = new Block(iftrueleft, iftrueright, iftrue);
    listConditions.add(condition);
    listStatements.add(block);
    listTokens.add(new Integer(tokenleft));

    List[] returnList = new List[] { listConditions, listStatements, listTokens };
	
    RESULT = returnList;
:}
| cond_clause_s:condList ELSIF:token condition:condition THEN sequence_of_statements:iftrue
{:
    Block block = new Block(iftrueleft, iftrueright, iftrue);
    ((LinkedList)condList[0]).addFirst(condition);
    ((LinkedList)condList[1]).addFirst(block);
    ((LinkedList)condList[2]).addFirst(new Integer(tokenleft));

    RESULT = condList;
:}
;

condition ::=
expression:expr
{:
    RESULT = expr;
:}
;

else_opt ::=
/* empty */
{:
    RESULT = null;
:}
| ELSE sequence_of_statements:statements
{:
    Block block = new Block(statementsleft, statementsright, statements);
    RESULT = block;
:}
;

///////////////////////////////////////////////////////////////////////////////
// 5.4 Case Statements
//
case_statement ::=
CASE:token expression:expr IS pragma_s alternative_s:whenList END CASE SEMICOLON:end
{:
    Block whenBlock = new Block(whenListleft, whenListright, whenList);
    CaseStatement caseStatement = new CaseStatement(tokenleft, endright, expr, whenBlock);
    RESULT = caseStatement;
:}
;

alternative_s ::=
/* empty */
{:
    RESULT = new LinkedList();
:}
| alternative_s:whenList alternative:when
{:
    whenList.add (when);
    RESULT = whenList;
:}
;

alternative ::=
WHEN:token choice_s:expr ARROW sequence_of_statements:statements
{:
    CaseWhen caseWhen = new CaseWhen(tokenleft, statementsright, expr, statements);
    RESULT = caseWhen;
:}
;

///////////////////////////////////////////////////////////////////////////////
// 5.5 Loop Statements
//
loop_statement ::=
label_opt:label iteration:iteration basic_loop:statement id_opt SEMICOLON:end
{:
    int start = (label == null) ? iterationleft : labelleft;
    Identifier identifier = new Identifier(labelleft, labelright, label);
    LoopStatement loopStatement = new LoopStatement(start, endright, identifier, iteration, statement);
    RESULT = loopStatement;
:}
;

label_opt ::=
/* empty */
{:
    RESULT = null;
:}
| IDENTIFIER:id COLON
{:
    RESULT = id;
:}
;

iteration ::=
/* empty */
{:
    RESULT = null;
:}
| WHILE condition:condition
{:
    RESULT = condition;
:}
| iter_part reverse_opt discrete_range:condition
{:
    RESULT = condition;
:}
;

iter_part ::=
FOR IDENTIFIER IN
;

reverse_opt ::=
| REVERSE
;

basic_loop ::=
LOOP sequence_of_statements:statements END LOOP
{:
    Block loopBlock = new Block(statementsleft, statementsright, statements);
    RESULT = loopBlock;
:}
;


///////////////////////////////////////////////////////////////////////////////

id_opt ::=
// empty
{:
    RESULT = null;
:}
| designator:name
{:
    RESULT = name;
:}
;

///////////////////////////////////////////////////////////////////////////////
// 5.6 Block Statements
//
block_statement ::=
label_opt:label block_declarative:declarations block_body:body END id_opt SEMICOLON:end
{:
    int start = (label == null) ? declarationsleft : labelleft;
    Identifier identifier = new Identifier(labelleft, labelright, label);
    BlockStatement blockStatement = new BlockStatement (start, endleft, identifier, declarations, body);
    RESULT = blockStatement;
:}
;

block_declarative ::=
{:
    RESULT = null;
:}
| DECLARE:token declarative_part:declarativePart
{:
    Block declarations = new Block(tokenright, declarativePartleft, declarativePart);
    RESULT = declarations;
:}
;

block_body ::=
BEGIN:token handled_stmt_s:statements
{:
    Block body = new Block(tokenright, statementsright, statements);
    RESULT = body;
:}
;

handled_stmt_s ::=
sequence_of_statements:statements except_handler_part_opt
{:
    RESULT = statements;
:}
; 

except_handler_part_opt ::=
	| except_handler_part
	;

///////////////////////////////////////////////////////////////////////////////
// 5.7 Exit Statements
//
exit_statement ::= 
EXIT:token name_opt:loopName when_opt:whenCondition SEMICOLON:end
{:
    RESULT = new ExitStatement(tokenleft, endright, loopName, whenCondition); 
:}
;

name_opt ::=
{:
    RESULT = null;
:}
| name:name
{:
    RESULT = name;
:}
;

when_opt ::=
{:
    RESULT = null;
:}
| WHEN condition:cond
{:
    RESULT = cond;
:}
;

///////////////////////////////////////////////////////////////////////////////
// 6.5 Return Statements
//
return_statement ::= 
RETURN:token SEMICOLON:end
{:
    RESULT = new ReturnStatement(tokenleft, endright);
:}
| RETURN:token expression:expr SEMICOLON:end
{:
    RESULT = new ReturnStatement(tokenleft, endright, expr);
:}
;

///////////////////////////////////////////////////////////////////////////////
// 5.8 Goto Statements
//
goto_statement ::= 
GOTO:token name:labelName SEMICOLON:end
{:
    RESULT = new GotoStatement(tokenleft, endright, labelName);
:}
;

///////////////////////////////////////////////////////////////////////////////
// 6.1 Subprogram Declarations
//
subprog_declaration ::=
subprogram_specification:subprog SEMICOLON:end
{:
    RESULT = new MethodDeclaration(subprogleft, endright, 0/*modifier*/, subprog);
:}
| generic_subp_inst:subprog SEMICOLON:end
{:
    RESULT = new MethodDeclaration(subprogleft, endright, 0/*modifier*/, subprog);
:}
| subprogram_specification:subprog IS ABSTRACT SEMICOLON:end
{:
    RESULT = new MethodDeclaration(subprogleft, endright, Ada95ASTParser.ABSTRACT, subprog);
:}
;

subprogram_specification ::=
PROCEDURE:procedure compound_name:procedureName formal_part_opt:formalPart
{:
    Identifier procedureId = new Identifier(procedureNameleft, procedureNameright, procedureName);
    SubprogramSpecification subprogramSpecification = new SubprogramSpecification(procedureleft, formalPartright, procedureId, formalPart);
    RESULT = subprogramSpecification;
:}
| FUNCTION:function designator:functionName formal_part_opt:formalPart RETURN name:subtypeMark
{:
    Identifier functionId = new Identifier(functionNameleft, functionNameright, functionName);
    Identifier subtypeReturn = new Identifier(subtypeMarkleft, subtypeMarkright, subtypeMark);
    SubprogramSpecification subprogramSpecification = new SubprogramSpecification(functionleft, subtypeMarkright, functionId, formalPart, subtypeReturn);
    RESULT = subprogramSpecification;
:}
| FUNCTION:function designator:functionName  /* for generic inst and generic rename */
{:
    Identifier functionId = new Identifier(functionNameleft, functionNameright, functionName);
    SubprogramSpecification subprogramSpecification = new SubprogramSpecification(functionleft, functionNameright, functionId);
    RESULT = subprogramSpecification;
:}
;

designator ::=
compound_name:name
{:
    RESULT = name;
:}
| operator_symbol:name
{:
    RESULT = name;
:}
;

formal_part_opt ::=
// empty
{:
	List list = new LinkedList();
	RESULT = list;
:}
| formal_part:list
{:
	RESULT = list;
:}
;

formal_part ::=
LPAREN param_s:list RPAREN
{:
	RESULT = list;
:}
;

param_s ::=
param:parameter
{:
    List list = new LinkedList();
    list.addAll(parameter);
    RESULT = list;
:}
| param_s:list SEMICOLON param:parameter
{:
    list.addAll(parameter);
    RESULT = list;
:}
;

param ::=
defining_identifier_list:identifierList COLON mode:mode subtype_mark:subtype init_opt:init
{:
    List list = new LinkedList();
    Identifier subtypeId = new Identifier(subtypeleft, subtyperight, subtype);
    TypeName typeName = new TypeName(subtypeleft, subtyperight, subtypeId);
    for (Object item : identifierList) {
        Identifier identifier = (Identifier)item;
        Variable variable = new Variable (identifier.getStartOffset(), identifier.getEndOffset(), identifier);
	    int end = init == null ? subtyperight : initright;
        FormalParameter parameter = new FormalParameter(identifierListleft, end, variable, mode, typeName, init);
    	list.add(parameter);
    }
    RESULT = list;
:}
| error:theError SEMICOLON /* error statement */
{:
    List list = new LinkedList();
    ASTError error = new ASTError(theErrorleft, theErrorright);
    list.add(error);
    RESULT = list;
:}
;

mode ::=
// empty
{:
    RESULT = FormalParameter.Mode.IN;
:}
| IN
{:
    RESULT = FormalParameter.Mode.IN;
:}
| OUT
{:
    RESULT = FormalParameter.Mode.OUT;
:}
| IN OUT
{:
    RESULT = FormalParameter.Mode.IN_OUT;
:}
| ACCESS
{:
    RESULT = FormalParameter.Mode.ACCESS;
:}
;

// TODO: manage the overload operators ex: "+" "and" ecc.
operator_symbol ::=
STRING_LITERAL:stringLiteral
{:
    RESULT = stringLiteral;
:}
;

subprogram_body ::=
subprogram_specification:subprog IS
declarative_part:declarativePart block_body:body END id_opt:idOpt SEMICOLON:end
{:
    if (idOpt != null && !idOpt.equalsIgnoreCase (subprog.getSubprogramName().getName())) {
        this.parser.message_error("mispelling of " + subprog.getSubprogramName().getName());
    } else {
        Block declarations = new Block(subprogright, bodyleft, declarativePart);
        body.setEndOffset(endright);
        Identifier nameEnd = new Identifier(idOptleft, idOptright, idOpt);
        SubprogramBody subprogramBody = new SubprogramBody(subprogleft, endright, subprog, declarations, body, nameEnd);
        MethodDeclaration methodDeclaration = new MethodDeclaration(subprogleft, endright, 0/*modifier*/, subprogramBody);
        RESULT = methodDeclaration;
    }
:}
;

///////////////////////////////////////////////////////////////////////////////
// 6.4 Subprogram Calls
//
procedure_call_statement ::=
name SEMICOLON
;


///////////////////////////////////////////////////////////////////////////////
// 7.1 Package Specifications and Declarations
//
package_declaration ::= 
package_specification:statement SEMICOLON
{:
    RESULT = statement;
:}
| generic_package_instantiation SEMICOLON
;

package_specification ::= 
PACKAGE:declarationStart compound_name:packageName IS:blockStart
  declarative_items_opt:declarativeItems private_part:privateDeclarativeItems
END:declarationEnd compound_name_opt:packageNameEnd
{:
    if (packageNameEnd != null && !packageNameEnd.equalsIgnoreCase (packageName)) {
        this.parser.message_error("mispelling of " + packageName);
    }
    else {
        Identifier packageId = new Identifier(packageNameleft, packageNameright, packageName);
        Identifier packageIdEnd = new Identifier(packageNameEndleft, packageNameEndright, packageNameEnd);
        declarativeItems.addAll (privateDeclarativeItems);
        // Add private part on block statements
        Block block = new Block(blockStartleft, declarationEndright, declarativeItems);
        PackageSpecification packageSpecification = new PackageSpecification(declarationStartleft, declarationEndright, packageId, packageIdEnd, block);
        RESULT = packageSpecification;
    }
:}
;

private_part ::=
{:
    RESULT = new LinkedList();
:}
| PRIVATE declarative_items_opt:declarativeItems
{:
    RESULT = this.parser.setModifier (declarativeItems, Ada95ASTParser.PRIVATE);
:}
;

compound_name_opt ::=
// empty
| compound_name:compoundName
{:
    RESULT = compoundName;
:}
;

///////////////////////////////////////////////////////////////////////////////
// 7.2 Package Bodies
//
package_body ::=
PACKAGE:declarationStart BODY compound_name:packageName IS:blockStart
  declarative_part:declarativePart body_opt END compound_name_opt:packageNameEnd SEMICOLON:declarationEnd
{:
    if (packageNameEnd != null && !packageNameEnd.equalsIgnoreCase (packageName)) {
        this.parser.message_error("mispelling of " + packageName);
    }
    else {
        Identifier packageId = new Identifier(packageNameleft, packageNameright, packageName);
        Identifier packageIdEnd = new Identifier(packageNameEndleft, packageNameEndright, packageNameEnd);

        List list = this.parser.setModifier (declarativePart, Ada95ASTParser.PRIVATE);
        Block block = new Block(blockStartleft, declarationEndright, list);

        PackageBody packageBody = new PackageBody(declarationStartleft, declarationEndright, packageId, packageIdEnd, block);
        RESULT = packageBody;
    }
:}
;

body_opt ::=
	| block_body
	;

///////////////////////////////////////////////////////////////////////////////
// 7.3 Private Types and Private Extensions
//
private_type_declaration ::=
tagged_opt:tagged limited_opt:limited PRIVATE:privateKeyword
{:
    PrivateType privateType = new PrivateType(taggedleft, privateKeywordright, tagged + limited + Ada95ASTParser.PRIVATE);
    RESULT = privateType;
:}
;

limited_opt ::=
{:
    RESULT = 0;
:}
| LIMITED
{:
    RESULT = Ada95ASTParser.LIMITED;
:}
;

///////////////////////////////////////////////////////////////////////////////
// 8.4 Use Clauses
//
use_clause ::= 
USE:token package_name_list:packageList SEMICOLON:end
{:
    RESULT = new Use(tokenleft, endright, packageList);
:}
| USE:token TYPE subtype_mark_list:subTypeList SEMICOLON:end
{:
    RESULT = new UseType(tokenleft, endright, subTypeList);
:}
;

package_name_list ::=
name:name
{:
    List idList = new LinkedList();
    Identifier id = new Identifier(nameleft, nameright, name);
    PackageName packageName = new PackageName(nameleft, nameright, id);
    idList.add(packageName);
    RESULT = idList;
:}
| package_name_list:idList COMMA name:name
{:
    Identifier id = new Identifier(nameleft, nameright, name);
    PackageName packageName = new PackageName(nameleft, nameright, id);
    idList.add(packageName);
    RESULT = idList;
:}
;

subtype_mark_list ::=
name:name
{:
    List idList = new LinkedList();
    Identifier id = new Identifier(nameleft, nameright, name);
    TypeName typeName = new TypeName(nameleft, nameright, id);
    idList.add(typeName);
    RESULT = idList;
:}
| subtype_mark_list:idList COMMA name:name
{:
    Identifier id = new Identifier(nameleft, nameright, name);
    TypeName typeName = new TypeName(nameleft, nameright, id);
    idList.add(typeName);
    RESULT = idList;
:}
;


///////////////////////////////////////////////////////////////////////////////
// 8.5 Renaming Declarations
//
renaming_declaration ::=
defining_identifier_list COLON object_qualifier_opt subtype_indication RENAMES name SEMICOLON
| defining_identifier_list COLON EXCEPTION RENAMES name SEMICOLON
| rename_unit:unit
{:
    RESULT = unit;
:}
;

rename_unit ::= 
PACKAGE:token compound_name:name RENAMES name:renames SEMICOLON:end
{:
    Identifier packageNameId = new Identifier(nameleft, nameright, name);
    Identifier packageRenamesId = new Identifier(renamesleft, renamesright, renames);
    PackageRenames packageRenames = new PackageRenames(tokenleft, endright, packageNameId, packageRenamesId);
    RESULT = packageRenames;
:}
| subprogram_specification RENAMES name SEMICOLON:end
| generic_formal_part PACKAGE compound_name RENAMES name SEMICOLON
| generic_formal_part subprogram_specification RENAMES name SEMICOLON
;

task_decl ::= task_spec SEMICOLON
	;

task_spec ::= TASK simple_name task_def
	| TASK TYPE simple_name discrim_part_opt task_def
	;

task_def ::=
	| IS entry_decl_s rep_spec_s task_private_opt END id_opt
	;

task_private_opt ::=
	| PRIVATE entry_decl_s rep_spec_s
	;

task_body ::= TASK BODY simple_name IS
	       declarative_part block_body END id_opt SEMICOLON
	;

prot_decl ::= prot_spec SEMICOLON
	;

prot_spec ::= PROTECTED IDENTIFIER prot_def
	| PROTECTED TYPE simple_name discrim_part_opt prot_def
	;

prot_def ::= IS prot_op_decl_s prot_private_opt END id_opt
	;

prot_private_opt ::=
	| PRIVATE prot_elem_decl_s
	;

prot_op_decl_s ::= 
	| prot_op_decl_s prot_op_decl
	;

prot_op_decl ::= entry_decl
	| subprogram_specification SEMICOLON
	| rep_spec
	| pragma
	;

prot_elem_decl_s ::= 
	| prot_elem_decl_s prot_elem_decl
	;

prot_elem_decl ::= prot_op_decl | comp_decl ;

/////////////////////////////////////////////////////////////////
// 9.4 Protected Units and Protected Objects
//
protected_body ::= 
PROTECTED BODY simple_name:name IS
prot_op_body_s END id_opt SEMICOLON
;

prot_op_body_s ::= pragma_s
	| prot_op_body_s prot_op_body pragma_s
	;

prot_op_body ::= entry_body
	| subprogram_body
	| subprogram_specification SEMICOLON
	;

entry_decl_s ::= pragma_s
	| entry_decl_s entry_decl pragma_s
	;

entry_decl ::= ENTRY IDENTIFIER formal_part_opt SEMICOLON
	| ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON
	;

entry_body ::= ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part
	| ENTRY IDENTIFIER LPAREN iter_part discrete_range RPAREN 
		formal_part_opt WHEN condition entry_body_part
	;

entry_body_part ::= SEMICOLON
	| IS declarative_part block_body END id_opt SEMICOLON
	;

rep_spec_s ::=
	| rep_spec_s rep_spec pragma_s
	;

entry_call ::= 
procedure_call_statement:statement
{:
    RESULT = statement;
:}
;

accept_stmt ::= accept_hdr SEMICOLON
	| accept_hdr DO handled_stmt_s END id_opt SEMICOLON
	;

accept_hdr ::= ACCEPT entry_name formal_part_opt
	;

entry_name ::= simple_name
	| entry_name LPAREN expression RPAREN
	;

/////////////////////////////////////////////////////////////////
// 9.6 Delay Statements, Duration, and Time
//
delay_statement ::=
DELAY:token expression:expr SEMICOLON:end
{:
    RESULT = new ReturnStatement(tokenleft, endright, expr);
:}
| DELAY:token UNTIL expression:expr SEMICOLON:end
{:
    RESULT = new ReturnStatement(tokenleft, endright, expr);
:}
;

select_stmt ::= select_wait
	| async_select
	| timed_entry_call
	| cond_entry_call
	;

select_wait ::= SELECT guarded_select_alt or_select else_opt
	      END SELECT SEMICOLON
	;

guarded_select_alt ::= select_alt
	| WHEN condition ARROW select_alt
	;

or_select ::=
	| or_select OR guarded_select_alt
	;

select_alt ::= accept_stmt stmts_opt
	| delay_statement stmts_opt
	| TERMINATE SEMICOLON
	;

delay_or_entry_alt ::= delay_statement stmts_opt
	| entry_call stmts_opt
	;

async_select ::= SELECT delay_or_entry_alt
	       THEN ABORT sequence_of_statements
	       END SELECT SEMICOLON
	;

timed_entry_call ::= SELECT entry_call stmts_opt 
		   OR delay_statement stmts_opt
	           END SELECT SEMICOLON
	;

cond_entry_call ::= SELECT entry_call stmts_opt 
		  ELSE sequence_of_statements
	          END SELECT SEMICOLON
	;

stmts_opt ::=
	| sequence_of_statements
	;

///////////////////////////////////////////////////////////////////////////////
// 9.8 Abort of a Task - Abort of a Sequence of Statements
//
abort_statement ::=
ABORT:token task_name_list:taskList SEMICOLON:end
{:
    RESULT = new AbortStatement(tokenleft, endright, taskList);
:}
;

task_name_list ::=
name:name
{:
    List idList = new LinkedList();
    Identifier id = new Identifier(nameleft, nameright, name);
    TaskName taskName = new TaskName(nameleft, nameright, id);
    idList.add(taskName);
    RESULT = idList;
:}
| task_name_list:idList COMMA name:name
{:
    Identifier id = new Identifier(nameleft, nameright, name);
    TaskName taskName = new TaskName(nameleft, nameright, id);
    idList.add(taskName);
    RESULT = idList;
:}
;

///////////////////////////////////////////////////////////////////////////////
// 10.1.1 Compilation Units - Library Units
//
compilation ::=
compilation_units:units
{:
    Ada95ASTLexer adaAstLexer = (Ada95ASTLexer) parser.getScanner();
    List comments = adaAstLexer.getCommentList();
    Program program = new Program(unitsleft, unitsright, units, comments);
    RESULT = program;
:}
;

compilation_units ::=
{:
    RESULT = new LinkedList();
:}
| compilation_units:units compilation_unit:unit
{:
    if(units != null) {
        units.add(unit);
    }
    RESULT = units;
:}
| pragma pragma_s  // 10.1.5 - 4
{:
    RESULT = new LinkedList();
:}
;

compilation_unit ::=
context_clause private_opt unit:unit pragma_s
{:
    RESULT = unit;
:}
| private_opt unit:unit pragma_s  // 10.1.5 - 5/1
{:
    RESULT = unit;
:}
;

private_opt ::=
| PRIVATE
;

unit ::= 
package_declaration:statement
{:
    RESULT = statement;
:}
| package_body:statement
{:
    RESULT = statement;
:}
| subprog_declaration:statement
{:
    RESULT = statement;
:}
| subprogram_body:statement
{:
    RESULT = statement;
:}
| subunit:statement
{:
    RESULT = statement;
:}
| generic_declaration:statement
{:
    RESULT = statement;
:}
| rename_unit
;

///////////////////////////////////////////////////////////////////////////////
// 10.1.2 Context Clauses - With Clauses
//
context_clause ::= 
with_clause:statement
{:
    RESULT = statement;
:}
| use_clause:statement
{:
    RESULT = statement;
:}
| context_clause with_clause:statement
{:
    RESULT = statement;
:}
| context_clause use_clause:statement
{:
    RESULT = statement;
:}
| context_clause pragma
;

with_clause ::= 
WITH:token library_unit_name_list:packageList SEMICOLON:end
{:
    RESULT = new With(tokenleft, endright, packageList);
:}
;

///////////////////////////////////////////////////////////////////////////////
// 10.1.3 Subunits of Compilation Units
//
subunit ::=
SEPARATE LPAREN compound_name RPAREN
proper_body:statement
{:
    RESULT = statement;
:}
;


body_stub ::= 
TASK BODY simple_name IS SEPARATE SEMICOLON
| PACKAGE BODY compound_name IS SEPARATE SEMICOLON
| subprogram_specification:subprog IS SEPARATE SEMICOLON
{:
    RESULT = subprog;
:}
| PROTECTED BODY simple_name IS SEPARATE SEMICOLON
;

exception_decl ::= defining_identifier_list COLON EXCEPTION SEMICOLON
	;

except_handler_part ::= EXCEPTION exception_handler
	| except_handler_part exception_handler
	;

exception_handler ::= WHEN except_choice_s ARROW sequence_of_statements
	| WHEN IDENTIFIER COLON except_choice_s ARROW sequence_of_statements
	;

except_choice_s ::= except_choice
	| except_choice_s BAR except_choice
	;

except_choice ::= name
	| OTHERS
	;

///////////////////////////////////////////////////////////////////////////////
// 11.3 Raise Statements
//
raise_statement ::=
RAISE:token name_opt:exceptionName SEMICOLON:end
{:
    RESULT = new RaiseStatement(tokenleft, endright, exceptionName); 
:}
;

requeue_stmt ::= REQUEUE name SEMICOLON
	| REQUEUE name WITH ABORT SEMICOLON
	;

///////////////////////////////////////////////////////////////////////////////
// 12.1 Generic Declarations
//
generic_declaration ::= 
generic_formal_part subprogram_specification SEMICOLON
| generic_formal_part package_specification:statement SEMICOLON
{:
    RESULT = statement;
:}
;

generic_formal_part ::= GENERIC
	| generic_formal_part generic_formal
	;

generic_formal ::= param SEMICOLON
	| TYPE simple_name generic_discrim_part_opt IS generic_type_def SEMICOLON
	| WITH PROCEDURE simple_name 
	    formal_part_opt subp_default SEMICOLON
	| WITH FUNCTION designator 
	    formal_part_opt RETURN name subp_default SEMICOLON
	| WITH PACKAGE simple_name IS NEW name LPAREN BOX RPAREN SEMICOLON
	| WITH PACKAGE simple_name IS NEW name SEMICOLON
	| use_clause
	;

generic_discrim_part_opt ::=
	| discrim_part
	| LPAREN BOX RPAREN
	;

subp_default ::=
	| IS name
	| IS BOX
	;

generic_type_def ::= LPAREN BOX RPAREN
	| RANGE BOX
	| MOD BOX
	| DELTA BOX
	| DELTA BOX DIGITS BOX
	| DIGITS BOX
	| array_type
	| access_type
	| private_type_declaration
	| generic_derived_type
	;

generic_derived_type ::= NEW subtype_indication
	| NEW subtype_indication WITH PRIVATE
	| ABSTRACT NEW subtype_indication WITH PRIVATE
	;

generic_subp_inst ::=
subprogram_specification:subprog IS generic_inst
{:
    RESULT = subprog;
:}
;

// 12.3
generic_package_instantiation ::=
PACKAGE compound_name IS generic_inst
;

generic_inst ::= NEW name
;

rep_spec ::= attrib_def
	| record_type_spec
	| address_spec
	;

attrib_def ::= FOR subtype_mark USE expression SEMICOLON
	;

record_type_spec ::= FOR subtype_mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
	;

align_opt ::=
	| AT MOD expression SEMICOLON
	;

comp_loc_s ::=
	| comp_loc_s subtype_mark AT expression RANGE range SEMICOLON
	;

address_spec ::= FOR subtype_mark USE AT expression SEMICOLON
	;

///////////////////////////////////////////////////////////////////////////////
// 13.8 Machine Code Insertions
//
code_statement ::=
qualified_expression:expr SEMICOLON:end
{:
    RESULT = new CodeStatement (exprleft, endright, expr);
:}
;