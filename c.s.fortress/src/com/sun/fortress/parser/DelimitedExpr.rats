/*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress expressions that are enclosed by keywords.
 */
module com.sun.fortress.parser.DelimitedExpr(TraitObject, NoNewlineHeader,
                                             MayNewlineHeader, Type, Expr,
                                             LocalDecl, Literal, Identifier,
                                             Keyword, Symbol, Spacing);
import TraitObject;
import NoNewlineHeader;
import MayNewlineHeader;
import Type;
import Expr;
import LocalDecl;
import Literal;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* DelimitedExpr ::=
     ArgExpr
   | Parenthesized
   | object (w ExtendsWhere)? (w GoInAnObject)? w end
   | Do
   | label w Id w BlockElems w end w Id
   | while w Expr w Do
   | for w GeneratorClauseList w DoFront w end
   | if w Expr w then w BlockElems (w Elifs)? (w Else)? w end
   | ( w if w Expr w then w BlockElems (w Elifs)? w Else (w end)? w )
   | case w Expr (w Op)? w of w CaseClauses (w CaseElse)? w end
   | case w most w Op w of w CaseClauses w end
   | typecase w TypecaseBindings w of w TypecaseClauses (br CaseElse)? w end
   | try w BlockElems (w Catch)? (w forbid w TraitTypes)?
       (w finally w BlockElems)? w end
 */
Expr DelimitedExpr =
     ArgExpr
   / Parenthesized
   / object a1:(w ExtendsWhere)? a2:(w GoInAnObject)? w end
     { if (a1 == null) a1 = FortressUtil.emptyTraitTypeWheres();
       if (a2 == null) a2 = Collections.<Decl>emptyList();
       yyValue = new ObjectExpr(createSpan(yyStart,yyCount), false, a1, a2);
     }
   / Do
   / label w a1:Id w a2:BlockElems w end w a3:Id
     { if (!a1.getText().equals(a3.getText()))
           error(a1, "Mismatched identifiers for label expressions.");
       yyValue = new Label(createSpan(yyStart,yyCount), false, a1, a2);
     }
   / while w a1:Expr w a2:Do
     { yyValue = new While(createSpan(yyStart,yyCount), false, a1, a2); }
   / for w a1:GeneratorClauseList w a2:DoFront w end
     { yyValue = new For(createSpan(yyStart,yyCount), false, a1, a2); }
   / if w a1:Expr w then w a2:BlockElems a3:(w Elifs)? a4:(w Else)? w end
     { IfClause ic = new IfClause(FortressUtil.spanTwo(a1,a2), a1, a2);
       List<IfClause> clauses = FortressUtil.mkList(ic);
       if (a3 != null) clauses.addAll(a3);
       Option<Block> elseC = Option.wrap(a4);
       yyValue = new If(createSpan(yyStart,yyCount), false, clauses, elseC);
     }
   / openparen w if w a1:Expr w then w a2:BlockElems a3:(w Elifs)? w a4:Else
       (w end)? w closeparen
     { IfClause ic = new IfClause(FortressUtil.spanTwo(a1,a2), a1, a2);
       List<IfClause> clauses = FortressUtil.mkList(ic);
       if (a3 != null) clauses.addAll(a3);
       yyValue = new If(createSpan(yyStart,yyCount),false,clauses,
                        Option.some(a4));
     }
   / case w a1:Expr a2:(w Op)? w of w a3:CaseClauses a4:(w CaseElse)? w end
     { Option<Op> compare;
       if (a2 == null) compare = Option.none();
       else            compare = Option.some(a2);
       Option<Block> _else;
       if (a4 == null)
           _else = Option.none();
       else _else = Option.some(a4);
       yyValue = new CaseExpr(createSpan(yyStart,yyCount), false,
                              Option.some(a1), compare, a3, _else);
     }
   / case w most w a1:Op w of w a2:CaseClauses w end
     { Option<Op> compare = Option.some(a1);
       yyValue = new CaseExpr(createSpan(yyStart,yyCount), false,
                              Option.<Expr>none(), compare, a2,
                              Option.<Block>none());
     }
   / typecase w a1:TypecaseBindings w of w a2:TypecaseClauses a3:(br CaseElse)?
       w end
     { Option<Block> caseElse = Option.wrap(a3);
       yyValue = new Typecase(createSpan(yyStart,yyCount), false, a1, a2,
                              caseElse);
     }
   / <TRY> try w a1:BlockElems a2:(w Catch)? a3:(w forbid w TraitTypes)?
     a4:(w finally w BlockElems)? w end
     { Option<Catch> catch_ = Option.wrap(a2);
       if (a3 == null) a3 = FortressUtil.emptyTraitTypes();
       Option<Block> finally_ = Option.wrap(a4);
       yyValue = new Try(createSpan(yyStart,yyCount), false, a1, catch_, a3,
                         finally_);
     };

/* Do ::= (DoFront w also w)* DoFront w end */
Do Do = a1s:(DoFront w also w)* a2:DoFront w end
     { yyValue = new Do(createSpan(yyStart, yyCount), false,
                        FortressUtil.mkList(a1s.list(), a2));
     };

/* DoFront ::= (at w Expr w)? (atomic w)? do (w BlockElems)? */
private DoFront DoFront =
     a1:(at w Expr w)? a2:(atomic w)? do a3:(w BlockElems)?
     { Span span = createSpan(yyStart,yyCount);
       Option<Expr> at = Option.wrap(a1);
       boolean atomic = (a2 == null) ? false : true;
       if (a3 == null) a3 = FortressUtil.doBlock(span);
       yyValue = new DoFront(span, at, atomic, a3);
     };

/* ArgExpr ::=
     ( w (Expr w , w)* (Expr w ... w , w)? KeywordExpr (w , w KeywordExpr)* w )
   | ( w (Expr w , w)* Expr w ... w )
   | TupleExpr
 */
Expr ArgExpr =
     openparen w a1s:(Expr w comma w)* a2:(Expr w void:ellipses w comma w)?
     a3:KeywordExpr a4s:(w comma w KeywordExpr)* w closeparen
     { List<Expr> es = a1s.list();
       Option<VarargsExpr> vs = ((a2 != null) ?
                              Option.some(new VarargsExpr(a2.getSpan(), a2)) :
                              Option.<VarargsExpr>none());
       List<KeywordExpr> ks = new ArrayList<KeywordExpr>();
       ks.add(a3);
       for (KeywordExpr b : (List<KeywordExpr>)a4s.list()) {
           ks.add(b);
       }
       yyValue = new ArgExpr(createSpan(yyStart,yyCount), false, es, vs, ks);
     }
   / openparen w a1s:(Expr w comma w)* a2:Expr w ellipses w closeparen
     { Option<VarargsExpr> vs = Option.some(new VarargsExpr(a2.getSpan(), a2));
       yyValue = new ArgExpr(createSpan(yyStart,yyCount),false,a1s.list(),vs);
     }
   / TupleExpr ;

/* TupleExpr ::= ( w (Expr w , w)+  Expr w ) */
Expr TupleExpr =
     openparen w a1s:(Expr w comma w)+ a2:Expr w closeparen
     { List<Expr> es = FortressUtil.mkList(a1s.list(), a2);
       yyValue = new TupleExpr(createSpan(yyStart,yyCount), false, es);
     };

/* KeywordExpr ::= BindId w = w Expr */
private KeywordExpr KeywordExpr = a1:BindId w equals w a2:Expr
     { yyValue = new KeywordExpr(createSpan(yyStart,yyCount), a1, a2); };

/* Parenthesized ::= ( w Expr w ) */
Expr Parenthesized =
     openparen w a1:Expr w closeparen
     { yyValue = ExprFactory.makeInParentheses(a1); };

/* Elifs ::= Elif (w Elif)* */
List<IfClause> Elifs = a1:Elif a2s:(w Elif)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* Elif ::= elif w Expr w then w BlockElems */
private IfClause Elif = elif w a1:Expr w then w a2:BlockElems
     { yyValue = new IfClause(createSpan(yyStart,yyCount), a1, a2); };

/* Else ::= else w BlockElems */
Block Else = else w yyValue:BlockElems;

/* CaseClauses ::= CaseClause (br CaseClause)* */
private List<CaseClause> CaseClauses = a1:CaseClause a2s:(br CaseClause)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* CaseElse ::= else w => w BlockElems */
Block CaseElse = else w match w BlockElems ;

/* TypecaseBindings ::= TypecaseVars (w = w Expr)? */
private com.sun.fortress.useful.Pair<List<Id>,Option<Expr>> TypecaseBindings =
     a1:TypecaseVars a2:(w void:equals w Expr)?
     { yyValue = new com.sun.fortress.useful.Pair(a1, Option.wrap(a2)); };

/* TypecaseVars ::=
     BindId
   | ( w BindId(w , w BindId)+ w )
 */
private List<Id> TypecaseVars =
     a1:BindId
     { yyValue = FortressUtil.mkList(a1); }
   / openparen w a1:BindId a2s:(w comma w BindId)+ w closeparen
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* TypecaseClauses ::= TypecaseClause (br TypecaseClause)* */
private List<TypecaseClause> TypecaseClauses =
     a1:TypecaseClause a2s:(br TypecaseClause)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* TypecaseClause ::= TypecaseTypes w => w BlockElems */
TypecaseClause TypecaseClause =
     a1:TypecaseTypes w match w a2:BlockElems
     { yyValue = new TypecaseClause(createSpan(yyStart,yyCount), a1, a2); };

/* TypecaseTypes ::=
     ( w TypeList w )
   | Type
 */
List<Type> TypecaseTypes =
     openparen w TypeList w closeparen
   / a1:Type { yyValue = FortressUtil.mkList(a1); };

/* Catch ::= catch w BindId w CatchClauses */
Catch Catch = catch w a1:BindId w a2:CatchClauses
     { yyValue = new Catch(createSpan(yyStart,yyCount), a1, a2); };

/* CatchClauses ::= CatchClause (br CatchClause)* */
private List<CatchClause> CatchClauses = a1:CatchClause a2s:(br CatchClause)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* CatchClause ::= TraitType w => w BlockElems */
private CatchClause CatchClause = a1:TraitType w match w a2:BlockElems
     { yyValue = new CatchClause(createSpan(yyStart,yyCount), a1, a2); };

/* MapExpr ::= { (w EntryList)? w } */
Expr MapExpr =
     void:opencurly a1:(w EntryList)? w void:closecurly
     { if (a1 == null) a1 = FortressUtil.emptyExprs();
       Op open  = NodeFactory.makeOpEnclosing(createSpan(yyStart,yyStart+1),
                                              "{|->");
       Op close = NodeFactory.makeOpEnclosing(createSpan(yyCount-1,1), "}");
       yyValue = ASTUtil.enclosing(createSpan(yyStart,yyCount), open, a1, close);
     };

/* Comprehension ::=
     (BIG w)? [ StaticArgs? w ArrayComprehensionClause
                          (br ArrayComprehensionClause)* w ]
   | (BIG w)? { StaticArgs? w Entry wr | wr GeneratorClauseList w }
   | (BIG w)? LeftEncloser StaticArgs? w Expr wr | wr GeneratorClauseList w
              RightEncloser
 */
FlowExpr Comprehension =
     (BIG w)? opensquare a1:StaticArgs? w a2:ArrayComprehensionClause
     a3s:(br ArrayComprehensionClause)* w closesquare
     { List<ArrayComprehensionClause> clauses = FortressUtil.mkList(a2,
                                                                    a3s.list());
       if (a1 == null) a1 = Collections.<StaticArg>emptyList();
       yyValue = new ArrayComprehension(createSpan(yyStart,yyCount),a1,clauses);
     }
   / (BIG w)? opencurly a1:StaticArgs? w a2:Entry wr bar wr
     a3:GeneratorClauseList w closecurly
     { Span span = createSpan(yyStart,yyCount);
       Op open  = NodeFactory.makeOpBig(span, "BIG {|->");
       Op close = NodeFactory.makeOpBig(span, "BIG }");
       OpName opr = new Enclosing(span, open, close);
       if (a1 == null) a1 = Collections.<StaticArg>emptyList();
       yyValue = new Accumulator(createSpan(yyStart,yyCount), a1, opr, a3, a2);
     }
   / (BIG w)? a1:LeftEncloser a2:StaticArgs? w a3:Expr wr bar wr
     a4:GeneratorClauseList w a5:RightEncloser
     { Span span = createSpan(yyStart,yyCount);
       Op open  = NodeFactory.makeOpBig(span, "BIG " + a1.getText());
       Op close = NodeFactory.makeOpBig(span, "BIG " + a5.getText());
       OpName opr = new Enclosing(span, open, close);
       if (a2 == null) a2 = Collections.<StaticArg>emptyList();
       yyValue = new Accumulator(createSpan(yyStart,yyCount), a2, opr, a4, a3);
     };

/* The operator "|->" should not be in the left-hand sides of map expressions
   and map/array comprehensions.
 */
String mapstoOp =
     !("|->" w Expr (w mapsto / wr bar / w closecurly / w comma)) "|->" ;

/* Entry ::= Expr w |-> w Expr */
Expr Entry = a1:Expr w mapsto w a2:Expr
     { yyValue = ExprFactory.makeTuple(a1, a2); };

/* ArrayComprehensionLeft ::=
     IdOrInt w |-> w Expr
   | ( w IdOrInt w , w IdOrIntList w ) w |-> w Expr
 */
com.sun.fortress.useful.Pair<List<Expr>,Expr> ArrayComprehensionLeft =
     a1:IdOrInt w mapsto w a2:Expr
     { List<Expr> exprs = FortressUtil.mkList(a1);
       yyValue = new com.sun.fortress.useful.Pair<List<Expr>,Expr>(exprs, a2);
     }
   / openparen w a1:IdOrInt w comma w a2:IdOrIntList w closeparen w mapsto w
     a3:Expr
     { List<Expr> exprs = FortressUtil.mkList(a1);
       for (Expr i : a2) {
           exprs.add(i);
       }
       yyValue = new com.sun.fortress.useful.Pair<List<Expr>,Expr>(exprs, a3);
     };

/* IdOrInt ::= Id | IntLiteralExpr */
Expr IdOrInt =
     a1:Id { yyValue = ExprFactory.makeVarRef(a1); }
   / IntLiteralExpr ;

/* IdOrIntList ::= IdOrInt (w , w IdOrInt)* */
List<Expr> IdOrIntList = a1:IdOrInt a2s:(w comma w IdOrInt)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* ExprList ::= Expr (w , w Expr)* */
List<Expr> ExprList = a1:Expr a2s:(w comma w Expr)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* EntryList ::= Entry (w , w Entry)* */
List<Expr> EntryList = a1:Entry a2s:(w comma w Entry)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };
