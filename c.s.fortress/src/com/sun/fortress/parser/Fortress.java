// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.13.2,
// (C) 2004-2007 Robert Grimm,
// on Tuesday, March 11, 2008 at 11:25:26 PM.
// Edit at your own risk.
// ===========================================================================

package com.sun.fortress.parser;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import com.sun.fortress.interpreter.evaluator.ProgramError;
import com.sun.fortress.parser_util.precedence_opexpr.*;
import com.sun.fortress.parser_util.precedence_resolver.*;
import com.sun.fortress.nodes.*;
import com.sun.fortress.nodes_util.*;
import com.sun.fortress.parser_util.*;
import com.sun.fortress.useful.PureList;
import com.sun.fortress.useful.Empty;
import com.sun.fortress.useful.Cons;
import com.sun.fortress.useful.Useful;
import edu.rice.cs.plt.tuple.Option;
import edu.rice.cs.plt.iter.IterUtil;
import xtc.util.Action;
import java.util.Collections;
import java.util.ArrayList;
import java.util.List;

import static com.sun.fortress.interpreter.evaluator.ProgramError.errorMsg;
import static com.sun.fortress.interpreter.evaluator.ProgramError.error;
import static com.sun.fortress.interpreter.evaluator.InterpreterBug.bug;
import java.util.LinkedList;

/**
 * Packrat parser for grammar <code>com.sun.fortress.parser.Fortress</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.13.2, (C) 2004-2007 Robert Grimm.
 */
public final class Fortress extends ParserBase {

  /** The isNative flag. */
  public static final boolean isNative = true;

  /** The FORTRESS_SYNTAX_SPECIAL_SYMBOLS set. */
  public static final Set<String> FORTRESS_SYNTAX_SPECIAL_SYMBOLS = new HashSet<String>();

  /** The FORTRESS_SYNTAX_SPECIAL_CHARS set. */
  public static final Set<String> FORTRESS_SYNTAX_SPECIAL_CHARS = new HashSet<String>();

  /** The FORTRESS_KEYWORDS set. */
  public static final Set<String> FORTRESS_KEYWORDS = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fImports;
    Result fImports$$Star1;
    Result fImport;
    Result fAliasedSimpleName;
    Result fAliasedAPIName;
    Result fExports;
    Result fExports$$Star1;
    Result fExport;
    Result fDecls;
    Result fDecls$$Star1;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fDecl;
    Result fAbsDecls;
    Result fAbsDecls$$Star1;
    Result fAbsDecl;
    Result f$$Shared1;
    Result fTraitObject$Varargs;
    Result fTraitObject$Keyword;
    Result f$$Shared2;
    Result fTraitObject$Param;
    Result fTraitHeaderFront;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fCoercions;
    Result fCoercions$$Star1;
    Result fGoesFrontInATrait;
    Result fGoBackInATrait;
    Result fGoBackInATrait$$Star1;
    Result fGoesBackInATrait;
    Result fObjectHeader;
    Result fGoInAnObject;
    Result fGoesFrontInAnObject;
    Result fGoBackInAnObject;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fGoBackInAnObject$$Star1;
    Result fGoesBackInAnObject;
    Result fAbsCoercions;
    Result fAbsCoercions$$Star1;
    Result f$$Shared27;
    Result f$$Shared27$$Star1;
    Result f$$Shared3;
    Result f$$Shared28;
    Result f$$Shared28$$Star1;
    Result f$$Shared4;
  }

  /** Chunk 5 of memoized results. */
  static final class Chunk5 {
    Result fFnSig;
    Result fFnHeaderFront;
    Result fNamedFnHeaderFront;
    Result fParameter$ValParam;
    Result fParameter$Params;
    Result fParameter$Params$$Star1;
    Result fParameter$Params$$Star2;
    Result fParameter$Params$$Star3;
    Result f$$Shared29;
    Result fParameter$Keyword;
  }

  /** Chunk 6 of memoized results. */
  static final class Chunk6 {
    Result fParameter$Param;
    Result fMdDef;
    Result fMdHeaderFront;
    Result fGetterSetterDef;
    Result fGetterSetterMod;
    Result fCoercion;
    Result fAbsCoercion;
    Result fCoercionClauses;
    Result fCoercionWhereConstraintList;
    Result fCoercionWhereConstraintList$$Star1;
  }

  /** Chunk 7 of memoized results. */
  static final class Chunk7 {
    Result fCoercionWhereConstraint;
    Result fMethodParam$ValParam;
    Result fMethodParam$Params;
    Result fMethodParam$Params$$Star1;
    Result fMethodParam$Params$$Star2;
    Result fMethodParam$Params$$Star3;
    Result fMethodParam$Keyword;
    Result fMethodParam$Param;
    Result f$$Shared30;
    Result f$$Shared30$$Plus1;
  }

  /** Chunk 8 of memoized results. */
  static final class Chunk8 {
    Result f$$Shared5;
    Result f$$Shared6;
    Result f$$Shared40;
    Result f$$Shared7;
    Result fIsType;
    Result fWhereConstraintList;
    Result fWhereConstraintList$$Star1;
    Result fWhereConstraint;
    Result fIntVal;
    Result fIntExpr;
  }

  /** Chunk 9 of memoized results. */
  static final class Chunk9 {
    Result fIntExpr$$Star1;
    Result fBoolVal;
    Result fBoolExpr;
    Result fBoolExpr$$Star1;
    Result fEnsures;
    Result fEnsuresClause;
    Result fInvariant;
    Result fStaticArgs;
    Result fStaticArg;
    Result fExtendsWhere;
  }

  /** Chunk 10 of memoized results. */
  static final class Chunk10 {
    Result fTraitTypeWhere;
    Result fNoNewlineHeader$Extends;
    Result fExcludes;
    Result fTraitTypes;
    Result fWhere;
    Result fWhereBindingList;
    Result fWhereBindingList$$Star1;
    Result fWhereBinding;
    Result fFnHeaderClause;
    Result fFnClauses;
  }

  /** Chunk 11 of memoized results. */
  static final class Chunk11 {
    Result fThrows;
    Result fTraitMods;
    Result fTraitMods$$Plus1;
    Result fAbsTraitMods;
    Result fAbsTraitMods$$Plus1;
    Result fAbsTraitMod;
    Result fMdMods;
    Result fMdMods$$Plus1;
    Result fFnMods;
    Result fFnMods$$Plus1;
  }

  /** Chunk 12 of memoized results. */
  static final class Chunk12 {
    Result fFnMod;
    Result fAbsFnMods;
    Result fAbsFnMods$$Plus1;
    Result fAbsFnMod;
    Result fLocalFnMod;
    Result fApiFldMod;
    Result fStaticParams;
    Result fStaticParam;
    Result fDimUnitDecl;
    Result f$$Shared58;
  }

  /** Chunk 13 of memoized results. */
  static final class Chunk13 {
    Result fDimUnitDecl$$Star1;
    Result fDimUnitDecl$$Star2;
    Result fTypeAlias;
    Result fTestDecl;
    Result fPropertyDecl;
    Result fOpenExpander;
    Result fCloseExpander;
    Result fSyntaxDef;
    Result fSyntaxDefOr;
    Result fBlockExpr;
  }

  /** Chunk 14 of memoized results. */
  static final class Chunk14 {
    Result fSyntaxSymbols;
    Result fSyntaxSymbols$$Star1;
    Result fSyntaxSymbol;
    Result fSymbol;
    Result fSuffix;
    Result fItem;
    Result fItem$$Star1;
    Result fChar;
    Result futf16;
    Result fSpecialChars;
  }

  /** Chunk 15 of memoized results. */
  static final class Chunk15 {
    Result fSpecialSymbols;
    Result fbreakline;
    Result fType$Type;
    Result fType$TypePrimary;
    Result fType$TypePrefix;
    Result fType$ParenthesizedType;
    Result fType$ArgType;
    Result fType$ArgType$$Star1;
    Result fType$ArgType$$Star2;
    Result fType$KeywordType;
  }

  /** Chunk 16 of memoized results. */
  static final class Chunk16 {
    Result fType$TupleType;
    Result fType$TypeList;
    Result fType$TypeList$$Star1;
    Result f$$Shared8;
    Result f$$Shared9;
    Result f$$Shared11;
    Result f$$Shared13;
    Result f$$Shared14;
    Result f$$Shared15;
    Result f$$Shared16;
  }

  /** Chunk 17 of memoized results. */
  static final class Chunk17 {
    Result fType$TraitType;
    Result f$$Shared59;
    Result fNoNewlineType$Type;
    Result fNoNewlineType$TypePrimary;
    Result fNoNewlineType$TypePrefix;
    Result fNoNewlineType$ParenthesizedType;
    Result fNoNewlineType$ArgType;
    Result fNoNewlineType$ArgType$$Star1;
    Result fNoNewlineType$ArgType$$Star2;
    Result fNoNewlineType$KeywordType;
  }

  /** Chunk 18 of memoized results. */
  static final class Chunk18 {
    Result fNoNewlineType$TraitType;
    Result fNoNewlineType;
    Result fExpression$Expr;
    Result fExpression$Expr$$Star1;
    Result fExpression$AssignExpr;
    Result f$$Shared47;
    Result f$$Shared47$$Star1;
    Result f$$Shared42;
    Result f$$Shared42$$Plus1;
    Result fExpression$OpExpr;
  }

  /** Chunk 19 of memoized results. */
  static final class Chunk19 {
    Result fExpression$OpExprNoEnc;
    Result fExpression$LeftLooseInfix;
    Result fExpression$OpExprLeftEncloser;
    Result fExpression$OpExprPrimary;
    Result fExpression$OpExprPrefix;
    Result fExpression$LooseInfix;
    Result f$$Shared52;
    Result f$$Shared37;
    Result f$$Shared23;
    Result f$$Shared25;
  }

  /** Chunk 20 of memoized results. */
  static final class Chunk20 {
    Result fExpression$AtomicBack;
    Result fExpression$GeneratorClauseList;
    Result fExpression$GeneratorClauseList$$Star1;
    Result fExpression$GeneratorBinding;
    Result fDelimitedExpr;
    Result fDo;
    Result fDo$$Star1;
    Result fDoFront;
    Result fArgExpr;
    Result fArgExpr$$Star1;
  }

  /** Chunk 21 of memoized results. */
  static final class Chunk21 {
    Result fArgExpr$$Star2;
    Result fKeywordExpr;
    Result fParenthesized;
    Result fElifs;
    Result fElifs$$Star1;
    Result fElif;
    Result fElse;
    Result fCaseClauses;
    Result fCaseClauses$$Star1;
    Result fCaseElse;
  }

  /** Chunk 22 of memoized results. */
  static final class Chunk22 {
    Result fTypecaseClause;
    Result fTypecaseTypes;
    Result fCatch;
    Result fCatchClause;
    Result fEntry;
    Result fIdOrInt;
    Result fExprList;
    Result fExprList$$Star1;
    Result fNoNewlineExpr$Expr;
    Result fNoNewlineExpr$Expr$$Star1;
  }

  /** Chunk 23 of memoized results. */
  static final class Chunk23 {
    Result fNoNewlineExpr$AssignExpr;
    Result fNoNewlineExpr$OpExpr;
    Result fNoNewlineExpr$OpExprNoEnc;
    Result fNoNewlineExpr$LeftLooseInfix;
    Result fNoNewlineExpr$OpExprLeftEncloser;
    Result fNoNewlineExpr$OpExprPrimary;
    Result fNoNewlineExpr$OpExprPrefix;
    Result fNoNewlineExpr$LooseInfix;
    Result fNoNewlineExpr$AtomicBack;
    Result fNoNewlineExpr$GeneratorClauseList;
  }

  /** Chunk 24 of memoized results. */
  static final class Chunk24 {
    Result fNoNewlineExpr$GeneratorClauseList$$Star1;
    Result fNoNewlineExpr$GeneratorBinding;
    Result fNoNewlineExpr;
    Result fNoNewlineVarWTypes;
    Result fNoNewlineVarWTypes$$Plus1;
    Result fNoNewlineVarWType;
    Result fNoNewlineIsType;
    Result fNoSpaceExpr$ExprFront;
    Result fNoSpaceExpr$OpExprNoEnc;
    Result fNoSpaceExpr$OpExprLeftEncloser;
  }

  /** Chunk 25 of memoized results. */
  static final class Chunk25 {
    Result fNoSpaceExpr$OpExprPrimary;
    Result fNoSpaceExpr$OpExprPrefix;
    Result fNoSpaceExpr;
    Result fLiteralExpr;
    Result fBlockElems;
    Result fBlockElemCollection;
    Result fLocalFnDecl;
    Result fVarWoType;
    Result fUnpasting;
    Result fUnpastingElems;
  }

  /** Chunk 26 of memoized results. */
  static final class Chunk26 {
    Result fUnpastingElem;
    Result fCaseClause;
    Result fid;
    Result fid$$Star1;
    Result fidrest;
    Result fId;
    Result fBindId;
    Result fBindIdOrBindIdTuple;
    Result fSimpleName;
    Result fAPIName;
  }

  /** Chunk 27 of memoized results. */
  static final class Chunk27 {
    Result f$$Shared60;
    Result fQualifiedName;
    Result fEncloser;
    Result fLeftEncloser;
    Result fRightEncloser;
    Result fExponentOp;
    Result fEncloserPair;
    Result fbars;
    Result fbars$$Star1;
    Result fslashes;
  }

  /** Chunk 28 of memoized results. */
  static final class Chunk28 {
    Result fslashes$$Star1;
    Result fslashes$$Star2;
    Result fgreaters;
    Result fgreaters$$Star1;
    Result fencloser;
    Result fleftEncloser;
    Result frightEncloser;
    Result frightEncloserMulti;
    Result frightEncloserMulti$$Plus1;
    Result frightEncloserMulti$$Plus2;
  }

  /** Chunk 29 of memoized results. */
  static final class Chunk29 {
    Result fOpName;
    Result fOp;
    Result fcompOp;
    Result fmultiOp;
    Result fsingleOp;
    Result fop;
    Result fleftarrow;
    Result fcaret;
    Result fcolonequals;
    Result fequals;
  }

  /** Chunk 30 of memoized results. */
  static final class Chunk30 {
    Result fequalsOp;
    Result fsemicolon;
    Result fone;
    Result fSymbol$colon;
    Result fclosecurly;
    Result fopencurly;
    Result fclosesquare;
    Result fopensquare;
    Result fellipses;
    Result fNOT;
  }

  /** Chunk 31 of memoized results. */
  static final class Chunk31 {
    Result fOR;
    Result fAND;
    Result fIMPLIES;
    Result fDOT;
    Result fslash;
    Result frightarrow;
    Result fAssignOp;
    Result fSUM;
    Result fPROD;
    Result fAccumulator;
  }

  /** Chunk 32 of memoized results. */
  static final class Chunk32 {
    Result fArrayComprehensionClause;
    Result fWhitespace;
    Result fSpacing$Space;
    Result fSpacing$Newline;
    Result fComment;
    Result fRectSeparator;
    Result fRectSeparator$$Plus1;
    Result fper;
    Result fBIG;
    Result fabstract;
  }

  /** Chunk 33 of memoized results. */
  static final class Chunk33 {
    Result fatomic;
    Result fend;
    Result fhidden;
    Result fnative;
    Result foverride;
    Result fprivate;
    Result fself;
    Result fsettable;
    Result ftest;
    Result ftransient;
  }

  /** Chunk 34 of memoized results. */
  static final class Chunk34 {
    Result funit;
    Result fvar;
    Result fwidens;
    Result fwrapped;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class FortressColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
    Chunk5 chunk5;
    Chunk6 chunk6;
    Chunk7 chunk7;
    Chunk8 chunk8;
    Chunk9 chunk9;
    Chunk10 chunk10;
    Chunk11 chunk11;
    Chunk12 chunk12;
    Chunk13 chunk13;
    Chunk14 chunk14;
    Chunk15 chunk15;
    Chunk16 chunk16;
    Chunk17 chunk17;
    Chunk18 chunk18;
    Chunk19 chunk19;
    Chunk20 chunk20;
    Chunk21 chunk21;
    Chunk22 chunk22;
    Chunk23 chunk23;
    Chunk24 chunk24;
    Chunk25 chunk25;
    Chunk26 chunk26;
    Chunk27 chunk27;
    Chunk28 chunk28;
    Chunk29 chunk29;
    Chunk30 chunk30;
    Chunk31 chunk31;
    Chunk32 chunk32;
    Chunk33 chunk33;
    Chunk34 chunk34;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public Fortress(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public Fortress(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new FortressColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.File.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pFile(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    Object          yyOpValue1;
    CompilationUnit yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pCompilationUnit(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pEndOfFile(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pFile$$Choice1(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Import> v$el$2 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$2;
    }
    { // Start scope for a1.
      List<Import> a1 = cast(yyOpValue1);

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExports(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Export> a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;

            yyResult = psemicolon(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
            }

            yyOpValue1 = null;

            yyResult = pFile$$Choice2(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Decl> v$el$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
            { // Start scope for a3.
              List<Decl> a3 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pEndOfFile(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  if (a1 == null) a1 = Collections.<Import>emptyList();
                  if (a3 == null) a3 = Collections.<Decl>emptyList();
                  Span span = createSpan(yyStart,yyCount);
                  String file = span.begin.getFileName();
                  APIName name = NodeFactory.makeAPIName(span, file, "\\.");
                  yyValue = new Component(span, name, a1, a2, a3);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for a3.
          }
        }

        // Nested alternative 2.

        yyResult = pAbsDecls(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<AbsDecl> a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;

            yyResult = psemicolon(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
            }

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pEndOfFile(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                if (a1 == null) a1 = Collections.<Import>emptyList();
                Span span = createSpan(yyStart,yyCount);
                String file = span.begin.getFileName();
                APIName name = NodeFactory.makeAPIName(span, file, "\\.");
                yyValue = new Api(span, name, a1, a2);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Alternative 3.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pImports(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Import> a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyResult = psemicolon(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          yyOpValue1 = null;

          yyResult = pFile$$Choice3(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<AbsDecl> v$el$4 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$4;
          }
          { // Start scope for a2.
            List<AbsDecl> a2 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pEndOfFile(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                if (a2 == null) a2 = Collections.<AbsDecl>emptyList();
                Span span = createSpan(yyStart,yyCount);
                String file = span.begin.getFileName();
                APIName name = NodeFactory.makeAPIName(span, file, "\\.");
                yyValue = new Api(span, name, a1, a2);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.File$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pFile$$Choice1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    List<Import> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pImports(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyResult = psemicolon(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.File$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pFile$$Choice2(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDecls(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyResult = psemicolon(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.File$$Choice3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pFile$$Choice3(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyOption1;
    List<AbsDecl> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pAbsDecls(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyResult = psemicolon(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.CompilationUnit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCompilationUnit(final int yyStart) throws IOException {
    Result          yyResult;
    CompilationUnit yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComponent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pApi(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.Component.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComponent(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Component  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pnative(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      String a1 = cast(yyOpValue1);

      yyResult = pcomponent(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pAPIName(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            APIName a2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = p$$Shared53(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Import> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for a3.
              List<Import> a3 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExports(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Export> a4 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption1  = yyResult.index;

                    yyResult = psemicolon(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                    }

                    yyOpValue1 = null;

                    yyResult = pComponent$$Choice2(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<Decl> v$el$3 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$3;
                    }
                    { // Start scope for a5.
                      List<Decl> a5 = cast(yyOpValue1);

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pend(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          if (a3 == null) a3 = Collections.<Import>emptyList();
                          if (a5 == null) a5 = Collections.<Decl>emptyList();
                          Span span = createSpan(yyStart,yyCount);
                          if (a1 == null)
                          yyValue = new Component(span, a2, a3, a4, a5);
                          else
                          yyValue = new Component(span, true, a2, a3, a4, a5);

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    } // End scope for a5.
                  }
                }
              }
            } // End scope for a3.
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared53.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.Fortress.Component$$Choice1 
   * and com.sun.fortress.parser.Fortress.Api$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared53(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    List<Import> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pImports(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyResult = psemicolon(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.Component$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComponent$$Choice2(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDecls(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyResult = psemicolon(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.Api.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pApi(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Api        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pnative(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      String a1 = cast(yyOpValue1);

      yyResult = papi(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pAPIName(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            APIName a2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = p$$Shared53(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Import> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for a3.
              List<Import> a3 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pApi$$Choice2(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<AbsDecl> v$el$3 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$3;
              }
              { // Start scope for a4.
                List<AbsDecl> a4 = cast(yyOpValue1);

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pend(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    if (a3 == null) a3 = Collections.<Import>emptyList();
                    if (a4 == null) a4 = Collections.<AbsDecl>emptyList();
                    Span span = createSpan(yyStart,yyCount);
                    if (a1 == null)
                    yyValue = new Api(span, a2, a3, a4);
                    else
                    yyValue = new Api(span, true, a2, a3, a4);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for a4.
            } // End scope for a3.
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.Api$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pApi$$Choice2(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyOption1;
    List<AbsDecl> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pAbsDecls(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyResult = psemicolon(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.Imports.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImports(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fImports) 
      yyColumn.chunk1.fImports = pImports$1(yyStart);
    return yyColumn.chunk1.fImports;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.Imports. */
  private Result pImports$1(final int yyStart) throws IOException {
    Result       yyResult;
    List<Import> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pImport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Import> a1 = yyResult.semanticValue();

      yyResult = pImports$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<List<Import>> a2s = yyResult.semanticValue();

        for (List<Import> i : a2s.list()) {
          for (Import j : i) {
            a1.add(j);
          }
        }
        yyValue = a1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.Imports$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImports$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fImports$$Star1) 
      yyColumn.chunk1.fImports$$Star1 = pImports$$Star1$1(yyStart);
    return yyColumn.chunk1.fImports$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.Imports$$Star1. */
  private Result pImports$$Star1$1(final int yyStart) throws IOException {
    Result             yyResult;
    Pair<List<Import>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pImport(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Import> v$el$1 = yyResult.semanticValue();

        yyResult = pImports$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<List<Import>> v$2 = yyResult.semanticValue();

          yyValue = new Pair<List<Import>>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.Import.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImport(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fImport) 
      yyColumn.chunk1.fImport = pImport$1(yyStart);
    return yyColumn.chunk1.fImport;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.Import. */
  private Result pImport$1(final int yyStart) throws IOException {
    Result       yyResult;
    List<Import> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pimport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pImportedNames(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = papi(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pAliasedAPINames(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<AliasedAPIName> a1 = yyResult.semanticValue();

              Import imp = new ImportApi(createSpan(yyStart, yyCount), a1);
              yyValue = FortressUtil.mkList(imp);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.ImportedNames.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImportedNames(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Object       yyOpValue1;
    List<Import> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAPIName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      APIName a1 = yyResult.semanticValue();

      yyResult = pdot(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = popencurly(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              final int yyChoice1 = yyResult.index;

              // Nested alternative 1.

              yyResult = pellipses(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pclosecurly(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption1  = yyResult.index;
                    yyOpValue1 = null;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pexcept(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pw(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pSimpleNames(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            List<SimpleName> v$el$1 = yyResult.semanticValue();

                            yyOption1  = yyResult.index;
                            yyOpValue1 = v$el$1;
                          }
                        }
                      }
                    }
                    { // Start scope for a2.
                      List<SimpleName> a2 = cast(yyOpValue1);

                      if (a2 == null) a2 = Collections.<SimpleName>emptyList();
                      yyValue = FortressUtil.mkList((Import)new ImportStar(
                      createSpan(yyStart,yyCount),a1,a2));

                      return new SemanticValue(yyValue, yyOption1, yyError);
                    } // End scope for a2.
                  }
                }
              }

              // Nested alternative 2.

              yyResult = pAliasedSimpleNameList(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<AliasedSimpleName> a2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcomma(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pellipses(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        String v$el$2 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = v$el$2;
                      }
                    }
                  }
                }
                { // Start scope for a3.
                  String a3 = cast(yyOpValue1);

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pclosecurly(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      Span span = createSpan(yyStart,yyCount);
                      List<Import> imports = FortressUtil.mkList((Import)new ImportNames(span,
                      a1,a2));
                      if (a3 != null)
                      imports.add((Import)new ImportStar(span, a1,
                      Collections.<SimpleName>emptyList()));
                      yyValue = imports;

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                } // End scope for a3.
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pas(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id v$el$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
          }
        }
      }
      { // Start scope for a2.
        Id a2 = cast(yyOpValue1);

        AliasedSimpleName an;
        APIName api = Option.unwrap(a1.getApi());
        SimpleName name = a1.getName();
        if (a2 == null)
        an = NodeFactory.makeAliasedSimpleName(name.getSpan(), name);
        else
        an = NodeFactory.makeAliasedSimpleName(FortressUtil.spanTwo(name,a2),
        name, a2);
        yyValue = FortressUtil.mkList((Import)new ImportNames(
        createSpan(yyStart,yyCount),
        api, FortressUtil.mkList(an)));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.SimpleNames.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleNames(final int yyStart) throws IOException {
    Result           yyResult;
    List<SimpleName> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimpleName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SimpleName a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSimpleNameList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.SimpleNameList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleNameList(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyRepetition1;
    Pair<SimpleName> yyRepValue1;
    List<SimpleName> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimpleName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SimpleName a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pSimpleName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                SimpleName v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<SimpleName>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<SimpleName> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.AliasedSimpleName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedSimpleName(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAliasedSimpleName) 
      yyColumn.chunk1.fAliasedSimpleName = pAliasedSimpleName$1(yyStart);
    return yyColumn.chunk1.fAliasedSimpleName;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.AliasedSimpleName. */
  private Result pAliasedSimpleName$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    Object            yyOpValue1;
    AliasedSimpleName yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pas(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        Id a2 = cast(yyOpValue1);

        Span span = createSpan(yyStart,yyCount);
        if (a2 == null)
        yyValue = NodeFactory.makeAliasedSimpleName(span, a1);
        else
        yyValue = NodeFactory.makeAliasedSimpleName(span, a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pOp(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pas(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pOp(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Op v$el$2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
              }
            }
          }
          { // Start scope for a2.
            Op a2 = cast(yyOpValue1);

            Span span = createSpan(yyStart,yyCount);
            if (a2 == null)
            yyValue = NodeFactory.makeAliasedSimpleName(span, a1);
            else
            yyValue = NodeFactory.makeAliasedSimpleName(span, a1, a2);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a2.
        }

        // Nested alternative 2.

        yyResult = pEncloserPair(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Enclosing a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pas(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pEncloserPair(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Enclosing v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
            }
          }
          { // Start scope for a2.
            Enclosing a2 = cast(yyOpValue1);

            Span span = createSpan(yyStart,yyCount);
            if (a2 == null)
            yyValue = NodeFactory.makeAliasedSimpleName(span, a1);
            else
            yyValue = NodeFactory.makeAliasedSimpleName(span, a1, a2);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.AliasedSimpleNameList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedSimpleNameList(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    int                     yyRepetition1;
    Pair<AliasedSimpleName> yyRepValue1;
    List<AliasedSimpleName> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAliasedSimpleName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AliasedSimpleName a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pAliasedSimpleName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                AliasedSimpleName v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = 
                  new Pair<AliasedSimpleName>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<AliasedSimpleName> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.AliasedAPINames.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedAPINames(final int yyStart) throws IOException {
    Result               yyResult;
    List<AliasedAPIName> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAliasedAPIName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AliasedAPIName a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAliasedAPINameList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.AliasedAPIName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedAPIName(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAliasedAPIName) 
      yyColumn.chunk1.fAliasedAPIName = pAliasedAPIName$1(yyStart);
    return yyColumn.chunk1.fAliasedAPIName;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.AliasedAPIName. */
  private Result pAliasedAPIName$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    Id             yyOpValue1;
    AliasedAPIName yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAPIName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      APIName a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pas(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        Id a2 = yyOpValue1;

        Span span = createSpan(yyStart,yyCount);
        if (a2 == null)
        yyValue = new AliasedAPIName(span, a1, Option.<Id>none());
        else
        yyValue = new AliasedAPIName(span, a1, Option.some(a2));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.AliasedAPINameList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedAPINameList(final int yyStart) throws IOException {
    Result               yyResult;
    int                  yyRepetition1;
    Pair<AliasedAPIName> yyRepValue1;
    List<AliasedAPIName> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAliasedAPIName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AliasedAPIName a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pAliasedAPIName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                AliasedAPIName v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<AliasedAPIName>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<AliasedAPIName> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.Exports.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExports(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExports) 
      yyColumn.chunk1.fExports = pExports$1(yyStart);
    return yyColumn.chunk1.fExports;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.Exports. */
  private Result pExports$1(final int yyStart) throws IOException {
    Result       yyResult;
    List<Export> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Export a1 = yyResult.semanticValue();

      yyResult = pExports$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Export> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.Exports$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExports$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExports$$Star1) 
      yyColumn.chunk1.fExports$$Star1 = pExports$$Star1$1(yyStart);
    return yyColumn.chunk1.fExports$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.Exports$$Star1. */
  private Result pExports$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<Export> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pExport(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Export v$el$1 = yyResult.semanticValue();

        yyResult = pExports$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Export> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Export>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.Export.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExport(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExport) 
      yyColumn.chunk1.fExport = pExport$1(yyStart);
    return yyColumn.chunk1.fExport;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.Export. */
  private Result pExport$1(final int yyStart) throws IOException {
    Result     yyResult;
    Export     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAPINames(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<APIName> a1 = yyResult.semanticValue();

          yyValue = new Export(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.APINames.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAPINames(final int yyStart) throws IOException {
    Result        yyResult;
    List<APIName> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAPIName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      APIName a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAPINameList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.Fortress.APINameList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAPINameList(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyRepetition1;
    Pair<APIName> yyRepValue1;
    List<APIName> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAPIName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      APIName a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pAPIName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                APIName v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<APIName>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<APIName> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.Decls.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecls(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fDecls) 
      yyColumn.chunk1.fDecls = pDecls$1(yyStart);
    return yyColumn.chunk1.fDecls;
  }

  /** Actually parse Declaration.Decls. */
  private Result pDecls$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Decl> a1 = yyResult.semanticValue();

      yyResult = pDecls$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<List<Decl>> a2s = yyResult.semanticValue();

        for (List<Decl> ds : a2s.list()) {
          a1.addAll(ds);
        }
        yyValue = a1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.Decls$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecls$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fDecls$$Star1) 
      yyColumn.chunk1.fDecls$$Star1 = pDecls$$Star1$1(yyStart);
    return yyColumn.chunk1.fDecls$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.Decls$$Star1. */
  private Result pDecls$$Star1$1(final int yyStart) throws IOException {
    Result           yyResult;
    Pair<List<Decl>> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDecl(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Decl> v$el$1 = yyResult.semanticValue();

        yyResult = pDecls$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<List<Decl>> v$2 = yyResult.semanticValue();

          yyValue = new Pair<List<Decl>>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.Decl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecl(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDecl) 
      yyColumn.chunk2.fDecl = pDecl$1(yyStart);
    return yyColumn.chunk2.fDecl;
  }

  /** Actually parse Declaration.Decl. */
  private Result pDecl$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitDecl a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pObjectDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ObjectDecl a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pVariable$VarDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      VarDecl a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pFnDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Decl a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pDimUnitDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pTypeAlias(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeAlias a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pTestDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TestDecl a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pPropertyDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PropertyDecl a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pExternalSyntax(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExternalSyntax a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((Decl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.AbsDecls.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsDecls(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAbsDecls) 
      yyColumn.chunk2.fAbsDecls = pAbsDecls$1(yyStart);
    return yyColumn.chunk2.fAbsDecls;
  }

  /** Actually parse Declaration.AbsDecls. */
  private Result pAbsDecls$1(final int yyStart) throws IOException {
    Result        yyResult;
    List<AbsDecl> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAbsDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<AbsDecl> a1 = yyResult.semanticValue();

      yyResult = pAbsDecls$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<List<AbsDecl>> a2s = yyResult.semanticValue();

        for (List<AbsDecl> ds : a2s.list()) {
          a1.addAll(ds);
        }
        yyValue = a1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.AbsDecls$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsDecls$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAbsDecls$$Star1) 
      yyColumn.chunk2.fAbsDecls$$Star1 = pAbsDecls$$Star1$1(yyStart);
    return yyColumn.chunk2.fAbsDecls$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.AbsDecls$$Star1. */
  private Result pAbsDecls$$Star1$1(final int yyStart) throws IOException {
    Result              yyResult;
    Pair<List<AbsDecl>> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pAbsDecl(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<AbsDecl> v$el$1 = yyResult.semanticValue();

        yyResult = pAbsDecls$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<List<AbsDecl>> v$2 = yyResult.semanticValue();

          yyValue = new Pair<List<AbsDecl>>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.AbsDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsDecl(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAbsDecl) 
      yyColumn.chunk2.fAbsDecl = pAbsDecl$1(yyStart);
    return yyColumn.chunk2.fAbsDecl;
  }

  /** Actually parse Declaration.AbsDecl. */
  private Result pAbsDecl$1(final int yyStart) throws IOException {
    Result        yyResult;
    List<AbsDecl> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAbsTraitDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AbsTraitDecl a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((AbsDecl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAbsObjectDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AbsObjectDecl a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((AbsDecl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = p$$Shared40(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AbsVarDecl a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((AbsDecl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pAbsFnDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AbsFnDecl a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((AbsDecl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pDimUnitDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pTypeAlias(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeAlias a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((AbsDecl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pTestDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TestDecl a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((AbsDecl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pPropertyDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PropertyDecl a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((AbsDecl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pAbsExternalSyntax(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AbsExternalSyntax a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((AbsDecl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyResult = pGrammarDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      GrammarDecl a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList((AbsDecl)a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.Params.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitObject$Params(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    Pair<Object> yyRepValue1;
    int          yyOption1;
    VarargsParam yyOpValue1;
    List<Param>  yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pTraitObject$Param(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        NormalParam v$el$1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Object>(v$el$1, yyRepValue1);
              continue;
            }
          }
        }
      }
      break;
    }
    { // Start scope for a1s.
      Pair<NormalParam> a1s = cast(yyRepValue1.reverse());

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pTraitObject$Varargs(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        VarargsParam v$el$2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
        }
      }
      { // Start scope for a2.
        VarargsParam a2 = yyOpValue1;

        yyResult = pTraitObject$Keyword(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Param a3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pTraitObject$Keyword(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Param v$el$3 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepValue1   = new Pair<Object>(v$el$3, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }
          { // Start scope for a4s.
            Pair<Param> a4s = cast(yyRepValue1.reverse());

            yyValue = FortressUtil.<Param, NormalParam>mkList(a1s.list());
            if (a2 != null) yyValue.add(a2);
            yyValue.add(a3);
            yyValue.addAll(a4s.list());

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for a4s.
        }
      } // End scope for a2.

      // Nested alternative 2.

      yyResult = pTraitObject$Varargs(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        VarargsParam a2 = yyResult.semanticValue();

        yyValue = FortressUtil.<Param, NormalParam>mkList(a1s.list(), a2);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1s.

    // Alternative 2.

    yyResult = pTraitObject$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NormalParam a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pTraitObject$Param(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                NormalParam v$el$4 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Object>(v$el$4, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<NormalParam> a2s = cast(yyRepValue1.reverse());

        yyValue = FortressUtil.<Param, NormalParam>mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared1.
   * This nonterminal represents the duplicate productions 
   * TraitObject.VarargsParam, Parameter.VarargsParam, 
   * and MethodParam.VarargsParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.f$$Shared1) 
      yyColumn.chunk2.f$$Shared1 = p$$Shared1$1(yyStart);
    return yyColumn.chunk2.f$$Shared1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared1. */
  private Result p$$Shared1$1(final int yyStart) throws IOException {
    Result       yyResult;
    VarargsParam yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSymbol$colon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType$Type(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pellipses(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  VarargsType ty = new VarargsType(a2.getSpan(), a2);
                  yyValue = NodeFactory.makeVarargsParam(a1, ty);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.Varargs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitObject$Varargs(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTraitObject$Varargs) 
      yyColumn.chunk2.fTraitObject$Varargs = pTraitObject$Varargs$1(yyStart);
    return yyColumn.chunk2.fTraitObject$Varargs;
  }

  /** Actually parse TraitObject.Varargs. */
  private Result pTraitObject$Varargs$1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    VarargsParam yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ptransient(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          VarargsParam a1 = yyResult.semanticValue();

          yyValue = NodeFactory.makeVarargsParam(a1, FortressUtil.mkList(
          (Modifier)new ModifierTransient(createSpan(yyStart,9))));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.Keyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitObject$Keyword(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTraitObject$Keyword) 
      yyColumn.chunk2.fTraitObject$Keyword = pTraitObject$Keyword$1(yyStart);
    return yyColumn.chunk2.fTraitObject$Keyword;
  }

  /** Actually parse TraitObject.Keyword. */
  private Result pTraitObject$Keyword$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitObject$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NormalParam a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeParam(a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared2.
   * This nonterminal represents the duplicate productions 
   * TraitObject.PlainParam, Parameter.PlainParam, and MethodParam.PlainParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared2(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.f$$Shared2) 
      yyColumn.chunk2.f$$Shared2 = p$$Shared2$1(yyStart);
    return yyColumn.chunk2.f$$Shared2;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared2. */
  private Result p$$Shared2$1(final int yyStart) throws IOException {
    Result      yyResult;
    Result      yyPredResult;
    boolean     yyPredMatched;
    NormalParam yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIsType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a2 = yyResult.semanticValue();

          yyValue = NodeFactory.makeParam(a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyPredMatched = false;

    yyPredResult = p$$Shared2$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pBindId(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id a1 = yyResult.semanticValue();

        yyValue = NodeFactory.makeParam(a1);

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select(" expected", yyStart);
    }

    // Alternative 3.

    yyResult = pType$Type(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeParam(new Id(createSpan(yyStart,yyCount), "_"),
      a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.$$Shared2$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared2$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pclosedoublesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pclosesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = popendoublesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 4.

        yyResult = popensquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 5.

        yyResult = prightarrow(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.Param.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitObject$Param(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTraitObject$Param) 
      yyColumn.chunk2.fTraitObject$Param = pTraitObject$Param$1(yyStart);
    return yyColumn.chunk2.fTraitObject$Param;
  }

  /** Actually parse TraitObject.Param. */
  private Result pTraitObject$Param$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    List<Modifier> yyOpValue1;
    NormalParam    yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pParamFldMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<Modifier> a1 = yyOpValue1;

      yyResult = p$$Shared2(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        NormalParam a2 = yyResult.semanticValue();

        if (a1 != null) yyValue = NodeFactory.makeParam(a2, a1);
        else yyValue = a2;

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = ptransient(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared2(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          NormalParam a1 = yyResult.semanticValue();

          yyValue = NodeFactory.makeParam(a1, FortressUtil.mkList(
          (Modifier)new ModifierTransient(createSpan(yyStart,9))));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.TraitDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitDecl(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    TraitDecl  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pTraitMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<Modifier> a1 = cast(yyOpValue1);

      yyResult = pTraitHeaderFront(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        TraitHeader a2 = yyResult.semanticValue();

        yyResult = pTraitClauses(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          TraitClauses a3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pGoInATrait(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Decl> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
          { // Start scope for a4.
            List<Decl> a4 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pend(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                if (a1 == null) a1 = FortressUtil.emptyModifiers();
                if (a4 == null) a4 = Collections.<Decl>emptyList();
                yyValue =
                new TraitDecl(createSpan(yyStart,yyCount), a1, a2.getName(),
                a2.getStaticParams(), a2.getExtendsClause(), a3.getWhere(),
                a3.getExcludes(), a3.getComprises(), a4);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a4.
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.TraitHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitHeaderFront(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTraitHeaderFront) 
      yyColumn.chunk2.fTraitHeaderFront = pTraitHeaderFront$1(yyStart);
    return yyColumn.chunk2.fTraitHeaderFront;
  }

  /** Actually parse TraitObject.TraitHeaderFront. */
  private Result pTraitHeaderFront$1(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    Object      yyOpValue1;
    TraitHeader yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ptrait(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticParams(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<StaticParam> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<StaticParam> a2 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExtendsWhere(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<TraitTypeWhere> v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
            { // Start scope for a3.
              List<TraitTypeWhere> a3 = cast(yyOpValue1);

              if (a2 == null) a2 = FortressUtil.emptyStaticParams();
              if (a3 == null) a3 = FortressUtil.emptyTraitTypeWheres();
              yyValue = new TraitHeader(a1, a2, a3);

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a3.
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.TraitClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitClauses(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<TraitClause> yyRepValue1;
    TraitClauses      yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pw(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          TraitClause v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<TraitClause>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }
    { // Start scope for a1s.
      Pair<TraitClause> a1s = yyRepValue1.reverse();

      yyValue = new TraitClauses();
      for (TraitClause t : (List<TraitClause>)a1s.list()) {
        yyValue.set(t);
      }

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for a1s.
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.TraitClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitClause(final int yyStart) throws IOException {
    Result      yyResult;
    TraitClause yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExcludes(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<TraitType> a1 = yyResult.semanticValue();

      yyValue = new Excludes(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pComprises(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<TraitType> a1 = yyResult.semanticValue();

      yyValue = new Comprises(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pWhere(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WhereClause a1 = yyResult.semanticValue();

      yyValue = new Where(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoInATrait.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoInATrait(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Decl> yyOpValue1;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pCoercions(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Decl> v$el$1 = yyResult.semanticValue();

      yyResult = pbr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      List<Decl> a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = pGoFrontInATrait(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Decl> a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pbr(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pGoBackInATrait(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Decl> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a3.
          List<Decl> a3 = yyOpValue1;

          yyValue = new ArrayList<Decl>();
          if (a1 != null) yyValue.addAll(a1);
          yyValue.addAll(a2);
          if (a3 != null) yyValue.addAll(a3);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      }

      // Nested alternative 2.

      yyResult = pGoBackInATrait(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Decl> a2 = yyResult.semanticValue();

        yyValue = new ArrayList<Decl>();
        if (a1 != null) yyValue.addAll(a1);
        yyValue.addAll(a2);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pCoercions(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Decl> a1 = yyResult.semanticValue();

      yyValue = new ArrayList<Decl>();
      yyValue.addAll(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.Coercions.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCoercions(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fCoercions) 
      yyColumn.chunk3.fCoercions = pCoercions$1(yyStart);
    return yyColumn.chunk3.fCoercions;
  }

  /** Actually parse TraitObject.Coercions. */
  private Result pCoercions$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCoercion(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Decl a1 = yyResult.semanticValue();

      yyResult = pCoercions$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Decl> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.Coercions$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCoercions$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fCoercions$$Star1) 
      yyColumn.chunk3.fCoercions$$Star1 = pCoercions$$Star1$1(yyStart);
    return yyColumn.chunk3.fCoercions$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.Coercions$$Star1. */
  private Result pCoercions$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pCoercion(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Decl v$el$1 = yyResult.semanticValue();

        yyResult = pCoercions$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Decl> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Decl>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoFrontInATrait.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoFrontInATrait(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Decl> yyRepValue1;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pGoesFrontInATrait(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Decl a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pbr(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pGoesFrontInATrait(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Decl v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Decl>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Decl> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoesFrontInATrait.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoesFrontInATrait(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fGoesFrontInATrait) 
      yyColumn.chunk3.fGoesFrontInATrait = pGoesFrontInATrait$1(yyStart);
    return yyColumn.chunk3.fGoesFrontInATrait;
  }

  /** Actually parse TraitObject.GoesFrontInATrait. */
  private Result pGoesFrontInATrait$1(final int yyStart) throws IOException {
    Result     yyResult;
    Decl       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared40(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pGetterSetterDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pPropertyDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoBackInATrait.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoBackInATrait(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fGoBackInATrait) 
      yyColumn.chunk3.fGoBackInATrait = pGoBackInATrait$1(yyStart);
    return yyColumn.chunk3.fGoBackInATrait;
  }

  /** Actually parse TraitObject.GoBackInATrait. */
  private Result pGoBackInATrait$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pGoesBackInATrait(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Decl a1 = yyResult.semanticValue();

      yyResult = pGoBackInATrait$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Decl> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.GoBackInATrait$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoBackInATrait$$Star1(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fGoBackInATrait$$Star1) 
      yyColumn.chunk3.fGoBackInATrait$$Star1 = pGoBackInATrait$$Star1$1(yyStart);
    return yyColumn.chunk3.fGoBackInATrait$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.GoBackInATrait$$Star1. */
  private Result pGoBackInATrait$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pGoesBackInATrait(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Decl v$el$1 = yyResult.semanticValue();

        yyResult = pGoBackInATrait$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Decl> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Decl>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoesBackInATrait.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoesBackInATrait(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fGoesBackInATrait) 
      yyColumn.chunk3.fGoesBackInATrait = pGoesBackInATrait$1(yyStart);
    return yyColumn.chunk3.fGoesBackInATrait;
  }

  /** Actually parse TraitObject.GoesBackInATrait. */
  private Result pGoesBackInATrait$1(final int yyStart) throws IOException {
    Result     yyResult;
    Decl       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMdDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pPropertyDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.ObjectDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pObjectDecl(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    ObjectDecl yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pTraitMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<Modifier> a1 = cast(yyOpValue1);

      yyResult = pObjectHeader(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        ObjectHeader a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pGoInAnObject(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Decl> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a3.
          List<Decl> a3 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pend(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              if (a1 == null) a1 = FortressUtil.emptyModifiers();
              if (a3 == null) a3 = Collections.<Decl>emptyList();
              FnHeaderClause fhc = a2.getFnHeaderClause();
              Contract contract = Option.unwrap(fhc.getContractClause(),
              FortressUtil.emptyContract());
              yyValue = new ObjectDecl
              (createSpan(yyStart,yyCount), a1, a2.getName(),
              a2.getStaticParams(), a2.getExtendsClause(), fhc.getWhereClause(),
              a2.getParams(), fhc.getThrowsClause(), contract, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a3.
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.ObjectHeader.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pObjectHeader(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fObjectHeader) 
      yyColumn.chunk3.fObjectHeader = pObjectHeader$1(yyStart);
    return yyColumn.chunk3.fObjectHeader;
  }

  /** Actually parse TraitObject.ObjectHeader. */
  private Result pObjectHeader$1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Object       yyOpValue1;
    ObjectHeader yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pobject(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticParams(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<StaticParam> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<StaticParam> a2 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pObjectValParam(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<Param> v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
            { // Start scope for a3.
              List<Param> a3 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExtendsWhere(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<TraitTypeWhere> v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
              { // Start scope for a4.
                List<TraitTypeWhere> a4 = cast(yyOpValue1);

                yyResult = pFnClauses(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  FnHeaderClause a5 = yyResult.semanticValue();

                  Option<List<Param>> ps = Option.wrap(a3);
                  if (a2 == null) a2 = FortressUtil.emptyStaticParams();
                  if (a4 == null) a4 = FortressUtil.emptyTraitTypeWheres();
                  yyValue = new ObjectHeader(a1, a2, ps, a4, a5);

                  return yyResult.createValue(yyValue, yyError);
                }
              } // End scope for a4.
            } // End scope for a3.
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.ObjectValParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pObjectValParam(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    List<Param> yyOpValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitObject$Params(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<Param> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (a1 == null) yyValue = FortressUtil.emptyParams();
            else yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoInAnObject(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fGoInAnObject) 
      yyColumn.chunk3.fGoInAnObject = pGoInAnObject$1(yyStart);
    return yyColumn.chunk3.fGoInAnObject;
  }

  /** Actually parse TraitObject.GoInAnObject. */
  private Result pGoInAnObject$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Decl> yyOpValue1;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pCoercions(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Decl> v$el$1 = yyResult.semanticValue();

      yyResult = pbr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      List<Decl> a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = pGoFrontInAnObject(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Decl> a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pbr(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pGoBackInAnObject(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Decl> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a3.
          List<Decl> a3 = yyOpValue1;

          yyValue = new ArrayList<Decl>();
          if (a1 != null) yyValue.addAll(a1);
          yyValue.addAll(a2);
          if (a3 != null) yyValue.addAll(a3);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      }

      // Nested alternative 2.

      yyResult = pGoBackInAnObject(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Decl> a2 = yyResult.semanticValue();

        yyValue = new ArrayList<Decl>();
        if (a1 != null) yyValue.addAll(a1);
        yyValue.addAll(a2);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pCoercions(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Decl> a1 = yyResult.semanticValue();

      yyValue = new ArrayList<Decl>();
      yyValue.addAll(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoFrontInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoFrontInAnObject(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Decl> yyRepValue1;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pGoesFrontInAnObject(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Decl a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pbr(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pGoesFrontInAnObject(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Decl v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Decl>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Decl> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoesFrontInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoesFrontInAnObject(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fGoesFrontInAnObject) 
      yyColumn.chunk3.fGoesFrontInAnObject = pGoesFrontInAnObject$1(yyStart);
    return yyColumn.chunk3.fGoesFrontInAnObject;
  }

  /** Actually parse TraitObject.GoesFrontInAnObject. */
  private Result pGoesFrontInAnObject$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Decl       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pField$VarDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pGetterSetterDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pPropertyDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoBackInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoBackInAnObject(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fGoBackInAnObject) 
      yyColumn.chunk3.fGoBackInAnObject = pGoBackInAnObject$1(yyStart);
    return yyColumn.chunk3.fGoBackInAnObject;
  }

  /** Actually parse TraitObject.GoBackInAnObject. */
  private Result pGoBackInAnObject$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pGoesBackInAnObject(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Decl a1 = yyResult.semanticValue();

      yyResult = pGoBackInAnObject$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Decl> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.GoBackInAnObject$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoBackInAnObject$$Star1(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fGoBackInAnObject$$Star1) 
      yyColumn.chunk4.fGoBackInAnObject$$Star1 = pGoBackInAnObject$$Star1$1(yyStart);
    return yyColumn.chunk4.fGoBackInAnObject$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.GoBackInAnObject$$Star1. */
  private Result pGoBackInAnObject$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Decl> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pGoesBackInAnObject(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Decl v$el$1 = yyResult.semanticValue();

        yyResult = pGoBackInAnObject$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Decl> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Decl>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.GoesBackInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGoesBackInAnObject(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fGoesBackInAnObject) 
      yyColumn.chunk4.fGoesBackInAnObject = pGoesBackInAnObject$1(yyStart);
    return yyColumn.chunk4.fGoesBackInAnObject;
  }

  /** Actually parse TraitObject.GoesBackInAnObject. */
  private Result pGoesBackInAnObject$1(final int yyStart) throws IOException {
    Result     yyResult;
    Decl       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMdDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pPropertyDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.AbsTraitDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsTraitDecl(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Object       yyOpValue1;
    AbsTraitDecl yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pAbsTraitMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<Modifier> a1 = cast(yyOpValue1);

      yyResult = pTraitHeaderFront(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        TraitHeader a2 = yyResult.semanticValue();

        yyResult = pAbsTraitClauses(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          TraitClauses a3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pAbsGoInATrait(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<AbsDecl> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
          { // Start scope for a4.
            List<AbsDecl> a4 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pend(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                if (a1 == null) a1 = FortressUtil.emptyModifiers();
                if (a4 == null) a4 = Collections.<AbsDecl>emptyList();
                yyValue = new AbsTraitDecl
                (createSpan(yyStart,yyCount), a1, a2.getName(),
                a2.getStaticParams(), a2.getExtendsClause(), a3.getWhere(),
                a3.getExcludes(), a3.getComprises(), a4);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a4.
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.AbsTraitClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsTraitClauses(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<TraitClause> yyRepValue1;
    TraitClauses      yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pw(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAbsTraitClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          TraitClause v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<TraitClause>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }
    { // Start scope for a1s.
      Pair<TraitClause> a1s = yyRepValue1.reverse();

      yyValue = new TraitClauses();
      for (TraitClause t : (List<TraitClause>)a1s.list()) {
        yyValue.set(t);
      }

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for a1s.
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.AbsTraitClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsTraitClause(final int yyStart) throws IOException {
    Result      yyResult;
    TraitClause yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExcludes(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<TraitType> a1 = yyResult.semanticValue();

      yyValue = new Excludes(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAbsComprises(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<TraitType> a1 = yyResult.semanticValue();

      yyValue = new Comprises(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pWhere(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WhereClause a1 = yyResult.semanticValue();

      yyValue = new Where(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.AbsGoInATrait.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsGoInATrait(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyOption1;
    List<AbsDecl> yyOpValue1;
    List<AbsDecl> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pAbsCoercions(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<AbsDecl> v$el$1 = yyResult.semanticValue();

      yyResult = pbr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      List<AbsDecl> a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = p$$Shared27(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<AbsDecl> a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pbr(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared28(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<AbsDecl> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a3.
          List<AbsDecl> a3 = yyOpValue1;

          yyValue = new ArrayList<AbsDecl>();
          if (a1 != null) yyValue.addAll(a1);
          yyValue.addAll(a2);
          if (a3 != null) yyValue.addAll(a3);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      }

      // Nested alternative 2.

      yyResult = p$$Shared28(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<AbsDecl> a2 = yyResult.semanticValue();

        yyValue = new ArrayList<AbsDecl>();
        if (a1 != null) yyValue.addAll(a1);
        yyValue.addAll(a2);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pAbsCoercions(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<AbsDecl> a1 = yyResult.semanticValue();

      yyValue = new ArrayList<AbsDecl>();
      yyValue.addAll(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.AbsCoercions.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsCoercions(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fAbsCoercions) 
      yyColumn.chunk4.fAbsCoercions = pAbsCoercions$1(yyStart);
    return yyColumn.chunk4.fAbsCoercions;
  }

  /** Actually parse TraitObject.AbsCoercions. */
  private Result pAbsCoercions$1(final int yyStart) throws IOException {
    Result        yyResult;
    List<AbsDecl> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAbsCoercion(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AbsDecl a1 = yyResult.semanticValue();

      yyResult = pAbsCoercions$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<AbsDecl> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.AbsCoercions$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsCoercions$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fAbsCoercions$$Star1) 
      yyColumn.chunk4.fAbsCoercions$$Star1 = pAbsCoercions$$Star1$1(yyStart);
    return yyColumn.chunk4.fAbsCoercions$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.AbsCoercions$$Star1. */
  private Result pAbsCoercions$$Star1$1(final int yyStart) 
    throws IOException {

    Result        yyResult;
    Pair<AbsDecl> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pAbsCoercion(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        AbsDecl v$el$1 = yyResult.semanticValue();

        yyResult = pAbsCoercions$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<AbsDecl> v$2 = yyResult.semanticValue();

          yyValue = new Pair<AbsDecl>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared27.
   * This nonterminal represents the duplicate productions 
   * TraitObject.AbsGoFrontInATrait and TraitObject.AbsGoFrontInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared27(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.f$$Shared27) 
      yyColumn.chunk4.f$$Shared27 = p$$Shared27$1(yyStart);
    return yyColumn.chunk4.f$$Shared27;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared27. */
  private Result p$$Shared27$1(final int yyStart) throws IOException {
    Result        yyResult;
    List<AbsDecl> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared3(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AbsDecl a1 = yyResult.semanticValue();

      yyResult = p$$Shared27$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<AbsDecl> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.$$Shared27$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared27$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.f$$Shared27$$Star1) 
      yyColumn.chunk4.f$$Shared27$$Star1 = p$$Shared27$$Star1$1(yyStart);
    return yyColumn.chunk4.f$$Shared27$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared27$$Star1. */
  private Result p$$Shared27$$Star1$1(final int yyStart) throws IOException {
    Result        yyResult;
    Pair<AbsDecl> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = p$$Shared3(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        AbsDecl v$el$1 = yyResult.semanticValue();

        yyResult = p$$Shared27$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<AbsDecl> v$2 = yyResult.semanticValue();

          yyValue = new Pair<AbsDecl>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared3.
   * This nonterminal represents the duplicate productions 
   * TraitObject.AbsGoesFrontInATrait and TraitObject.AbsGoesFrontInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared3(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.f$$Shared3) 
      yyColumn.chunk4.f$$Shared3 = p$$Shared3$1(yyStart);
    return yyColumn.chunk4.f$$Shared3;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared3. */
  private Result p$$Shared3$1(final int yyStart) throws IOException {
    Result     yyResult;
    AbsDecl    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pApiFldDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAbsGetterSetterDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pPropertyDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared28.
   * This nonterminal represents the duplicate productions 
   * TraitObject.AbsGoBackInATrait and TraitObject.AbsGoBackInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared28(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.f$$Shared28) 
      yyColumn.chunk4.f$$Shared28 = p$$Shared28$1(yyStart);
    return yyColumn.chunk4.f$$Shared28;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared28. */
  private Result p$$Shared28$1(final int yyStart) throws IOException {
    Result        yyResult;
    List<AbsDecl> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared4(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AbsDecl a1 = yyResult.semanticValue();

      yyResult = p$$Shared28$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<AbsDecl> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.$$Shared28$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared28$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.f$$Shared28$$Star1) 
      yyColumn.chunk4.f$$Shared28$$Star1 = p$$Shared28$$Star1$1(yyStart);
    return yyColumn.chunk4.f$$Shared28$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared28$$Star1. */
  private Result p$$Shared28$$Star1$1(final int yyStart) throws IOException {
    Result        yyResult;
    Pair<AbsDecl> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = p$$Shared4(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        AbsDecl v$el$1 = yyResult.semanticValue();

        yyResult = p$$Shared28$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<AbsDecl> v$2 = yyResult.semanticValue();

          yyValue = new Pair<AbsDecl>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared4.
   * This nonterminal represents the duplicate productions 
   * TraitObject.AbsGoesBackInATrait and TraitObject.AbsGoesBackInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared4(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.f$$Shared4) 
      yyColumn.chunk4.f$$Shared4 = p$$Shared4$1(yyStart);
    return yyColumn.chunk4.f$$Shared4;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared4. */
  private Result p$$Shared4$1(final int yyStart) throws IOException {
    Result     yyResult;
    AbsDecl    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAbsMdDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pPropertyDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.AbsObjectDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsObjectDecl(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyOption1;
    Object        yyOpValue1;
    AbsObjectDecl yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pAbsTraitMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<Modifier> a1 = cast(yyOpValue1);

      yyResult = pObjectHeader(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        ObjectHeader a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pAbsGoInAnObject(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<AbsDecl> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a3.
          List<AbsDecl> a3 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pend(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              if (a1 == null) a1 = FortressUtil.emptyModifiers();
              if (a3 == null) a3 = Collections.<AbsDecl>emptyList();
              FnHeaderClause fhc = a2.getFnHeaderClause();
              Contract contract = Option.unwrap(fhc.getContractClause(),
              FortressUtil.emptyContract());
              yyValue = new AbsObjectDecl
              (createSpan(yyStart,yyCount), a1, a2.getName(),
              a2.getStaticParams(), a2.getExtendsClause(), fhc.getWhereClause(),
              a2.getParams(), fhc.getThrowsClause(), contract, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a3.
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal TraitObject.AbsGoInAnObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsGoInAnObject(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyOption1;
    List<AbsDecl> yyOpValue1;
    List<AbsDecl> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pAbsCoercions(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<AbsDecl> v$el$1 = yyResult.semanticValue();

      yyResult = pbr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      List<AbsDecl> a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = p$$Shared27(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<AbsDecl> a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pbr(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared28(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<AbsDecl> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a3.
          List<AbsDecl> a3 = yyOpValue1;

          yyValue = new ArrayList<AbsDecl>();
          if (a1 != null) yyValue.addAll(a1);
          yyValue.addAll(a2);
          if (a3 != null) yyValue.addAll(a3);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      }

      // Nested alternative 2.

      yyResult = p$$Shared28(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<AbsDecl> a2 = yyResult.semanticValue();

        yyValue = new ArrayList<AbsDecl>();
        if (a1 != null) yyValue.addAll(a1);
        yyValue.addAll(a2);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pAbsCoercions(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<AbsDecl> a1 = yyResult.semanticValue();

      yyValue = new ArrayList<AbsDecl>();
      yyValue.addAll(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Function.FnDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnDecl(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Decl       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pFnMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$2 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$2;
    }
    { // Start scope for a1.
      List<Modifier> a1 = cast(yyOpValue1);

      yyResult = pFnHeaderFront(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        FnHeaderFront a2 = yyResult.semanticValue();

        yyResult = pFnHeaderClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FnHeaderClause a3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pequals(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineExpr(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Expr v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
            }
          }
          { // Start scope for a4.
            Expr a4 = cast(yyOpValue1);

            if (a1 == null) a1 = FortressUtil.emptyModifiers();
            Span span = createSpan(yyStart,yyCount);
            if (a4 == null) yyValue = FortressUtil.mkAbsFnDecl(span, a1, a2, a3);
            else            yyValue = FortressUtil.mkFnDecl(span, a1, a2, a3, a4);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a4.
        }
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pFnSig(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Function.FnSig.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnSig(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fFnSig) 
      yyColumn.chunk5.fFnSig = pFnSig$1(yyStart);
    return yyColumn.chunk5.fFnSig;
  }

  /** Actually parse Function.FnSig. */
  private Result pFnSig$1(final int yyStart) throws IOException {
    Result     yyResult;
    AbsFnDecl  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimpleName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SimpleName a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSymbol$colon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              final List<Modifier> mods = FortressUtil.emptyModifiers();
              final List<Param>  params = FortressUtil.emptyParams();
              
              if (!(a2 instanceof ArrowType)) {
                bug(errorMsg("Abstract function declaration should have an arrow " +
                "type.", a2));
              }
              
              ((ArrowType)a2).getDomain().accept(new NodeAbstractVisitor_void() {
                public void forType(Type that) {
                  Id name = new Id(that.getSpan(), "_");
                  params.add(NodeFactory.makeParam(that.getSpan(),mods,name,that));
                }
                public void forVarargsType(VarargsType that) {
                  Id name = new Id(that.getSpan(), "_");
                  params.add(NodeFactory.makeVarargsParam(that.getSpan(), mods,
                  name, that));
                }
                public void forArgType(ArgType that) {
                  for (AbstractNode i : that.getElements()) { i.accept(this); }
                  if (that.getVarargs().isSome())
                  Option.unwrap(that.getVarargs()).accept(this);
                  assert(that.getKeywords().isEmpty()): "Keyword parameters present"
                  + " in a FnSig: " + that;
                }
                public void forTupleType(TupleType that) {
                  for (AbstractNode i : that.getElements()) { i.accept(this); }
                }
                public void defaultCase(Node that) {
                  bug(errorMsg("Node expected to be a Type; was: ", that));
                }
              });
              yyValue = FortressUtil.mkAbsFnDecl(createSpan(yyStart,yyCount), mods, a1,
              params, ((ArrowType)a2).getRange());

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Function.AbsFnDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsFnDecl(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    List<Modifier> yyOpValue1;
    AbsFnDecl      yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pAbsFnMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$2 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$2;
    }
    { // Start scope for a1.
      List<Modifier> a1 = yyOpValue1;

      yyResult = pFnHeaderFront(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        FnHeaderFront a2 = yyResult.semanticValue();

        yyResult = pFnHeaderClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FnHeaderClause a3 = yyResult.semanticValue();

          if (a1 == null) a1 = FortressUtil.emptyModifiers();
          yyValue = FortressUtil.mkAbsFnDecl(createSpan(yyStart,yyCount),a1,a2,a3);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pFnSig(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Function.FnHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnHeaderFront(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fFnHeaderFront) 
      yyColumn.chunk5.fFnHeaderFront = pFnHeaderFront$1(yyStart);
    return yyColumn.chunk5.fFnHeaderFront;
  }

  /** Actually parse Function.FnHeaderFront. */
  private Result pFnHeaderFront$1(final int yyStart) throws IOException {
    Result        yyResult;
    FnHeaderFront yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNamedFnHeaderFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pParameter$OpHeaderFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Function.NamedFnHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNamedFnHeaderFront(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fNamedFnHeaderFront) 
      yyColumn.chunk5.fNamedFnHeaderFront = pNamedFnHeaderFront$1(yyStart);
    return yyColumn.chunk5.fNamedFnHeaderFront;
  }

  /** Actually parse Function.NamedFnHeaderFront. */
  private Result pNamedFnHeaderFront$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<StaticParam> yyOpValue1;
    FnHeaderFront     yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticParam> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        List<StaticParam> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pParameter$ValParam(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Param> a3 = yyResult.semanticValue();

            if (a2 == null) a2 = FortressUtil.emptyStaticParams();
            yyValue = new FnHeaderFront(a1, a2, a3);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.ValParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$ValParam(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fParameter$ValParam) 
      yyColumn.chunk5.fParameter$ValParam = pParameter$ValParam$1(yyStart);
    return yyColumn.chunk5.fParameter$ValParam;
  }

  /** Actually parse Parameter.ValParam. */
  private Result pParameter$ValParam$1(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    List<Param> yyOpValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = FortressUtil.<Param, NormalParam>mkList(NodeFactory.makeParam(a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pParameter$Params(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<Param> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (a1 == null) yyValue = FortressUtil.emptyParams();
            else            yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.Params.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$Params(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fParameter$Params) 
      yyColumn.chunk5.fParameter$Params = pParameter$Params$1(yyStart);
    return yyColumn.chunk5.fParameter$Params;
  }

  /** Actually parse Parameter.Params. */
  private Result pParameter$Params$1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    VarargsParam yyOpValue1;
    List<Param>  yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParameter$Params$$Star1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<NormalParam> a1s = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = p$$Shared29(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        VarargsParam v$el$3 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
          }
        }
      }
      { // Start scope for a2.
        VarargsParam a2 = yyOpValue1;

        yyResult = pParameter$Keyword(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Param a3 = yyResult.semanticValue();

          yyResult = pParameter$Params$$Star2(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<Param> a4s = yyResult.semanticValue();

            yyValue = FortressUtil.<Param, NormalParam>mkList(a1s.list());
            if (a2 != null) yyValue.add(a2);
            yyValue.add(a3);
            yyValue.addAll(a4s.list());

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.

      // Nested alternative 2.

      yyResult = p$$Shared29(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        VarargsParam a2 = yyResult.semanticValue();

        yyValue = FortressUtil.<Param, NormalParam>mkList(a1s.list(), a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pParameter$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NormalParam a1 = yyResult.semanticValue();

      yyResult = pParameter$Params$$Star3(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<NormalParam> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.<Param, NormalParam>mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Parameter.Params$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$Params$$Star1(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fParameter$Params$$Star1) 
      yyColumn.chunk5.fParameter$Params$$Star1 = pParameter$Params$$Star1$1(yyStart);
    return yyColumn.chunk5.fParameter$Params$$Star1;
  }

  /** Actually parse Parameter.Params$$Star1. */
  private Result pParameter$Params$$Star1$1(final int yyStart) 
    throws IOException {

    Result            yyResult;
    Pair<NormalParam> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParameter$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NormalParam v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pParameter$Params$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<NormalParam> v$2 = yyResult.semanticValue();

              yyValue = new Pair<NormalParam>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Parameter.Params$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$Params$$Star2(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fParameter$Params$$Star2) 
      yyColumn.chunk5.fParameter$Params$$Star2 = pParameter$Params$$Star2$1(yyStart);
    return yyColumn.chunk5.fParameter$Params$$Star2;
  }

  /** Actually parse Parameter.Params$$Star2. */
  private Result pParameter$Params$$Star2$1(final int yyStart) 
    throws IOException {

    Result      yyResult;
    Pair<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pParameter$Keyword(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Param v$el$4 = yyResult.semanticValue();

            yyResult = pParameter$Params$$Star2(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Param> v$5 = yyResult.semanticValue();

              yyValue = new Pair<Param>(v$el$4, v$5);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Parameter.Params$$Star3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$Params$$Star3(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fParameter$Params$$Star3) 
      yyColumn.chunk5.fParameter$Params$$Star3 = pParameter$Params$$Star3$1(yyStart);
    return yyColumn.chunk5.fParameter$Params$$Star3;
  }

  /** Actually parse Parameter.Params$$Star3. */
  private Result pParameter$Params$$Star3$1(final int yyStart) 
    throws IOException {

    Result            yyResult;
    Pair<NormalParam> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pParameter$Param(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            NormalParam v$el$6 = yyResult.semanticValue();

            yyResult = pParameter$Params$$Star3(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<NormalParam> v$7 = yyResult.semanticValue();

              yyValue = new Pair<NormalParam>(v$el$6, v$7);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared29.
   * This nonterminal represents the duplicate productions Parameter.Varargs 
   * and MethodParam.Varargs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared29(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.f$$Shared29) 
      yyColumn.chunk5.f$$Shared29 = p$$Shared29$1(yyStart);
    return yyColumn.chunk5.f$$Shared29;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared29. */
  private Result p$$Shared29$1(final int yyStart) throws IOException {
    Result       yyResult;
    VarargsParam yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.Keyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$Keyword(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fParameter$Keyword) 
      yyColumn.chunk5.fParameter$Keyword = pParameter$Keyword$1(yyStart);
    return yyColumn.chunk5.fParameter$Keyword;
  }

  /** Actually parse Parameter.Keyword. */
  private Result pParameter$Keyword$1(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParameter$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NormalParam a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeParam(a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.Param.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$Param(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fParameter$Param) 
      yyColumn.chunk6.fParameter$Param = pParameter$Param$1(yyStart);
    return yyColumn.chunk6.fParameter$Param;
  }

  /** Actually parse Parameter.Param. */
  private Result pParameter$Param$1(final int yyStart) throws IOException {
    Result      yyResult;
    NormalParam yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Parameter.OpHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter$OpHeaderFront(final int yyStart) 
    throws IOException {

    Result        yyResult;
    int           yyOption1;
    Object        yyOpValue1;
    FnHeaderFront yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBIG(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for big.
        String big = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared54(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Object opa1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticParams(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<StaticParam> v$el$4 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$4;
              }
            }
            { // Start scope for opa2.
              List<StaticParam> opa2 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pParameter$Params(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Param> opa3 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = p$$Shared55(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Op opa4 = yyResult.semanticValue();

                      SimpleName name;
                      Span span = createSpan(yyStart,yyCount);
                      Op leftOp = (Op)opa1;
                      String left  = leftOp.getText();
                      String right = opa4.getText();
                      if (PrecedenceMap.ONLY.matchedBrackets(left, right) ||
                      left.equals("{|->") && right.equals("}")) {
                        if (big != null) {
                          leftOp = NodeFactory.makeOpBig(leftOp.getSpan(), "BIG " + left);
                          opa4 = NodeFactory.makeOpBig(opa4.getSpan(), "BIG " + right);
                        }
                        name = new Enclosing(span, leftOp, opa4);
                      } else
                      name = error(leftOp, "Mismatched enclosing operator definition: "
                      + left + " and " + right);
                      if (opa2 == null) opa2 = FortressUtil.emptyStaticParams();
                      yyValue = new FnHeaderFront(name, opa2, opa3);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            } // End scope for opa2.
          }
        }
      } // End scope for big.

      // Nested alternative 2.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pParameter$ValParam(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared56(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Op a2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pStaticParams(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<StaticParam> v$el$9 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$9;
                }
              }
              { // Start scope for a3.
                List<StaticParam> a3 = cast(yyOpValue1);

                Span span = createSpan(yyStart,yyCount);
                if (a3 == null)
                yyValue = new FnHeaderFront(NodeFactory.makeOpPostfix(a2), a1);
                else
                yyValue = new FnHeaderFront(NodeFactory.makeOpPostfix(a2), a3, a1);

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for a3.
            }
          }
        }
      }

      // Nested alternative 3.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBIG(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$10 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$10;
        }
      }
      { // Start scope for big.
        String big = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared57(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Object a1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticParams(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<StaticParam> v$el$13 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$13;
              }
            }
            { // Start scope for a2.
              List<StaticParam> a2 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pParameter$ValParam(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Param> a3 = yyResult.semanticValue();

                  Span span = createSpan(yyStart,yyCount);
                  Op op = (Op)a1;
                  if (big != null)
                  op = NodeFactory.makeOpBig(op.getSpan(), "BIG " + op.getText());
                  else if (op.getText().equals("BIG +") ||
                  op.getText().equals("BIG juxtaposition")) {
                    op = op;
                  } else if (a3.size() == 0) { // nofix
                    op = NodeFactory.makeOpNofix(op);
                  } else if (NodeUtil.isMultifix(a3)) { // multifix
                    op = NodeFactory.makeOpMultifix(op);
                  } else if (a3.size() == 1) { // prefix
                    op = NodeFactory.makeOpPrefix(op);
                  } else if (a3.size() == 2) { // infix
                    op = NodeFactory.makeOpInfix(op);
                  } else { // error
                    op = error(op, "Operator fix is invalid in its dclaration.");
                  }
                  if (a2 == null) yyValue = new FnHeaderFront(op, a3);
                  else            yyValue = new FnHeaderFront(op, a2, a3);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for a2.
          }
        }
      } // End scope for big.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared54.
   * This nonterminal represents the duplicate productions 
   * Parameter.OpHeaderFront$$Choice1 and MethodParam.OpHeaderFront$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared54(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pw(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('|' == yyC) {
          yyIndex = yyResult.index + 1;

          yyC = character(yyIndex);
          if ('-' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('>' == yyC) {
              yyIndex = yyIndex + 1;

              yyValue=NodeFactory.makeOpEnclosing(createSpan(yyStart,yyCount),
              "{|->");

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"|->\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"|->\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"|->\" expected", yyBase);
        }
      }
    }

    // Alternative 2.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared55.
   * This nonterminal represents the duplicate productions 
   * Parameter.OpHeaderFront$$Choice2 and MethodParam.OpHeaderFront$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared55(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared56.
   * This nonterminal represents the duplicate productions 
   * Parameter.OpHeaderFront$$Choice3 and MethodParam.OpHeaderFront$$Choice3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared56(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExponentOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared57.
   * This nonterminal represents the duplicate productions 
   * Parameter.OpHeaderFront$$Choice4 and MethodParam.OpHeaderFront$$Choice4.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared57(final int yyStart) throws IOException {
    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=NodeFactory.makeOpUnknown(createSpan(yyStart,yyCount),
      "^");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pSUM(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=NodeFactory.makeOpBig(createSpan(yyStart,yyCount),
      "BIG +");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pPROD(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue=NodeFactory.makeOpBig(createSpan(yyStart,yyCount),
      "BIG juxtaposition");

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.MdDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMdDecl(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    Object          yyOpValue1;
    FnAbsDeclOrDecl yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMdDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pabstract(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$2 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
    }
    { // Start scope for a1.
      String a1 = cast(yyOpValue1);

      yyOpValue1 = null;

      yyResult = pMdMods(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Modifier> v$el$3 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$3;
      }
      { // Start scope for a2.
        List<Modifier> a2 = cast(yyOpValue1);

        yyResult = pMdHeaderFront(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FnHeaderFront a3 = yyResult.semanticValue();

          yyResult = pFnHeaderClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            FnHeaderClause a4 = yyResult.semanticValue();

            List<Modifier> mods = new ArrayList<Modifier>();
            if (a1 != null)
            mods.add(new ModifierAbstract(createSpan(yyStart,8)));
            if (a2 != null) mods.addAll(a2);
            yyValue = FortressUtil.mkAbsFnDecl(createSpan(yyStart,yyCount), mods,
            a3.getReceiver(), a3, a4);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.MdDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMdDef(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fMdDef) 
      yyColumn.chunk6.fMdDef = pMdDef$1(yyStart);
    return yyColumn.chunk6.fMdDef;
  }

  /** Actually parse Method.MdDef. */
  private Result pMdDef$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    List<Modifier> yyOpValue1;
    FnDecl         yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pMdMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<Modifier> a1 = yyOpValue1;

      yyResult = pMdHeaderFront(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        FnHeaderFront a2 = yyResult.semanticValue();

        yyResult = pFnHeaderClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FnHeaderClause a3 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pequals(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineExpr(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Expr a4 = yyResult.semanticValue();

                  if (a1 == null) a1 = FortressUtil.emptyModifiers();
                  yyValue = FortressUtil.mkFnDecl(createSpan(yyStart,yyCount), a1,
                  a2.getReceiver(), a2, a3, a4);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.AbsMdDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsMdDecl(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    AbsFnDecl  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pabstract(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      String a1 = cast(yyOpValue1);

      yyOpValue1 = null;

      yyResult = pAbsMdMods(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Modifier> v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
      { // Start scope for a2.
        List<Modifier> a2 = cast(yyOpValue1);

        yyResult = pMdHeaderFront(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FnHeaderFront a3 = yyResult.semanticValue();

          yyResult = pFnHeaderClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            FnHeaderClause a4 = yyResult.semanticValue();

            List<Modifier> mods = new ArrayList<Modifier>();
            if (a1 != null)
            mods.add(new ModifierAbstract(createSpan(yyStart,8)));
            if (a2 != null) mods.addAll(a2);
            yyValue = FortressUtil.mkAbsFnDecl(createSpan(yyStart,yyCount), mods,
            a3.getReceiver(), a3, a4);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.MdHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMdHeaderFront(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fMdHeaderFront) 
      yyColumn.chunk6.fMdHeaderFront = pMdHeaderFront$1(yyStart);
    return yyColumn.chunk6.fMdHeaderFront;
  }

  /** Actually parse Method.MdHeaderFront. */
  private Result pMdHeaderFront$1(final int yyStart) throws IOException {
    Result        yyResult;
    FnHeaderFront yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNamedMdHeaderFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMethodParam$OpHeaderFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.NamedMdHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNamedMdHeaderFront(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<StaticParam> yyOpValue1;
    FnHeaderFront     yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticParam> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        List<StaticParam> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pMethodParam$ValParam(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Param> a3 = yyResult.semanticValue();

            if (a2 == null) a2 = FortressUtil.emptyStaticParams();
            yyValue = new FnHeaderFront(a1, a2, a3);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.GetterSetterDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGetterSetterDecl(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    Object          yyOpValue1;
    FnAbsDeclOrDecl yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pGetterSetterDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pabstract(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$2 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
    }
    { // Start scope for a1.
      String a1 = cast(yyOpValue1);

      yyOpValue1 = null;

      yyResult = pFnMods(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Modifier> v$el$3 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$3;
      }
      { // Start scope for a2.
        List<Modifier> a2 = cast(yyOpValue1);

        yyResult = pGetterSetterMod(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Modifier a3 = yyResult.semanticValue();

          yyResult = pMdHeaderFront(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            FnHeaderFront a4 = yyResult.semanticValue();

            yyResult = pFnHeaderClause(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              FnHeaderClause a5 = yyResult.semanticValue();

              List<Modifier> mods = new ArrayList<Modifier>();
              if (a1 != null)
              mods.add(new ModifierAbstract(createSpan(yyStart,8)));
              if (a2 != null) mods.addAll(a2);
              mods.add(a3);
              yyValue = FortressUtil.mkAbsFnDecl(createSpan(yyStart,yyCount), mods,
              a4.getReceiver(), a4, a5);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      } // End scope for a2.
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.GetterSetterDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGetterSetterDef(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fGetterSetterDef) 
      yyColumn.chunk6.fGetterSetterDef = pGetterSetterDef$1(yyStart);
    return yyColumn.chunk6.fGetterSetterDef;
  }

  /** Actually parse Method.GetterSetterDef. */
  private Result pGetterSetterDef$1(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    List<Modifier>  yyOpValue1;
    FnAbsDeclOrDecl yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pFnMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<Modifier> a1 = yyOpValue1;

      yyResult = pGetterSetterMod(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Modifier a2 = yyResult.semanticValue();

        yyResult = pMdHeaderFront(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FnHeaderFront a3 = yyResult.semanticValue();

          yyResult = pFnHeaderClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            FnHeaderClause a4 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pequals(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pNoNewlineExpr(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Expr a5 = yyResult.semanticValue();

                    if (a1 == null) a1 = new ArrayList<Modifier>();
                    a1.add(a2);
                    yyValue = FortressUtil.mkFnDecl(createSpan(yyStart,yyCount), a1,
                    a3.getReceiver(), a3, a4, a5);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.GetterSetterMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGetterSetterMod(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fGetterSetterMod) 
      yyColumn.chunk6.fGetterSetterMod = pGetterSetterMod$1(yyStart);
    return yyColumn.chunk6.fGetterSetterMod;
  }

  /** Actually parse Method.GetterSetterMod. */
  private Result pGetterSetterMod$1(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pgetter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new ModifierGetter(createSpan(yyStart,yyCount));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = psetter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new ModifierSetter(createSpan(yyStart,yyCount));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.AbsGetterSetterDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsGetterSetterDecl(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    AbsFnDecl  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pabstract(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      String a1 = cast(yyOpValue1);

      yyOpValue1 = null;

      yyResult = pAbsFnMods(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Modifier> v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
      { // Start scope for a2.
        List<Modifier> a2 = cast(yyOpValue1);

        yyResult = pGetterSetterMod(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Modifier a3 = yyResult.semanticValue();

          yyResult = pMdHeaderFront(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            FnHeaderFront a4 = yyResult.semanticValue();

            yyResult = pFnHeaderClause(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              FnHeaderClause a5 = yyResult.semanticValue();

              List<Modifier> mods = new ArrayList<Modifier>();
              if (a1 != null)
              mods.add(new ModifierAbstract(createSpan(yyStart,8)));
              if (a2 != null) mods.addAll(a2);
              mods.add(a3);
              yyValue = FortressUtil.mkAbsFnDecl(createSpan(yyStart,yyCount), mods,
              a4.getReceiver(), a4, a5);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      } // End scope for a2.
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.Coercion.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCoercion(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fCoercion) 
      yyColumn.chunk6.fCoercion = pCoercion$1(yyStart);
    return yyColumn.chunk6.fCoercion;
  }

  /** Actually parse Method.Coercion. */
  private Result pCoercion$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Decl       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcoerce(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticParam> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<StaticParam> a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = popenparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pBindId(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Id a2 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pIsType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Type a3 = yyResult.semanticValue();

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pcloseparen(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pCoercionClauses(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          FnHeaderClause a4 = yyResult.semanticValue();

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyOption1  = yyResult.index;
                            yyOpValue1 = null;

                            yyResult = pwidens(yyOption1);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              String v$el$2 = yyResult.semanticValue();

                              yyResult = pw(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyOption1  = yyResult.index;
                                yyOpValue1 = v$el$2;
                              }
                            }
                            { // Start scope for a5.
                              String a5 = cast(yyOpValue1);

                              yyResult = pequals(yyOption1);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pw(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyResult = pNoNewlineExpr(yyResult.index);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {
                                    Expr a6 = yyResult.semanticValue();

                                    if (a1 == null) a1 = FortressUtil.emptyStaticParams();
                                    List<Param> params = FortressUtil.<Param, NormalParam>mkList(NodeFactory.makeParam(a2, a3));
                                    List<Modifier> mods = new ArrayList<Modifier>();
                                    if (a5 != null) mods.add(new ModifierWidens(createSpan(yyStart,8)));
                                    Span span = createSpan(yyStart+9,8);
                                    yyValue = FortressUtil.mkFnDecl(createSpan(yyStart,yyCount), mods,
                                    new Id(span,"coerce"),a1, params, a4, a6);

                                    return yyResult.createValue(yyValue, yyError);
                                  }
                                }
                              }
                            } // End scope for a5.
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.AbsCoercion.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsCoercion(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fAbsCoercion) 
      yyColumn.chunk6.fAbsCoercion = pAbsCoercion$1(yyStart);
    return yyColumn.chunk6.fAbsCoercion;
  }

  /** Actually parse Method.AbsCoercion. */
  private Result pAbsCoercion$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    AbsDecl    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcoerce(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParams(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticParam> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<StaticParam> a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = popenparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pBindId(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Id a2 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pIsType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Type a3 = yyResult.semanticValue();

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pcloseparen(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pCoercionClauses(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          FnHeaderClause a4 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = null;

                          yyResult = pw(yyOption1);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pwidens(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              String v$el$2 = yyResult.semanticValue();

                              yyOption1  = yyResult.index;
                              yyOpValue1 = v$el$2;
                            }
                          }
                          { // Start scope for a5.
                            String a5 = cast(yyOpValue1);

                            if (a1 == null) a1 = FortressUtil.emptyStaticParams();
                            List<Param> params = FortressUtil.<Param, NormalParam>mkList(NodeFactory.makeParam(a2, a3));
                            List<Modifier> mods = new ArrayList<Modifier>();
                            if (a5 != null) mods.add(new ModifierWidens(createSpan(yyStart,8)));
                            Span span = createSpan(yyStart+9,8);
                            yyValue = FortressUtil.mkAbsFnDecl(createSpan(yyStart,yyCount), mods,
                            new Id(span, "coerce"),
                            a1, params, a4);

                            return new SemanticValue(yyValue, yyOption1, yyError);
                          } // End scope for a5.
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.CoercionClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCoercionClauses(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fCoercionClauses) 
      yyColumn.chunk6.fCoercionClauses = pCoercionClauses$1(yyStart);
    return yyColumn.chunk6.fCoercionClauses;
  }

  /** Actually parse Method.CoercionClauses. */
  private Result pCoercionClauses$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    Object         yyOpValue1;
    FnHeaderClause yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pCoercionWhere(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        WhereClause v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      WhereClause a1 = cast(yyOpValue1);

      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pEnsures(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<EnsuresClause> v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a2.
        List<EnsuresClause> a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pInvariant(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Expr> v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
        }
        { // Start scope for a3.
          List<Expr> a3 = cast(yyOpValue1);

          if (a1 == null) a1 = FortressUtil.emptyWhereClause();
          Option<Contract> contractClause;
          if (a2 == null && a3 == null) contractClause = Option.<Contract>none();
          else contractClause = Option.<Contract>some(
          new Contract(createSpan(yyStart,yyCount),
          Option.<List<Expr>>none(),
          Option.wrap(a2),
          Option.wrap(a3)));
          yyValue = new FnHeaderClause(Option.<List<TraitType>>none(), a1,
          contractClause, Option.<Type>none());

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      } // End scope for a2.
    } // End scope for a1.
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.CoercionWhere.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCoercionWhere(final int yyStart) throws IOException {
    Result                yyResult;
    int                   yyOption1;
    List<WhereConstraint> yyOpValue1;
    WhereClause           yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pwhere(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = popendoublesquare(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pWhereBindingList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WhereBinding> a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pclosedoublesquare(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = popencurly(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = 
                          pCoercionWhereConstraintList(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          List<WhereConstraint> v$el$1 = yyResult.semanticValue();

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pclosecurly(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyOption1  = yyResult.index;
                              yyOpValue1 = v$el$1;
                            }
                          }
                        }
                      }
                    }
                  }
                  { // Start scope for a2.
                    List<WhereConstraint> a2 = yyOpValue1;

                    if (a2 == null)
                    yyValue = new WhereClause(a1, Collections.<WhereConstraint>emptyList());
                    else
                    yyValue = new WhereClause(a1, a2);

                    return new SemanticValue(yyValue, yyOption1, yyError);
                  } // End scope for a2.
                }
              }
            }
          }
        }

        // Nested alternative 2.

        yyResult = popencurly(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pCoercionWhereConstraintList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WhereConstraint> a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pclosecurly(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = new WhereClause(Collections.<WhereBinding>emptyList(), a1);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.CoercionWhereConstraintList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCoercionWhereConstraintList(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fCoercionWhereConstraintList) 
      yyColumn.chunk6.fCoercionWhereConstraintList = pCoercionWhereConstraintList$1(yyStart);
    return yyColumn.chunk6.fCoercionWhereConstraintList;
  }

  /** Actually parse Method.CoercionWhereConstraintList. */
  private Result pCoercionWhereConstraintList$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    List<WhereConstraint> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCoercionWhereConstraint(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WhereConstraint a1 = yyResult.semanticValue();

      yyResult = pCoercionWhereConstraintList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<WhereConstraint> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.CoercionWhereConstraintList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCoercionWhereConstraintList$$Star1(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fCoercionWhereConstraintList$$Star1) 
      yyColumn.chunk6.fCoercionWhereConstraintList$$Star1 = pCoercionWhereConstraintList$$Star1$1(yyStart);
    return yyColumn.chunk6.fCoercionWhereConstraintList$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.CoercionWhereConstraintList$$Star1. */
  private Result pCoercionWhereConstraintList$$Star1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<WhereConstraint> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pCoercionWhereConstraint(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            WhereConstraint v$el$1 = yyResult.semanticValue();

            yyResult = pCoercionWhereConstraintList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<WhereConstraint> v$2 = yyResult.semanticValue();

              yyValue = new Pair<WhereConstraint>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Method.CoercionWhereConstraint.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCoercionWhereConstraint(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fCoercionWhereConstraint) 
      yyColumn.chunk7.fCoercionWhereConstraint = pCoercionWhereConstraint$1(yyStart);
    return yyColumn.chunk7.fCoercionWhereConstraint;
  }

  /** Actually parse Method.CoercionWhereConstraint. */
  private Result pCoercionWhereConstraint$1(final int yyStart) 
    throws IOException {

    Result          yyResult;
    WhereConstraint yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWhereConstraint(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pType$Type(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pwidens(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = por(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcoerces(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pType$Type(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Type a2 = yyResult.semanticValue();

                      yyValue = new WhereWidensCoerces(createSpan(yyStart,yyCount), a1, a2);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.ValParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$ValParam(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fMethodParam$ValParam) 
      yyColumn.chunk7.fMethodParam$ValParam = pMethodParam$ValParam$1(yyStart);
    return yyColumn.chunk7.fMethodParam$ValParam;
  }

  /** Actually parse MethodParam.ValParam. */
  private Result pMethodParam$ValParam$1(final int yyStart) 
    throws IOException {

    Result      yyResult;
    int         yyOption1;
    List<Param> yyOpValue1;
    List<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMethodParam$Params(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<Param> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (a1 == null) yyValue = FortressUtil.emptyParams();
            else            yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.Params.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$Params(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fMethodParam$Params) 
      yyColumn.chunk7.fMethodParam$Params = pMethodParam$Params$1(yyStart);
    return yyColumn.chunk7.fMethodParam$Params;
  }

  /** Actually parse MethodParam.Params. */
  private Result pMethodParam$Params$1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    VarargsParam yyOpValue1;
    List<Param>  yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMethodParam$Params$$Star1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<NormalParam> a1s = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = p$$Shared29(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        VarargsParam v$el$3 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
          }
        }
      }
      { // Start scope for a2.
        VarargsParam a2 = yyOpValue1;

        yyResult = pMethodParam$Keyword(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Param a3 = yyResult.semanticValue();

          yyResult = pMethodParam$Params$$Star2(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<Param> a4s = yyResult.semanticValue();

            yyValue = FortressUtil.<Param, NormalParam>mkList(a1s.list());
            if (a2 != null) yyValue.add(a2);
            yyValue.add(a3);
            yyValue.addAll(a4s.list());

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.

      // Nested alternative 2.

      yyResult = p$$Shared29(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        VarargsParam a2 = yyResult.semanticValue();

        yyValue = FortressUtil.<Param, NormalParam>mkList(a1s.list(), a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pMethodParam$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NormalParam a1 = yyResult.semanticValue();

      yyResult = pMethodParam$Params$$Star3(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<NormalParam> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.<Param, NormalParam>mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal MethodParam.Params$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$Params$$Star1(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fMethodParam$Params$$Star1) 
      yyColumn.chunk7.fMethodParam$Params$$Star1 = pMethodParam$Params$$Star1$1(yyStart);
    return yyColumn.chunk7.fMethodParam$Params$$Star1;
  }

  /** Actually parse MethodParam.Params$$Star1. */
  private Result pMethodParam$Params$$Star1$1(final int yyStart) 
    throws IOException {

    Result            yyResult;
    Pair<NormalParam> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMethodParam$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NormalParam v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pMethodParam$Params$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<NormalParam> v$2 = yyResult.semanticValue();

              yyValue = new Pair<NormalParam>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal MethodParam.Params$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$Params$$Star2(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fMethodParam$Params$$Star2) 
      yyColumn.chunk7.fMethodParam$Params$$Star2 = pMethodParam$Params$$Star2$1(yyStart);
    return yyColumn.chunk7.fMethodParam$Params$$Star2;
  }

  /** Actually parse MethodParam.Params$$Star2. */
  private Result pMethodParam$Params$$Star2$1(final int yyStart) 
    throws IOException {

    Result      yyResult;
    Pair<Param> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pMethodParam$Keyword(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Param v$el$4 = yyResult.semanticValue();

            yyResult = pMethodParam$Params$$Star2(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Param> v$5 = yyResult.semanticValue();

              yyValue = new Pair<Param>(v$el$4, v$5);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal MethodParam.Params$$Star3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$Params$$Star3(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fMethodParam$Params$$Star3) 
      yyColumn.chunk7.fMethodParam$Params$$Star3 = pMethodParam$Params$$Star3$1(yyStart);
    return yyColumn.chunk7.fMethodParam$Params$$Star3;
  }

  /** Actually parse MethodParam.Params$$Star3. */
  private Result pMethodParam$Params$$Star3$1(final int yyStart) 
    throws IOException {

    Result            yyResult;
    Pair<NormalParam> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pMethodParam$Param(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            NormalParam v$el$6 = yyResult.semanticValue();

            yyResult = pMethodParam$Params$$Star3(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<NormalParam> v$7 = yyResult.semanticValue();

              yyValue = new Pair<NormalParam>(v$el$6, v$7);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.Keyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$Keyword(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fMethodParam$Keyword) 
      yyColumn.chunk7.fMethodParam$Keyword = pMethodParam$Keyword$1(yyStart);
    return yyColumn.chunk7.fMethodParam$Keyword;
  }

  /** Actually parse MethodParam.Keyword. */
  private Result pMethodParam$Keyword$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMethodParam$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NormalParam a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeParam(a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.Param.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$Param(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fMethodParam$Param) 
      yyColumn.chunk7.fMethodParam$Param = pMethodParam$Param$1(yyStart);
    return yyColumn.chunk7.fMethodParam$Param;
  }

  /** Actually parse MethodParam.Param. */
  private Result pMethodParam$Param$1(final int yyStart) throws IOException {
    Result      yyResult;
    NormalParam yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pself(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeParam(new Id(createSpan(yyStart,yyCount),
      "self"));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.OpHeaderFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMethodParam$OpHeaderFront(final int yyStart) 
    throws IOException {

    Result        yyResult;
    int           yyOption1;
    Object        yyOpValue1;
    FnHeaderFront yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBIG(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for big.
        String big = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared54(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Object opa1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticParams(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<StaticParam> v$el$4 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$4;
              }
            }
            { // Start scope for opa2.
              List<StaticParam> opa2 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pMethodParam$Params(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Param> opa3 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = p$$Shared55(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Op opa4 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pcolonequals(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = popenparen(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pw(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = 
                                  pSubscriptAssignParam(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {
                                  Param v$el$7 = yyResult.semanticValue();

                                  yyResult = pw(yyResult.index);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pcloseparen(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {

                                      yyOption1  = yyResult.index;
                                      yyOpValue1 = v$el$7;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      { // Start scope for opa5.
                        Param opa5 = cast(yyOpValue1);

                        SimpleName name;
                        Span span = createSpan(yyStart,yyCount);
                        Op leftOp = (Op)opa1;
                        String left  = leftOp.getText();
                        String right = opa4.getText();
                        if (PrecedenceMap.ONLY.matchedBrackets(left, right) ||
                        left.equals("{|->") && right.equals("}")) {
                          if (big != null) {
                            leftOp = NodeFactory.makeOpBig(leftOp.getSpan(), "BIG " + left);
                            opa4 = NodeFactory.makeOpBig(opa4.getSpan(), "BIG " + right);
                          }
                          name = new Enclosing(span, leftOp, opa4);
                        } else
                        name = error(leftOp, "Mismatched enclosing operator definition: "
                        + left + " and " + right);
                        if (opa2 == null) opa2 = FortressUtil.emptyStaticParams();
                        Option<Param> opparam = Option.wrap(opa5);
                        yyValue = new FnHeaderFront(name, opa2, opa3, opparam);

                        return new SemanticValue(yyValue, yyOption1, yyError);
                      } // End scope for opa5.
                    }
                  }
                }
              }
            } // End scope for opa2.
          }
        }
      } // End scope for big.

      // Nested alternative 2.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMethodParam$ValParam(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = p$$Shared56(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Op a2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pStaticParams(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<StaticParam> v$el$10 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$10;
                }
              }
              { // Start scope for a3.
                List<StaticParam> a3 = cast(yyOpValue1);

                Span span = createSpan(yyStart,yyCount);
                if (a3 == null)
                yyValue = new FnHeaderFront(NodeFactory.makeOpPostfix(a2), a1);
                else
                yyValue = new FnHeaderFront(NodeFactory.makeOpPostfix(a2), a3, a1);

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for a3.
            }
          }
        }
      }

      // Nested alternative 3.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBIG(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$11 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$11;
        }
      }
      { // Start scope for big.
        String big = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared57(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Object a1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticParams(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<StaticParam> v$el$14 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$14;
              }
            }
            { // Start scope for a2.
              List<StaticParam> a2 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pMethodParam$ValParam(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Param> a3 = yyResult.semanticValue();

                  Span span = createSpan(yyStart,yyCount);
                  Op op = (Op)a1;
                  if (big != null)
                  op = NodeFactory.makeOpBig(op.getSpan(), "BIG " + op.getText());
                  else if (op.getText().equals("BIG +") ||
                  op.getText().equals("BIG juxtaposition")) {
                    op = op;
                  } else if (a3.size() == 0) { // nofix
                    op = NodeFactory.makeOpNofix(op);
                  } else if (NodeUtil.isMultifix(a3)) { // multifix
                    op = NodeFactory.makeOpMultifix(op);
                  } else if (a3.size() == 1) { // prefix
                    op = NodeFactory.makeOpPrefix(op);
                  } else if (a3.size() == 2) { // infix
                    op = NodeFactory.makeOpInfix(op);
                  } else { // error
                    op = error(op, "Operator fix is invalid in its dclaration.");
                  }
                  if (a2 == null) yyValue = new FnHeaderFront(op, a3);
                  else            yyValue = new FnHeaderFront(op, a2, a3);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for a2.
          }
        }
      } // End scope for big.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MethodParam.SubscriptAssignParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSubscriptAssignParam(final int yyStart) throws IOException {
    Result     yyResult;
    Param      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared29(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMethodParam$Param(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Variable.VarDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariable$VarDecl(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    List<Modifier> yyOpValue1;
    VarDecl        yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pVariable$VarMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<Modifier> a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = p$$Shared30(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<LValueBind> a2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared6(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            com.sun.fortress.useful.Pair<Expr,Boolean> a3 = yyResult.semanticValue();

            if (a1 != null) {
              if (a3.getB()) a2 = FortressUtil.setModsAndMutable(a2, a1);
              else a2 = FortressUtil.setMods(a2, a1);
            } else {
              if (a3.getB()) a2 = FortressUtil.setMutable(a2);
            }
            yyValue = new VarDecl(createSpan(yyStart,yyCount), a2, a3.getA());

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pBindIdOrBindIdTuple(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Id> a2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice2 = yyResult.index;

          // Nested alternative 1.

          yyResult = pequals(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineExpr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr a3 = yyResult.semanticValue();

                List<LValueBind> lvs;
                if (a1 != null) lvs = FortressUtil.ids2Lvs(a2, a1);
                else lvs = FortressUtil.ids2Lvs(a2);
                yyValue = new VarDecl(createSpan(yyStart,yyCount), lvs, a3);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 2.

          yyResult = pSymbol$colon(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              final int yyChoice3 = yyResult.index;

              // Nested alternative 1.

              yyResult = pType$Type(yyChoice3);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Type a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pellipses(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = p$$Shared6(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        com.sun.fortress.useful.Pair<Expr,Boolean> a4 = yyResult.semanticValue();

                        List<LValueBind> lvs;
                        if (a1 != null) {
                          if (a4.getB()) lvs = FortressUtil.ids2Lvs(a2, a1, a3, true);
                          else           lvs = FortressUtil.ids2Lvs(a2, a1, a3, false);
                        } else {
                          if (a4.getB()) lvs = FortressUtil.ids2Lvs(a2, a3, true);
                          else           lvs = FortressUtil.ids2Lvs(a2, a3, false);
                        }
                        yyValue = new VarDecl(createSpan(yyStart,yyCount), lvs, a4.getA());

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              }

              // Nested alternative 2.

              yyResult = pType$TupleType(yyChoice3);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TupleType a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = p$$Shared6(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    com.sun.fortress.useful.Pair<Expr,Boolean> a4 = yyResult.semanticValue();

                    Span span = createSpan(yyStart,yyCount);
                    List<Type> tys = a3.getElements();
                    if (a2.size() != tys.size())
                    error(new Id(span,"_"), "Mismatched numbers of variables and types.");
                    List<LValueBind> lvs;
                    if (a1 != null) {
                      if (a4.getB()) lvs = FortressUtil.ids2Lvs(a2, a1, tys, true);
                      else           lvs = FortressUtil.ids2Lvs(a2, a1, tys, false);
                    } else {
                      if (a4.getB()) lvs = FortressUtil.ids2Lvs(a2, tys, true);
                      else           lvs = FortressUtil.ids2Lvs(a2, tys, false);
                    }
                    yyValue = new VarDecl(span, lvs, a4.getA());

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Variable.VarMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariable$VarMods(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyRepetition1;
    boolean        yyRepeated1;
    Pair<Modifier> yyRepValue1;
    List<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pVariable$VarMod(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Modifier v$el$1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Modifier>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Modifier> a1s = yyRepValue1.reverse();

      yyValue = FortressUtil.mkList(a1s.list());
      FortressUtil.noDuplicate(yyValue);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Variable.VarMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariable$VarMod(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared7(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pprivate(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = new ModifierPrivate(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared30.
   * This nonterminal represents the duplicate productions Variable.VarWTypes 
   * and Field.VarWTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared30(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.f$$Shared30) 
      yyColumn.chunk7.f$$Shared30 = p$$Shared30$1(yyStart);
    return yyColumn.chunk7.f$$Shared30;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared30. */
  private Result p$$Shared30$1(final int yyStart) throws IOException {
    Result           yyResult;
    List<LValueBind> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared5(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LValueBind a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared5(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          LValueBind a1 = yyResult.semanticValue();

          yyResult = p$$Shared30$$Plus1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<LValueBind> a2s = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = FortressUtil.mkList(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.$$Shared30$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared30$$Plus1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.f$$Shared30$$Plus1) 
      yyColumn.chunk7.f$$Shared30$$Plus1 = p$$Shared30$$Plus1$1(yyStart);
    return yyColumn.chunk7.f$$Shared30$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared30$$Plus1. */
  private Result p$$Shared30$$Plus1$1(final int yyStart) throws IOException {
    Result           yyResult;
    Pair<LValueBind> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared5(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            LValueBind v$el$1 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = p$$Shared30$$Plus1(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<LValueBind> v$2 = yyResult.semanticValue();

              yyValue = new Pair<LValueBind>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyValue = new Pair<LValueBind>(v$el$1);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared5.
   * This nonterminal represents the duplicate productions Variable.VarWType 
   * and Field.VarWType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared5(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.f$$Shared5) 
      yyColumn.chunk8.f$$Shared5 = p$$Shared5$1(yyStart);
    return yyColumn.chunk8.f$$Shared5;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared5. */
  private Result p$$Shared5$1(final int yyStart) throws IOException {
    Result     yyResult;
    LValueBind yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIsType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a2 = yyResult.semanticValue();

          yyValue = FortressUtil.mkLValueBind(createSpan(yyStart,yyCount),a1,a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared6.
   * This nonterminal represents the duplicate productions Variable.InitVal, 
   * Field.InitVal, and LocalDecl.InitVal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared6(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.f$$Shared6) 
      yyColumn.chunk8.f$$Shared6 = p$$Shared6$1(yyStart);
    return yyColumn.chunk8.f$$Shared6;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared6. */
  private Result p$$Shared6$1(final int yyStart) throws IOException {
    Result                                     yyResult;
    com.sun.fortress.useful.Pair<Expr,Boolean> yyValue;
    ParseError                                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared6$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a2 = yyResult.semanticValue();

          yyValue = new com.sun.fortress.useful.Pair<Expr,Boolean>(a2,
          a1.equals(":="));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.$$Shared6$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared6$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pequals(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pcolonequals(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared40.
   * This nonterminal represents the duplicate productions 
   * Variable.AbsVarDecl and AbsField.AbsVarDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared40(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.f$$Shared40) 
      yyColumn.chunk8.f$$Shared40 = p$$Shared40$1(yyStart);
    return yyColumn.chunk8.f$$Shared40;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared40. */
  private Result p$$Shared40$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    List<Modifier> yyOpValue1;
    AbsVarDecl     yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = p$$Shared31(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<Modifier> a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = pNoNewlineVarWTypes(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<LValueBind> a2 = yyResult.semanticValue();

        if (a1 != null) a2 = FortressUtil.setMods(a2, a1);
        yyValue = new AbsVarDecl(createSpan(yyStart,yyCount), a2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pBindIdOrBindIdTuple(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Id> a2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pSymbol$colon(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              final int yyChoice2 = yyResult.index;

              // Nested alternative 1.

              yyResult = pType$Type(yyChoice2);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Type a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pellipses(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    List<LValueBind> lvs;
                    if (a1 != null) lvs = FortressUtil.ids2Lvs(a2, a1, a3, false);
                    else            lvs = FortressUtil.ids2Lvs(a2, a3, false);
                    yyValue = new AbsVarDecl(createSpan(yyStart,yyCount), lvs);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }

              // Nested alternative 2.

              yyResult = pType$TupleType(yyChoice2);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TupleType a3 = yyResult.semanticValue();

                Span span = createSpan(yyStart,yyCount);
                List<Type> tys = a3.getElements();
                if (a2.size() != tys.size())
                error(new Id(span,"_"), "Mismatched numbers of variables and types.");
                List<LValueBind> lvs;
                if (a1 != null) lvs = FortressUtil.ids2Lvs(a2, a1, tys, false);
                else            lvs = FortressUtil.ids2Lvs(a2, tys, false);
                yyValue = new AbsVarDecl(span, lvs);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared31.
   * This nonterminal represents the duplicate productions 
   * Variable.AbsVarMods and AbsField.AbsVarMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared31(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyRepetition1;
    boolean        yyRepeated1;
    Pair<Modifier> yyRepValue1;
    List<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = p$$Shared7(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Modifier v$el$1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Modifier>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Modifier> a1s = yyRepValue1.reverse();

      yyValue = FortressUtil.mkList(a1s.list());
      FortressUtil.noDuplicate(yyValue);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared7.
   * This nonterminal represents the duplicate productions Variable.AbsVarMod 
   * and AbsField.AbsVarMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared7(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.f$$Shared7) 
      yyColumn.chunk8.f$$Shared7 = p$$Shared7$1(yyStart);
    return yyColumn.chunk8.f$$Shared7;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared7. */
  private Result p$$Shared7$1(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pvar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = new ModifierVar(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ptest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = new ModifierTest(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Field.VarDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pField$VarDecl(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    List<Modifier> yyOpValue1;
    VarDecl        yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pFldMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<Modifier> a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = p$$Shared30(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<LValueBind> a2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared6(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            com.sun.fortress.useful.Pair<Expr,Boolean> a3 = yyResult.semanticValue();

            if (a1 != null) {
              if (a3.getB()) a2 = FortressUtil.setModsAndMutable(a2, a1);
              else a2 = FortressUtil.setMods(a2, a1);
            } else {
              if (a3.getB()) a2 = FortressUtil.setMutable(a2);
            }
            yyValue = new VarDecl(createSpan(yyStart,yyCount), a2, a3.getA());

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pBindIdOrBindIdTuple(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Id> a2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice2 = yyResult.index;

          // Nested alternative 1.

          yyResult = pequals(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineExpr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr a3 = yyResult.semanticValue();

                List<LValueBind> lvs;
                if (a1 != null) lvs = FortressUtil.ids2Lvs(a2, a1);
                else lvs = FortressUtil.ids2Lvs(a2);
                yyValue = new VarDecl(createSpan(yyStart,yyCount), lvs, a3);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 2.

          yyResult = pSymbol$colon(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              final int yyChoice3 = yyResult.index;

              // Nested alternative 1.

              yyResult = pType$Type(yyChoice3);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Type a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pellipses(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = p$$Shared6(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        com.sun.fortress.useful.Pair<Expr,Boolean> a4 = yyResult.semanticValue();

                        List<LValueBind> lvs;
                        if (a1 != null) {
                          if (a4.getB()) lvs = FortressUtil.ids2Lvs(a2, a1, a3, true);
                          else           lvs = FortressUtil.ids2Lvs(a2, a1, a3, false);
                        } else {
                          if (a4.getB()) lvs = FortressUtil.ids2Lvs(a2, a3, true);
                          else           lvs = FortressUtil.ids2Lvs(a2, a3, false);
                        }
                        yyValue = new VarDecl(createSpan(yyStart,yyCount), lvs, a4.getA());

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              }

              // Nested alternative 2.

              yyResult = pType$TupleType(yyChoice3);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TupleType a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = p$$Shared6(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    com.sun.fortress.useful.Pair<Expr,Boolean> a4 = yyResult.semanticValue();

                    Span span = createSpan(yyStart,yyCount);
                    List<Type> tys = a3.getElements();
                    if (a2.size() != tys.size())
                    error(new Id(span,"_"), "Mismatched numbers of variables and types.");
                    List<LValueBind> lvs;
                    if (a1 != null) {
                      if (a4.getB()) lvs = FortressUtil.ids2Lvs(a2, a1, tys, true);
                      else           lvs = FortressUtil.ids2Lvs(a2, a1, tys, false);
                    } else {
                      if (a4.getB()) lvs = FortressUtil.ids2Lvs(a2, tys, true);
                      else           lvs = FortressUtil.ids2Lvs(a2, tys, false);
                    }
                    yyValue = new VarDecl(span, lvs, a4.getA());

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal AbsField.ApiFldDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pApiFldDecl(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    List<Modifier> yyOpValue1;
    AbsVarDecl     yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pApiFldMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<Modifier> a1 = yyOpValue1;

      yyResult = pBindId(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id a2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineIsType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Type a3 = yyResult.semanticValue();

            LValueBind lhs;
            if (a1 == null)
            lhs = (LValueBind)FortressUtil.mkLValueBind(a2, a3);
            else lhs = (LValueBind)FortressUtil.mkLValueBind(a2, a3, a1);
            yyValue = new AbsVarDecl(createSpan(yyStart,yyCount),
            FortressUtil.mkList(lhs));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.IsType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIsType(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fIsType) 
      yyColumn.chunk8.fIsType = pIsType$1(yyStart);
    return yyColumn.chunk8.fIsType;
  }

  /** Actually parse MayNewlineHeader.IsType. */
  private Result pIsType$1(final int yyStart) throws IOException {
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol$colon(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType$Type(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.WhereConstraintList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhereConstraintList(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fWhereConstraintList) 
      yyColumn.chunk8.fWhereConstraintList = pWhereConstraintList$1(yyStart);
    return yyColumn.chunk8.fWhereConstraintList;
  }

  /** Actually parse MayNewlineHeader.WhereConstraintList. */
  private Result pWhereConstraintList$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    List<WhereConstraint> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWhereConstraint(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WhereConstraint a1 = yyResult.semanticValue();

      yyResult = pWhereConstraintList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<WhereConstraint> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.WhereConstraintList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhereConstraintList$$Star1(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fWhereConstraintList$$Star1) 
      yyColumn.chunk8.fWhereConstraintList$$Star1 = pWhereConstraintList$$Star1$1(yyStart);
    return yyColumn.chunk8.fWhereConstraintList$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.WhereConstraintList$$Star1. */
  private Result pWhereConstraintList$$Star1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<WhereConstraint> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pWhereConstraint(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            WhereConstraint v$el$1 = yyResult.semanticValue();

            yyResult = pWhereConstraintList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<WhereConstraint> v$2 = yyResult.semanticValue();

              yyValue = new Pair<WhereConstraint>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.WhereConstraint.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhereConstraint(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fWhereConstraint) 
      yyColumn.chunk8.fWhereConstraint = pWhereConstraint$1(yyStart);
    return yyColumn.chunk8.fWhereConstraint;
  }

  /** Actually parse MayNewlineHeader.WhereConstraint. */
  private Result pWhereConstraint$1(final int yyStart) throws IOException {
    Result          yyResult;
    WhereConstraint yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineHeader$Extends(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<TraitType> a2 = yyResult.semanticValue();

          yyValue = new WhereExtends(createSpan(yyStart,yyCount), a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pTypeAlias(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pType$Type(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pcoerces(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType$Type(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyValue = new WhereCoerces(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = pwidens(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType$Type(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyValue = new WhereWidens(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pUnitConstraint(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pQualifiedName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              QualifiedIdName a2 = yyResult.semanticValue();

              yyValue = new WhereEquals(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 6.

    yyResult = pIntConstraint(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pBoolConstraint(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BoolConstraint a1 = yyResult.semanticValue();

      yyValue = new BoolConstraintExpr(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.UnitConstraint.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnitConstraint(final int yyStart) throws IOException {
    int            yyC;
    int            yyIndex;
    Result         yyResult;
    int            yyBase;
    UnitConstraint yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('o' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('n' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('l' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('e' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('s' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('s' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyResult = pw(yyIndex);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pequals(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyResult = pw(yyResult.index);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pId(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Id a1 = yyResult.semanticValue();

                                      yyValue = new UnitConstraint(createSpan(yyStart,yyCount), a1);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if ('d' == yyC) {
              yyIndex = yyResult.index + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('m' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('n' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('s' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('i' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('o' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('n' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyC = character(yyIndex);
                              if ('l' == yyC) {
                                yyIndex = yyIndex + 1;

                                yyC = character(yyIndex);
                                if ('e' == yyC) {
                                  yyIndex = yyIndex + 1;

                                  yyC = character(yyIndex);
                                  if ('s' == yyC) {
                                    yyIndex = yyIndex + 1;

                                    yyC = character(yyIndex);
                                    if ('s' == yyC) {
                                      yyIndex = yyIndex + 1;

                                      yyValue = new UnitConstraint(createSpan(yyStart,yyCount), a1);

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("\"dimensionless\" expected", yyBase);
                                    }
                                  } else {
                                    yyError = yyError.select("\"dimensionless\" expected", yyBase);
                                  }
                                } else {
                                  yyError = yyError.select("\"dimensionless\" expected", yyBase);
                                }
                              } else {
                                yyError = yyError.select("\"dimensionless\" expected", yyBase);
                              }
                            } else {
                              yyError = yyError.select("\"dimensionless\" expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("\"dimensionless\" expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("\"dimensionless\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"dimensionless\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"dimensionless\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"dimensionless\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"dimensionless\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"dimensionless\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"dimensionless\" expected", yyBase);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("unit constraint expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.IntConstraint.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntConstraint(final int yyStart) throws IOException {
    Result        yyResult;
    IntConstraint yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IntExpr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = plessthanequal(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIntExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              IntExpr a2 = yyResult.semanticValue();

              yyValue = new LEConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = plessthan(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIntExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              IntExpr a2 = yyResult.semanticValue();

              yyValue = new LTConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 3.

        yyResult = pgreaterthanequal(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIntExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              IntExpr a2 = yyResult.semanticValue();

              yyValue = new GEConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 4.

        yyResult = pgreaterthan(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIntExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              IntExpr a2 = yyResult.semanticValue();

              yyValue = new GTConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 5.

        yyResult = pequals(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIntExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              IntExpr a2 = yyResult.semanticValue();

              yyValue = new IEConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.IntVal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntVal(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fIntVal) 
      yyColumn.chunk8.fIntVal = pIntVal$1(yyStart);
    return yyColumn.chunk8.fIntVal;
  }

  /** Actually parse MayNewlineHeader.IntVal. */
  private Result pIntVal$1(final int yyStart) throws IOException {
    Result     yyResult;
    IntVal     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IntLiteralExpr a1 = yyResult.semanticValue();

      yyValue = new NumberConstraint(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyValue = new IntRef(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.IntExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntExpr(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fIntExpr) 
      yyColumn.chunk8.fIntExpr = pIntExpr$1(yyStart);
    return yyColumn.chunk8.fIntExpr;
  }

  /** Actually parse MayNewlineHeader.IntExpr. */
  private Result pIntExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    IntExpr    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IntExpr seed = yyResult.semanticValue();

      yyResult = pIntExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<IntExpr>> list = yyResult.semanticValue();

        yyValue = (IntExpr)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.IntExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntExpr$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fIntExpr$$Star1) 
      yyColumn.chunk9.fIntExpr$$Star1 = pIntExpr$$Star1$1(yyStart);
    return yyColumn.chunk9.fIntExpr$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.IntExpr$$Star1. */
  private Result pIntExpr$$Star1$1(final int yyStart) throws IOException {
    Result                yyResult;
    Pair<Action<IntExpr>> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<IntExpr> v$el$1 = yyResult.semanticValue();

      yyResult = pIntExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<IntExpr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<IntExpr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.IntExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntExprFront(final int yyStart) throws IOException {
    Result     yyResult;
    IntExpr    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntVal(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIntExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          IntExpr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.IntExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntExprTail(final int yyStart) throws IOException {
    Result          yyResult;
    Action<IntExpr> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pSymbol$plus(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pIntExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final IntExpr a1 = yyResult.semanticValue();

            yyValue = new Action<IntExpr>() {
              public IntExpr run(IntExpr base) {
                return new SumConstraint(createSpan(yyStart,yyCount),
                (IntExpr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pminus(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pIntExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final IntExpr a1 = yyResult.semanticValue();

            yyValue = new Action<IntExpr>() {
              public IntExpr run(IntExpr base) {
                return new MinusConstraint(createSpan(yyStart,yyCount),
                (IntExpr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pProductIntExpr$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pIntExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final IntExpr a1 = yyResult.semanticValue();

        yyValue = new Action<IntExpr>() {
          public IntExpr run(IntExpr base) {
            return new ProductConstraint(createSpan(yyStart,yyCount),
            (IntExpr)base, a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pIntVal(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final IntVal a1 = yyResult.semanticValue();

        yyValue = new Action<IntExpr>() {
          public IntExpr run(IntExpr base) {
            if (NodeUtil.isExponentiation((IntExpr)base))
            return error((IntExpr)base, "It is a static error if an " +
            "exponentiation is immediately followed by " +
            "an exponentiation.");
            return new ExponentConstraint(createSpan(yyStart,yyCount),
            (IntExpr)base, a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.ProductIntExpr$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProductIntExpr$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pDOT(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyResult = pSpacing$Space(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        continue;
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.BoolConstraint.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolConstraint(final int yyStart) throws IOException {
    Result                       yyResult;
    int                          yyRepetition1;
    Pair<Action<BoolConstraint>> yyRepValue1;
    BoolConstraint               yyValue;
    ParseError                   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBoolConstraintFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BoolConstraint seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBoolConstraintTail(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Action<BoolConstraint> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<Action<BoolConstraint>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for list.
        Pair<Action<BoolConstraint>> list = yyRepValue1.reverse();

        yyValue = (BoolConstraint)apply(list, seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for list.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.BoolConstraintFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolConstraintFront(final int yyStart) throws IOException {
    Result         yyResult;
    BoolConstraint yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNOT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBoolExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          BoolExpr a1 = yyResult.semanticValue();

          yyValue = new NotConstraint(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pBoolConstraintHead(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BoolExpr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pOR(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBoolExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              BoolExpr a2 = yyResult.semanticValue();

              yyValue = new OrConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = pAND(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBoolExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              BoolExpr a2 = yyResult.semanticValue();

              yyValue = new AndConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 3.

        yyResult = pIMPLIES(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBoolExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              BoolExpr a2 = yyResult.semanticValue();

              yyValue = new ImpliesConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 4.

        yyResult = pequals(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBoolExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              BoolExpr a2 = yyResult.semanticValue();

              yyValue = new BEConstraint(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.BoolConstraintHead.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolConstraintHead(final int yyStart) throws IOException {
    Result     yyResult;
    BoolExpr   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBoolVal(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBoolExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          BoolExpr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.BoolConstraintTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolConstraintTail(final int yyStart) throws IOException {
    Result                 yyResult;
    Action<BoolConstraint> yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pOR(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBoolExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final BoolExpr a1 = yyResult.semanticValue();

            yyValue = new Action<BoolConstraint>() {
              public BoolConstraint run(BoolConstraint base) {
                return new OrConstraint(createSpan(yyStart,yyCount),
                (BoolConstraint)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pAND(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBoolExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final BoolExpr a1 = yyResult.semanticValue();

            yyValue = new Action<BoolConstraint>() {
              public BoolConstraint run(BoolConstraint base) {
                return new AndConstraint(createSpan(yyStart,yyCount),
                (BoolConstraint)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 3.

      yyResult = pIMPLIES(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBoolExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final BoolExpr a1 = yyResult.semanticValue();

            yyValue = new Action<BoolConstraint>() {
              public BoolConstraint run(BoolConstraint base) {
                return new ImpliesConstraint(createSpan(yyStart,yyCount),
                (BoolConstraint)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 4.

      yyResult = pequals(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBoolExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final BoolExpr a1 = yyResult.semanticValue();

            yyValue = new Action<BoolConstraint>() {
              public BoolConstraint run(BoolConstraint base) {
                return new BEConstraint(createSpan(yyStart,yyCount),
                (BoolConstraint)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.BoolVal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolVal(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fBoolVal) 
      yyColumn.chunk9.fBoolVal = pBoolVal$1(yyStart);
    return yyColumn.chunk9.fBoolVal;
  }

  /** Actually parse MayNewlineHeader.BoolVal. */
  private Result pBoolVal$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    BoolVal    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;
            String a1 = "true";

            yyValue = new BoolConstant(createSpan(yyStart,yyCount), true);

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;
              String a1 = "false";

              yyValue = new BoolConstant(createSpan(yyStart,yyCount), false);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
      }
    }

    // Alternative 3.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyValue = new BoolRef(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("bool val expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.BoolExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolExpr(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fBoolExpr) 
      yyColumn.chunk9.fBoolExpr = pBoolExpr$1(yyStart);
    return yyColumn.chunk9.fBoolExpr;
  }

  /** Actually parse MayNewlineHeader.BoolExpr. */
  private Result pBoolExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    BoolExpr   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBoolExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      BoolExpr seed = yyResult.semanticValue();

      yyResult = pBoolExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<BoolExpr>> list = yyResult.semanticValue();

        yyValue = (BoolExpr)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.BoolExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolExpr$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fBoolExpr$$Star1) 
      yyColumn.chunk9.fBoolExpr$$Star1 = pBoolExpr$$Star1$1(yyStart);
    return yyColumn.chunk9.fBoolExpr$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.BoolExpr$$Star1. */
  private Result pBoolExpr$$Star1$1(final int yyStart) throws IOException {
    Result                 yyResult;
    Pair<Action<BoolExpr>> yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBoolExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<BoolExpr> v$el$1 = yyResult.semanticValue();

      yyResult = pBoolExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<BoolExpr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<BoolExpr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.BoolExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolExprFront(final int yyStart) throws IOException {
    Result     yyResult;
    BoolExpr   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBoolVal(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBoolExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          BoolExpr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 3.

    yyResult = pNOT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBoolExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          BoolExpr a1 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = new NotConstraint(span, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.BoolExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBoolExprTail(final int yyStart) throws IOException {
    Result           yyResult;
    Action<BoolExpr> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pOR(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBoolExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final BoolExpr a1 = yyResult.semanticValue();

            yyValue = new Action<BoolExpr>() {
              public BoolExpr run(BoolExpr base) {
                Span span = createSpan(yyStart,yyCount);
                return new OrConstraint(span, (BoolExpr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pAND(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBoolExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final BoolExpr a1 = yyResult.semanticValue();

            yyValue = new Action<BoolExpr>() {
              public BoolExpr run(BoolExpr base) {
                Span span = createSpan(yyStart,yyCount);
                return new AndConstraint(span, (BoolExpr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 3.

      yyResult = pIMPLIES(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBoolExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final BoolExpr a1 = yyResult.semanticValue();

            yyValue = new Action<BoolExpr>() {
              public BoolExpr run(BoolExpr base) {
                Span span = createSpan(yyStart,yyCount);
                return new ImpliesConstraint(span, (BoolExpr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 4.

      yyResult = pequals(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBoolExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final BoolExpr a1 = yyResult.semanticValue();

            yyValue = new Action<BoolExpr>() {
              public BoolExpr run(BoolExpr base) {
                Span span = createSpan(yyStart,yyCount);
                return new BEConstraint(span, (BoolExpr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.Contract.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pContract(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Contract   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pRequires(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Expr> v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      List<Expr> a1 = cast(yyOpValue1);

      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pEnsures(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<EnsuresClause> v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a2.
        List<EnsuresClause> a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pInvariant(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Expr> v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
        }
        { // Start scope for a3.
          List<Expr> a3 = cast(yyOpValue1);

          Option<List<Expr>> requires = Option.wrap(a1);
          Option<List<EnsuresClause>> ensures = Option.wrap(a2);
          Option<List<Expr>> invariant = Option.wrap(a3);
          if (a1 == null && a2 == null && a3 == null) yyValue = null;
          else yyValue = new Contract(createSpan(yyStart,yyCount), requires,
          ensures, invariant);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      } // End scope for a2.
    } // End scope for a1.
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.Requires.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRequires(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Expr> yyOpValue1;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = prequires(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popencurly(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExprList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Expr> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a1.
            List<Expr> a1 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                if (a1 == null) yyValue = FortressUtil.emptyExprs();
                else            yyValue = a1;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a1.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.Ensures.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnsures(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fEnsures) 
      yyColumn.chunk9.fEnsures = pEnsures$1(yyStart);
    return yyColumn.chunk9.fEnsures;
  }

  /** Actually parse MayNewlineHeader.Ensures. */
  private Result pEnsures$1(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyOption1;
    List<EnsuresClause> yyOpValue1;
    List<EnsuresClause> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pensures(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popencurly(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pEnsuresClauseList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<EnsuresClause> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a1.
            List<EnsuresClause> a1 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                if (a1 == null) yyValue = FortressUtil.emptyEnsuresClauses();
                else            yyValue = a1;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a1.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.EnsuresClauseList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnsuresClauseList(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyRepetition1;
    Pair<EnsuresClause> yyRepValue1;
    List<EnsuresClause> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEnsuresClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      EnsuresClause a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pEnsuresClause(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                EnsuresClause v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<EnsuresClause>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<EnsuresClause> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.EnsuresClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnsuresClause(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fEnsuresClause) 
      yyColumn.chunk9.fEnsuresClause = pEnsuresClause$1(yyStart);
    return yyColumn.chunk9.fEnsuresClause;
  }

  /** Actually parse MayNewlineHeader.EnsuresClause. */
  private Result pEnsuresClause$1(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyOption1;
    Expr          yyOpValue1;
    EnsuresClause yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pprovided(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        Expr a2 = yyOpValue1;

        Option<Expr> ensures = Option.wrap(a2);
        yyValue = new EnsuresClause(createSpan(yyStart,yyCount), a1, ensures);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.Invariant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInvariant(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fInvariant) 
      yyColumn.chunk9.fInvariant = pInvariant$1(yyStart);
    return yyColumn.chunk9.fInvariant;
  }

  /** Actually parse MayNewlineHeader.Invariant. */
  private Result pInvariant$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Expr> yyOpValue1;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pinvariant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popencurly(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExprList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Expr> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a1.
            List<Expr> a1 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                if (a1 == null) yyValue = FortressUtil.emptyExprs();
                else            yyValue = a1;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a1.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.StaticArgs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArgs(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fStaticArgs) 
      yyColumn.chunk9.fStaticArgs = pStaticArgs$1(yyStart);
    return yyColumn.chunk9.fStaticArgs;
  }

  /** Actually parse MayNewlineHeader.StaticArgs. */
  private Result pStaticArgs$1(final int yyStart) throws IOException {
    Result          yyResult;
    List<StaticArg> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popendoublesquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArgList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosedoublesquare(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.StaticArgList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArgList(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyRepetition1;
    Pair<StaticArg> yyRepValue1;
    List<StaticArg> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStaticArg(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StaticArg a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticArg(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                StaticArg v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<StaticArg>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<StaticArg> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal MayNewlineHeader.StaticArg.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArg(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fStaticArg) 
      yyColumn.chunk9.fStaticArg = pStaticArg$1(yyStart);
    return yyColumn.chunk9.fStaticArg;
  }

  /** Actually parse MayNewlineHeader.StaticArg. */
  private Result pStaticArg$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    StaticArg  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyValue = new OprArg(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('U' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('y' == yyC) {
              yyIndex = yyIndex + 1;

              Span span = createSpan(yyStart,yyCount);
              yyValue = new DimArg(span, new BaseDim(span));

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('o' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('n' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('l' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('e' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('s' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('s' == yyC) {
                              yyIndex = yyIndex + 1;
                              String a1 = "dimensionless";

                              Span span = createSpan(yyStart,yyCount);
                              yyValue = new UnitArg(span, ExprFactory.makeVarRef(new Id(span, a1)));

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pone(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pslash(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType$Type(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a1 = yyResult.semanticValue();

              Span span = createSpan(yyStart,1);
              DimExpr base = new BaseDim(createSpan(yyStart,1));
              try {
                yyValue = new DimArg(span, new QuotientDim(span, base,
                TypeResolver.typeToDim(a1)));
              } catch (TypeConvertFailure e) {
                yyValue = error(a1, "A dimension is expected but a type is found.");
              }

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 5.

    yyResult = p$$Shared15(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pSpacing$sr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType$Type(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          try {
            yyValue = new DimArg(span,
            new OpDim(span,TypeResolver.typeToDim(a2),a1));
          } catch (TypeConvertFailure e) {
            yyValue = error(a2, "A dimension is expected but a type is found.");
          }

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 6.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticArg(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          StaticArg a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 7.

    yyPredMatched = false;

    yyPredResult = pStaticArg$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pIntExpr(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        IntExpr a1 = yyResult.semanticValue();

        yyValue = new IntArg(createSpan(yyStart,yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("static arg expected", yyStart);
    }

    // Alternative 8.

    yyPredMatched = false;

    yyPredResult = pStaticArg$$Choice2(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pBoolExpr(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        BoolExpr a1 = yyResult.semanticValue();

        yyValue = new BoolArg(createSpan(yyStart,yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("static arg expected", yyStart);
    }

    // Alternative 9.

    yyPredMatched = false;

    yyPredResult = pStaticArg$$Choice3(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pType$Type(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Type a1 = yyResult.semanticValue();

        yyValue = new TypeArg(createSpan(yyStart,yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("static arg expected", yyStart);
    }

    // Alternative 10.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyValue = new UnitArg(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("static arg expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.StaticArg$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArg$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pclosedoublesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pclosesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pcomma(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 4.

        yyResult = popendoublesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 5.

        yyResult = popensquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 6.

        yyResult = prightarrow(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 7.

        yyBase   = yyChoice2;
        yyResult = pop(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue("OR")) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("\"OR\" expected", yyBase);
        }

        // Nested alternative 8.

        yyBase   = yyChoice2;
        yyResult = pop(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue("AND")) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("\"AND\" expected", yyBase);
        }

        // Nested alternative 9.

        yyBase   = yyChoice2;
        yyResult = pop(yyBase);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue("IMPLIES")) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("\"IMPLIES\" expected", yyBase);
        }

        // Nested alternative 10.

        yyResult = pequals(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.StaticArg$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArg$$Choice2(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pclosedoublesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pclosesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pcomma(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 4.

        yyResult = popendoublesquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 5.

        yyResult = popensquare(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 6.

        yyResult = prightarrow(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.StaticArg$$Choice3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticArg$$Choice3(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pDOT(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pslash(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pper(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 4.

        yyResult = p$$Shared16(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.ExtendsWhere.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExtendsWhere(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fExtendsWhere) 
      yyColumn.chunk9.fExtendsWhere = pExtendsWhere$1(yyStart);
    return yyColumn.chunk9.fExtendsWhere;
  }

  /** Actually parse NoNewlineHeader.ExtendsWhere. */
  private Result pExtendsWhere$1(final int yyStart) throws IOException {
    Result               yyResult;
    List<TraitTypeWhere> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pextends(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitTypeWheres(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.TraitTypeWheres.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitTypeWheres(final int yyStart) throws IOException {
    Result               yyResult;
    List<TraitTypeWhere> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitTypeWhere(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitTypeWhere a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitTypeWhereList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.TraitTypeWhereList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitTypeWhereList(final int yyStart) throws IOException {
    Result               yyResult;
    int                  yyRepetition1;
    Pair<TraitTypeWhere> yyRepValue1;
    List<TraitTypeWhere> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitTypeWhere(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitTypeWhere a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pTraitTypeWhere(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TraitTypeWhere v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<TraitTypeWhere>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<TraitTypeWhere> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.TraitTypeWhere.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitTypeWhere(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fTraitTypeWhere) 
      yyColumn.chunk10.fTraitTypeWhere = pTraitTypeWhere$1(yyStart);
    return yyColumn.chunk10.fTraitTypeWhere;
  }

  /** Actually parse NoNewlineHeader.TraitTypeWhere. */
  private Result pTraitTypeWhere$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    WhereClause    yyOpValue1;
    TraitTypeWhere yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TraitType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitType a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pWhere(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WhereClause v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        WhereClause a2 = yyOpValue1;

        if (a2 == null) a2 = FortressUtil.emptyWhereClause();
        yyValue = new TraitTypeWhere(a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.Extends.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineHeader$Extends(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fNoNewlineHeader$Extends) 
      yyColumn.chunk10.fNoNewlineHeader$Extends = pNoNewlineHeader$Extends$1(yyStart);
    return yyColumn.chunk10.fNoNewlineHeader$Extends;
  }

  /** Actually parse NoNewlineHeader.Extends. */
  private Result pNoNewlineHeader$Extends$1(final int yyStart) 
    throws IOException {

    Result          yyResult;
    List<TraitType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pextends(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitTypes(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.Excludes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExcludes(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fExcludes) 
      yyColumn.chunk10.fExcludes = pExcludes$1(yyStart);
    return yyColumn.chunk10.fExcludes;
  }

  /** Actually parse NoNewlineHeader.Excludes. */
  private Result pExcludes$1(final int yyStart) throws IOException {
    Result          yyResult;
    List<TraitType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexcludes(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitTypes(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.Comprises.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComprises(final int yyStart) throws IOException {
    Result          yyResult;
    List<TraitType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcomprises(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitTypes(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.AbsComprises.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsComprises(final int yyStart) throws IOException {
    Result          yyResult;
    List<TraitType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcomprises(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pComprisingTypes(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.TraitTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitTypes(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fTraitTypes) 
      yyColumn.chunk10.fTraitTypes = pTraitTypes$1(yyStart);
    return yyColumn.chunk10.fTraitTypes;
  }

  /** Actually parse NoNewlineHeader.TraitTypes. */
  private Result pTraitTypes$1(final int yyStart) throws IOException {
    Result          yyResult;
    List<TraitType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TraitType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitType a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTraitTypeList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.TraitTypeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitTypeList(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyRepetition1;
    Pair<TraitType> yyRepValue1;
    List<TraitType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TraitType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitType a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineType$TraitType(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TraitType v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<TraitType>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<TraitType> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.ComprisingTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComprisingTypes(final int yyStart) throws IOException {
    Result          yyResult;
    List<TraitType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TraitType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitType a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pComprisingTypeList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.ComprisingTypeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComprisingTypeList(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyRepetition1;
    Pair<TraitType> yyRepValue1;
    int             yyOption1;
    List<TraitType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pellipses(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = FortressUtil.emptyTraitTypes();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineType$TraitType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitType a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineType$TraitType(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TraitType v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<TraitType>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<TraitType> a2s = yyRepValue1.reverse();

        yyOption1  = yyRepetition1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
              }
            }
          }
        }

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.Where.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhere(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fWhere) 
      yyColumn.chunk10.fWhere = pWhere$1(yyStart);
    return yyColumn.chunk10.fWhere;
  }

  /** Actually parse NoNewlineHeader.Where. */
  private Result pWhere$1(final int yyStart) throws IOException {
    Result                yyResult;
    int                   yyOption1;
    List<WhereConstraint> yyOpValue1;
    WhereClause           yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pwhere(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = popendoublesquare(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pWhereBindingList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WhereBinding> a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pclosedoublesquare(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = popencurly(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pWhereConstraintList(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          List<WhereConstraint> v$el$1 = yyResult.semanticValue();

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pclosecurly(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyOption1  = yyResult.index;
                              yyOpValue1 = v$el$1;
                            }
                          }
                        }
                      }
                    }
                  }
                  { // Start scope for a2.
                    List<WhereConstraint> a2 = yyOpValue1;

                    if (a2 == null)
                    yyValue = new WhereClause(a1, Collections.<WhereConstraint>emptyList());
                    else
                    yyValue = new WhereClause(a1, a2);

                    return new SemanticValue(yyValue, yyOption1, yyError);
                  } // End scope for a2.
                }
              }
            }
          }
        }

        // Nested alternative 2.

        yyResult = popencurly(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pWhereConstraintList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WhereConstraint> a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pclosecurly(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = new WhereClause(Collections.<WhereBinding>emptyList(), a1);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.WhereBindingList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhereBindingList(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fWhereBindingList) 
      yyColumn.chunk10.fWhereBindingList = pWhereBindingList$1(yyStart);
    return yyColumn.chunk10.fWhereBindingList;
  }

  /** Actually parse NoNewlineHeader.WhereBindingList. */
  private Result pWhereBindingList$1(final int yyStart) throws IOException {
    Result             yyResult;
    List<WhereBinding> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWhereBinding(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WhereBinding a1 = yyResult.semanticValue();

      yyResult = pWhereBindingList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<WhereBinding> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.WhereBindingList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhereBindingList$$Star1(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fWhereBindingList$$Star1) 
      yyColumn.chunk10.fWhereBindingList$$Star1 = pWhereBindingList$$Star1$1(yyStart);
    return yyColumn.chunk10.fWhereBindingList$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.WhereBindingList$$Star1. */
  private Result pWhereBindingList$$Star1$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    Pair<WhereBinding> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pWhereBinding(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            WhereBinding v$el$1 = yyResult.semanticValue();

            yyResult = pWhereBindingList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<WhereBinding> v$2 = yyResult.semanticValue();

              yyValue = new Pair<WhereBinding>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.WhereBinding.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhereBinding(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fWhereBinding) 
      yyColumn.chunk10.fWhereBinding = pWhereBinding$1(yyStart);
    return yyColumn.chunk10.fWhereBinding;
  }

  /** Actually parse NoNewlineHeader.WhereBinding. */
  private Result pWhereBinding$1(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    List<TraitType> yyOpValue1;
    WhereBinding    yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pnat(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyValue = new WhereNat(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pint(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyValue = new WhereInt(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = pbool(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyValue = new WhereBool(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyResult = punit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyValue = new WhereUnit(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineHeader$Extends(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<TraitType> a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = a2;
        }
      }
      { // Start scope for a2.
        List<TraitType> a2 = yyOpValue1;

        if (a2 == null) a2 = FortressUtil.emptyTraitTypes();
        yyValue = new WhereType(createSpan(yyStart,yyCount), a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Alternative 6.

    yyResult = popendoublesquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = error(new VoidLiteralExpr(createSpan(yyStart,yyCount)),
      "White square bracket is not a valid where-clause binding.");

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.FnHeaderClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnHeaderClause(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fFnHeaderClause) 
      yyColumn.chunk10.fFnHeaderClause = pFnHeaderClause$1(yyStart);
    return yyColumn.chunk10.fFnHeaderClause;
  }

  /** Actually parse NoNewlineHeader.FnHeaderClause. */
  private Result pFnHeaderClause$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    Type           yyOpValue1;
    FnHeaderClause yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pNoNewlineIsType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Type v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      Type a1 = yyOpValue1;

      yyResult = pFnClauses(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        FnHeaderClause a2 = yyResult.semanticValue();

        Option<Type> returnType = Option.wrap(a1);
        yyValue = new FnHeaderClause(a2.getThrowsClause(), a2.getWhereClause(),
        a2.getContractClause(), returnType);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.FnClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnClauses(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fFnClauses) 
      yyColumn.chunk10.fFnClauses = pFnClauses$1(yyStart);
    return yyColumn.chunk10.fFnClauses;
  }

  /** Actually parse NoNewlineHeader.FnClauses. */
  private Result pFnClauses$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    Object         yyOpValue1;
    FnHeaderClause yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pThrows(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<TraitType> v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      List<TraitType> a1 = cast(yyOpValue1);

      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pWhere(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WhereClause v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a2.
        WhereClause a2 = cast(yyOpValue1);

        yyResult = pContract(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Contract a3 = yyResult.semanticValue();

          Option<List<TraitType>> throwsClause = Option.wrap(a1);
          if (a2 == null)         a2 = FortressUtil.emptyWhereClause();
          Option<Contract>        contractClause = Option.wrap(a3);
          yyValue = new FnHeaderClause(throwsClause, a2, contractClause,
          Option.<Type>none());

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for a2.
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.Throws.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pThrows(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fThrows) 
      yyColumn.chunk11.fThrows = pThrows$1(yyStart);
    return yyColumn.chunk11.fThrows;
  }

  /** Actually parse NoNewlineHeader.Throws. */
  private Result pThrows$1(final int yyStart) throws IOException {
    Result          yyResult;
    List<TraitType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pthrows(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMayTraitTypes(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.MayTraitTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMayTraitTypes(final int yyStart) throws IOException {
    Result          yyResult;
    List<TraitType> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pclosecurly(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = FortressUtil.emptyTraitTypes();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pTraitTypes(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.TraitMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitMods(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fTraitMods) 
      yyColumn.chunk11.fTraitMods = pTraitMods$1(yyStart);
    return yyColumn.chunk11.fTraitMods;
  }

  /** Actually parse NoNewlineHeader.TraitMods. */
  private Result pTraitMods$1(final int yyStart) throws IOException {
    Result         yyResult;
    List<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitMods$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Modifier> a1s = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1s.list());
      FortressUtil.noDuplicate(yyValue);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.TraitMods$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitMods$$Plus1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fTraitMods$$Plus1) 
      yyColumn.chunk11.fTraitMods$$Plus1 = pTraitMods$$Plus1$1(yyStart);
    return yyColumn.chunk11.fTraitMods$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.TraitMods$$Plus1. */
  private Result pTraitMods$$Plus1$1(final int yyStart) throws IOException {
    Result         yyResult;
    Pair<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTraitMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifier v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pTraitMods$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Modifier> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Modifier>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = new Pair<Modifier>(v$el$1);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.TraitMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitMod(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAbsTraitMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pprivate(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierPrivate(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.AbsTraitMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsTraitMods(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fAbsTraitMods) 
      yyColumn.chunk11.fAbsTraitMods = pAbsTraitMods$1(yyStart);
    return yyColumn.chunk11.fAbsTraitMods;
  }

  /** Actually parse NoNewlineHeader.AbsTraitMods. */
  private Result pAbsTraitMods$1(final int yyStart) throws IOException {
    Result         yyResult;
    List<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAbsTraitMods$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Modifier> a1s = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1s.list());
      FortressUtil.noDuplicate(yyValue);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.AbsTraitMods$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsTraitMods$$Plus1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fAbsTraitMods$$Plus1) 
      yyColumn.chunk11.fAbsTraitMods$$Plus1 = pAbsTraitMods$$Plus1$1(yyStart);
    return yyColumn.chunk11.fAbsTraitMods$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.AbsTraitMods$$Plus1. */
  private Result pAbsTraitMods$$Plus1$1(final int yyStart) 
    throws IOException {

    Result         yyResult;
    Pair<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAbsTraitMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifier v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pAbsTraitMods$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Modifier> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Modifier>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = new Pair<Modifier>(v$el$1);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.AbsTraitMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsTraitMod(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fAbsTraitMod) 
      yyColumn.chunk11.fAbsTraitMod = pAbsTraitMod$1(yyStart);
    return yyColumn.chunk11.fAbsTraitMod;
  }

  /** Actually parse NoNewlineHeader.AbsTraitMod. */
  private Result pAbsTraitMod$1(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pvalue(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierValue(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ptest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierTest(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.MdMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMdMods(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fMdMods) 
      yyColumn.chunk11.fMdMods = pMdMods$1(yyStart);
    return yyColumn.chunk11.fMdMods;
  }

  /** Actually parse NoNewlineHeader.MdMods. */
  private Result pMdMods$1(final int yyStart) throws IOException {
    Result         yyResult;
    List<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMdMods$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Modifier> a1s = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1s.list());
      FortressUtil.noDuplicate(yyValue);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.MdMods$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMdMods$$Plus1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fMdMods$$Plus1) 
      yyColumn.chunk11.fMdMods$$Plus1 = pMdMods$$Plus1$1(yyStart);
    return yyColumn.chunk11.fMdMods$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.MdMods$$Plus1. */
  private Result pMdMods$$Plus1$1(final int yyStart) throws IOException {
    Result         yyResult;
    Pair<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMdMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifier v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pMdMods$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Modifier> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Modifier>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = new Pair<Modifier>(v$el$1);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.MdMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMdMod(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFnMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = poverride(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierOverride(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.AbsMdMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsMdMods(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyRepetition1;
    boolean        yyRepeated1;
    Pair<Modifier> yyRepValue1;
    List<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pAbsMdMod(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Modifier v$el$1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Modifier>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Modifier> a1s = yyRepValue1.reverse();

      yyValue = FortressUtil.mkList(a1s.list());
      FortressUtil.noDuplicate(yyValue);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.AbsMdMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsMdMod(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAbsFnMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = poverride(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierOverride(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.FnMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnMods(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fFnMods) 
      yyColumn.chunk11.fFnMods = pFnMods$1(yyStart);
    return yyColumn.chunk11.fFnMods;
  }

  /** Actually parse NoNewlineHeader.FnMods. */
  private Result pFnMods$1(final int yyStart) throws IOException {
    Result         yyResult;
    List<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFnMods$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Modifier> a1s = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1s.list());
      FortressUtil.noDuplicate(yyValue);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.FnMods$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnMods$$Plus1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fFnMods$$Plus1) 
      yyColumn.chunk11.fFnMods$$Plus1 = pFnMods$$Plus1$1(yyStart);
    return yyColumn.chunk11.fFnMods$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.FnMods$$Plus1. */
  private Result pFnMods$$Plus1$1(final int yyStart) throws IOException {
    Result         yyResult;
    Pair<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFnMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifier v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pFnMods$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Modifier> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Modifier>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = new Pair<Modifier>(v$el$1);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.FnMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFnMod(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fFnMod) 
      yyColumn.chunk12.fFnMod = pFnMod$1(yyStart);
    return yyColumn.chunk12.fFnMod;
  }

  /** Actually parse NoNewlineHeader.FnMod. */
  private Result pFnMod$1(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAbsFnMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pprivate(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierPrivate(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.AbsFnMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsFnMods(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fAbsFnMods) 
      yyColumn.chunk12.fAbsFnMods = pAbsFnMods$1(yyStart);
    return yyColumn.chunk12.fAbsFnMods;
  }

  /** Actually parse NoNewlineHeader.AbsFnMods. */
  private Result pAbsFnMods$1(final int yyStart) throws IOException {
    Result         yyResult;
    List<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAbsFnMods$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Modifier> a1s = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1s.list());
      FortressUtil.noDuplicate(yyValue);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.AbsFnMods$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsFnMods$$Plus1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fAbsFnMods$$Plus1) 
      yyColumn.chunk12.fAbsFnMods$$Plus1 = pAbsFnMods$$Plus1$1(yyStart);
    return yyColumn.chunk12.fAbsFnMods$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.AbsFnMods$$Plus1. */
  private Result pAbsFnMods$$Plus1$1(final int yyStart) throws IOException {
    Result         yyResult;
    Pair<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAbsFnMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifier v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pAbsFnMods$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Modifier> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Modifier>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = new Pair<Modifier>(v$el$1);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.AbsFnMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsFnMod(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fAbsFnMod) 
      yyColumn.chunk12.fAbsFnMod = pAbsFnMod$1(yyStart);
    return yyColumn.chunk12.fAbsFnMod;
  }

  /** Actually parse NoNewlineHeader.AbsFnMod. */
  private Result pAbsFnMod$1(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLocalFnMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ptest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierTest(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.LocalFnMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalFnMods(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyRepetition1;
    boolean        yyRepeated1;
    Pair<Modifier> yyRepValue1;
    List<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pLocalFnMod(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Modifier v$el$1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Modifier>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Modifier> a1s = yyRepValue1.reverse();

      yyValue = FortressUtil.mkList(a1s.list());
      FortressUtil.noDuplicate(yyValue);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.LocalFnMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalFnMod(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fLocalFnMod) 
      yyColumn.chunk12.fLocalFnMod = pLocalFnMod$1(yyStart);
    return yyColumn.chunk12.fLocalFnMod;
  }

  /** Actually parse NoNewlineHeader.LocalFnMod. */
  private Result pLocalFnMod$1(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = patomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierAtomic(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pio(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierIO(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.ParamFldMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParamFldMods(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyRepetition1;
    boolean        yyRepeated1;
    Pair<Modifier> yyRepValue1;
    List<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pParamFldMod(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Modifier v$el$1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Modifier>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Modifier> a1s = yyRepValue1.reverse();

      yyValue = FortressUtil.mkList(a1s.list());
      FortressUtil.noDuplicate(yyValue);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.ParamFldMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParamFldMod(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pvar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierVar(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = phidden(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierHidden(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = psettable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierSettable(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pwrapped(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierWrapped(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.FldMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFldMods(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyRepetition1;
    boolean        yyRepeated1;
    Pair<Modifier> yyRepValue1;
    List<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pFldMod(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Modifier v$el$1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Modifier>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Modifier> a1s = yyRepValue1.reverse();

      yyValue = FortressUtil.mkList(a1s.list());
      FortressUtil.noDuplicate(yyValue);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.FldMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFldMod(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pvar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierVar(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAbsFldMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.AbsFldMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsFldMod(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pApiFldMod(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pwrapped(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierWrapped(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pprivate(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierPrivate(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.ApiFldMods.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pApiFldMods(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyRepetition1;
    boolean        yyRepeated1;
    Pair<Modifier> yyRepValue1;
    List<Modifier> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pApiFldMod(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Modifier v$el$1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Modifier>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<Modifier> a1s = yyRepValue1.reverse();

      yyValue = FortressUtil.mkList(a1s.list());
      FortressUtil.noDuplicate(yyValue);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.ApiFldMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pApiFldMod(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fApiFldMod) 
      yyColumn.chunk12.fApiFldMod = pApiFldMod$1(yyStart);
    return yyColumn.chunk12.fApiFldMod;
  }

  /** Actually parse NoNewlineHeader.ApiFldMod. */
  private Result pApiFldMod$1(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = phidden(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierHidden(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = psettable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierSettable(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = ptest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new ModifierTest(createSpan(yyStart,yyCount));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.StaticParams.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticParams(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fStaticParams) 
      yyColumn.chunk12.fStaticParams = pStaticParams$1(yyStart);
    return yyColumn.chunk12.fStaticParams;
  }

  /** Actually parse NoNewlineHeader.StaticParams. */
  private Result pStaticParams$1(final int yyStart) throws IOException {
    Result            yyResult;
    List<StaticParam> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popendoublesquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStaticParamList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosedoublesquare(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.StaticParamList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticParamList(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<StaticParam> yyRepValue1;
    List<StaticParam> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStaticParam(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StaticParam a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStaticParam(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                StaticParam v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<StaticParam>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<StaticParam> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineHeader.StaticParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStaticParam(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fStaticParam) 
      yyColumn.chunk12.fStaticParam = pStaticParam$1(yyStart);
    return yyColumn.chunk12.fStaticParam;
  }

  /** Actually parse NoNewlineHeader.StaticParam. */
  private Result pStaticParam$1(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    Object      yyOpValue1;
    StaticParam yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pnat(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyValue = new NatParam(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pint(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyValue = new IntParam(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = pbool(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyValue = new BoolParam(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyResult = pdim(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyValue = new DimensionParam(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = punit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pSymbol$colon(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineType(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Type v$el$1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
            }
          }
          { // Start scope for a2.
            Type a2 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pabsorbs(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = punit(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    String v$el$2 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$2;
                  }
                }
              }
            }
            { // Start scope for a3.
              String a3 = cast(yyOpValue1);

              Option<Type> derived = Option.wrap(a2);
              boolean absorbs = (a3 == null) ? false : true;
              yyValue = new UnitParam(createSpan(yyStart,yyCount), a1,
              derived, absorbs);

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a3.
          } // End scope for a2.
        }
      }
    }

    // Alternative 6.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a1 = yyResult.semanticValue();

          yyValue = new OperatorParam(createSpan(yyStart,yyCount), a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 7.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineHeader$Extends(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<TraitType> v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
      }
      { // Start scope for a2.
        List<TraitType> a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pabsorbs(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = punit(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                String v$el$4 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$4;
              }
            }
          }
        }
        { // Start scope for a3.
          String a3 = cast(yyOpValue1);

          if (a2 == null) a2 = Collections.<TraitType>emptyList();
          boolean absorbs;
          if (a3 == null) absorbs = false;
          else            absorbs = true;
          yyValue = new SimpleTypeParam(createSpan(yyStart,yyCount),
          a1, a2, absorbs);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      } // End scope for a2.
    }

    // Alternative 8.

    yyResult = popendoublesquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = error(new VoidLiteralExpr(createSpan(yyStart,yyCount)),
      "White square bracket is not a valid static parameter.");

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal OtherDecl.DimUnitDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDimUnitDecl(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fDimUnitDecl) 
      yyColumn.chunk12.fDimUnitDecl = pDimUnitDecl$1(yyStart);
    return yyColumn.chunk12.fDimUnitDecl;
  }

  /** Actually parse OtherDecl.DimUnitDecl. */
  private Result pDimUnitDecl$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    Object            yyOpValue1;
    List<DimUnitDecl> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pdim(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pequals(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineType(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Type v$el$1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
            }
          }
          { // Start scope for a2.
            Type a2 = cast(yyOpValue1);

            final int yyChoice1 = yyOption1;

            // Nested alternative 1.

            yyResult = ps(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = p$$Shared58(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                String a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pId(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Id a4 = yyResult.semanticValue();

                    yyResult = pDimUnitDecl$$Star1(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Pair<Id> a5s = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pequals(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pNoNewlineExpr(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              Expr v$el$6 = yyResult.semanticValue();

                              yyOption1  = yyResult.index;
                              yyOpValue1 = v$el$6;
                            }
                          }
                        }
                      }
                      { // Start scope for a6.
                        Expr a6 = cast(yyOpValue1);

                        Span span = createSpan(yyStart,yyCount);
                        DimDecl dim = new DimDecl(span, a1, Option.wrap(a2));
                        boolean si_unit;
                        if (a3.equals("SI_unit")) si_unit = true;
                        else                      si_unit = false;
                        List<Id> ids = new ArrayList<Id>();
                        ids.add(a4);
                        for (Id a5Elt : a5s.list()) { ids.add(a5Elt); }
                        Type ty = new IdType(a1.getSpan(), NodeFactory.makeQualifiedIdName(a1));
                        UnitDecl unit = new UnitDecl(span, si_unit, ids, Option.some(ty),
                        Option.wrap(a6));
                        yyValue = FortressUtil.mkList(dim, unit);

                        return new SemanticValue(yyValue, yyOption1, yyError);
                      } // End scope for a6.
                    }
                  }
                }
              }
            }

            // Nested alternative 2.

            yyOption1  = yyChoice1;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pdefault(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pId(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Id v$el$7 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$7;
                  }
                }
              }
            }
            { // Start scope for a3.
              Id a3 = cast(yyOpValue1);

              DimDecl dim = new DimDecl(createSpan(yyStart,yyCount),
              a1, Option.wrap(a2), Option.wrap(a3));
              yyValue = FortressUtil.mkList((DimUnitDecl)dim);

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a3.
          } // End scope for a2.
        }
      }
    }

    // Alternative 2.

    yyResult = p$$Shared58(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a2 = yyResult.semanticValue();

          yyResult = pDimUnitDecl$$Star2(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<Id> a3s = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pSymbol$colon(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pNoNewlineType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Type v$el$12 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$12;
                  }
                }
              }
            }
            { // Start scope for a4.
              Type a4 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pequals(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pNoNewlineExpr(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Expr v$el$13 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$13;
                    }
                  }
                }
              }
              { // Start scope for a5.
                Expr a5 = cast(yyOpValue1);

                boolean si_unit;
                if (a1.equals("SI_unit")) si_unit = true;
                else                      si_unit = false;
                List<Id> ids = new ArrayList<Id>();
                ids.add(a2);
                for (Id a3Elt : a3s.list()) { ids.add(a3Elt); }
                UnitDecl unit = new UnitDecl(createSpan(yyStart,yyCount), si_unit,
                ids, Option.wrap(a4), Option.wrap(a5));
                yyValue = FortressUtil.mkList((DimUnitDecl)unit);

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for a5.
            } // End scope for a4.
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared58.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.Fortress.DimUnitDecl$$Choice1 
   * and com.sun.fortress.parser.Fortress.DimUnitDecl$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared58(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.f$$Shared58) 
      yyColumn.chunk12.f$$Shared58 = p$$Shared58$1(yyStart);
    return yyColumn.chunk12.f$$Shared58;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared58. */
  private Result p$$Shared58$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = punit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pSI_unit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.DimUnitDecl$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDimUnitDecl$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fDimUnitDecl$$Star1) 
      yyColumn.chunk13.fDimUnitDecl$$Star1 = pDimUnitDecl$$Star1$1(yyStart);
    return yyColumn.chunk13.fDimUnitDecl$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.DimUnitDecl$$Star1. */
  private Result pDimUnitDecl$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pwr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id v$el$4 = yyResult.semanticValue();

        yyResult = pDimUnitDecl$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Id> v$5 = yyResult.semanticValue();

          yyValue = new Pair<Id>(v$el$4, v$5);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.DimUnitDecl$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDimUnitDecl$$Star2(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fDimUnitDecl$$Star2) 
      yyColumn.chunk13.fDimUnitDecl$$Star2 = pDimUnitDecl$$Star2$1(yyStart);
    return yyColumn.chunk13.fDimUnitDecl$$Star2;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.DimUnitDecl$$Star2. */
  private Result pDimUnitDecl$$Star2$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pwr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id v$el$10 = yyResult.semanticValue();

        yyResult = pDimUnitDecl$$Star2(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Id> v$11 = yyResult.semanticValue();

          yyValue = new Pair<Id>(v$el$10, v$11);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal OtherDecl.TypeAlias.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeAlias(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fTypeAlias) 
      yyColumn.chunk13.fTypeAlias = pTypeAlias$1(yyStart);
    return yyColumn.chunk13.fTypeAlias;
  }

  /** Actually parse OtherDecl.TypeAlias. */
  private Result pTypeAlias$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<StaticParam> yyOpValue1;
    TypeAlias         yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ptype(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStaticParams(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<StaticParam> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<StaticParam> a2 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pequals(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pNoNewlineType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Type a3 = yyResult.semanticValue();

                    if (a2 == null) a2 = FortressUtil.emptyStaticParams();
                    yyValue = new TypeAlias(createSpan(yyStart,yyCount), a1, a2, a3);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal OtherDecl.TestDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTestDecl(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fTestDecl) 
      yyColumn.chunk13.fTestDecl = pTestDecl$1(yyStart);
    return yyColumn.chunk13.fTestDecl;
  }

  /** Actually parse OtherDecl.TestDecl. */
  private Result pTestDecl$1(final int yyStart) throws IOException {
    Result     yyResult;
    TestDecl   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ptest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popensquare(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineExpr$GeneratorClauseList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<GeneratorClause> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pclosesquare(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pequals(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pNoNewlineExpr(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              Expr a3 = yyResult.semanticValue();

                              yyValue = new TestDecl(createSpan(yyStart,yyCount), a1, a2, a3);

                              return yyResult.createValue(yyValue, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal OtherDecl.PropertyDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPropertyDecl(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fPropertyDecl) 
      yyColumn.chunk13.fPropertyDecl = pPropertyDecl$1(yyStart);
    return yyColumn.chunk13.fPropertyDecl;
  }

  /** Actually parse OtherDecl.PropertyDecl. */
  private Result pPropertyDecl$1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Object       yyOpValue1;
    PropertyDecl yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pproperty(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id v$el$1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pequals(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a1.
        Id a1 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pFORALL(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pParameter$ValParam(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<Param> v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
          }
        }
        { // Start scope for a2.
          List<Param> a2 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              Option<Id> id = (a1 == null) ? Option.<Id>none() : Option.some(a1);
              if (a2 == null) a2 = FortressUtil.emptyParams();
              yyValue = new PropertyDecl(createSpan(yyStart,yyCount), id, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a2.
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal OtherDecl.ExternalSyntax.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExternalSyntax(final int yyStart) throws IOException {
    Result         yyResult;
    ExternalSyntax yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psyntax(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pOpenExpander(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          SimpleName a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pCloseExpander(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  SimpleName a3 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pequals(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pNoNewlineExpr(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          Expr a4 = yyResult.semanticValue();

                          yyValue = new ExternalSyntax(createSpan(yyStart,yyCount),a1,a2,a3,a4);

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal OtherDecl.OpenExpander.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOpenExpander(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fOpenExpander) 
      yyColumn.chunk13.fOpenExpander = pOpenExpander$1(yyStart);
    return yyColumn.chunk13.fOpenExpander;
  }

  /** Actually parse OtherDecl.OpenExpander. */
  private Result pOpenExpander$1(final int yyStart) throws IOException {
    Result     yyResult;
    SimpleName yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal OtherDecl.CloseExpander.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCloseExpander(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fCloseExpander) 
      yyColumn.chunk13.fCloseExpander = pCloseExpander$1(yyStart);
    return yyColumn.chunk13.fCloseExpander;
  }

  /** Actually parse OtherDecl.CloseExpander. */
  private Result pCloseExpander$1(final int yyStart) throws IOException {
    Result     yyResult;
    SimpleName yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pRightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pend(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      yyValue = new Id(span, "end");

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal OtherDecl.AbsExternalSyntax.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbsExternalSyntax(final int yyStart) throws IOException {
    Result            yyResult;
    AbsExternalSyntax yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psyntax(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pOpenExpander(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          SimpleName a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pCloseExpander(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  SimpleName a3 = yyResult.semanticValue();

                  yyValue = new AbsExternalSyntax(createSpan(yyStart,yyCount),a1,a2,a3);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.GrammarDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGrammarDef(final int yyStart) throws IOException {
    Result                  yyResult;
    int                     yyRepetition1;
    Pair<GrammarMemberDecl> yyRepValue1;
    int                     yyOption1;
    List<QualifiedIdName>   yyOpValue1;
    GrammarDecl             yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pgrammar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pGrammarExtends(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<QualifiedIdName> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<QualifiedIdName> a2 = yyOpValue1;

            yyRepetition1 = yyOption1;
            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = pbr(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNonterminalDef(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  GrammarMemberDecl v$el$2 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = 
                    new Pair<GrammarMemberDecl>(v$el$2, yyRepValue1);
                  continue;
                }
              }
              break;
            }
            { // Start scope for a3s.
              Pair<GrammarMemberDecl> a3s = yyRepValue1.reverse();

              yyResult = pw(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pend(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  if ( a2 == null) a2 = Collections.<QualifiedIdName>emptyList();
                  yyValue = new GrammarDef(createSpan(yyStart,yyCount), NodeFactory.makeQualifiedIdName(a1), a2, a3s.list());

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for a3s.
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.GrammarExtends.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGrammarExtends(final int yyStart) throws IOException {
    Result                yyResult;
    List<QualifiedIdName> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pextends(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pQualifiedNames(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.QualifiedNames.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualifiedNames(final int yyStart) throws IOException {
    Result                yyResult;
    List<QualifiedIdName> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pQualifiedNameList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.QualifiedNameList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualifiedNameList(final int yyStart) throws IOException {
    Result                yyResult;
    int                   yyRepetition1;
    Pair<QualifiedIdName> yyRepValue1;
    List<QualifiedIdName> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pQualifiedName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                QualifiedIdName v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = 
                  new Pair<QualifiedIdName>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<QualifiedIdName> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.NonterminalDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonterminalDef(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<SyntaxDef>   yyRepValue1;
    int               yyOption1;
    Object            yyOpValue1;
    GrammarMemberDecl yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pNonTermMod(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Option<ModifierPrivate> v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for m1.
      Option<ModifierPrivate> m1 = cast(yyOpValue1);

      yyResult = pId(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyResult = pSyntax$bar(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pType$TraitType(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TraitType v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
            { // Start scope for a2.
              TraitType a2 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcolonequals(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pSyntaxDef(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      SyntaxDef a4 = yyResult.semanticValue();

                      yyRepetition1 = yyResult.index;
                      yyRepValue1   = Pair.empty();
                      while (true) {

                        yyResult = pw(yyRepetition1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pSyntaxDefOr(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            SyntaxDef v$el$3 = yyResult.semanticValue();

                            yyRepetition1 = yyResult.index;
                            yyRepValue1   = 
                              new Pair<SyntaxDef>(v$el$3, yyRepValue1);
                            continue;
                          }
                        }
                        break;
                      }
                      { // Start scope for a4s.
                        Pair<SyntaxDef> a4s = yyRepValue1.reverse();

                        Option<TraitType> type = Option.none();
                        if (a2 != null) type = Option.some(a2);
                        if ( m1 == null) m1 = Option.none();
                        List<SyntaxDef> syntaxDefs = a4s.list();
                        syntaxDefs.add(0, a4);
                        yyValue = new NonterminalExtensionDef(createSpan(yyStart,yyCount), NodeFactory.makeQualifiedIdName(a1), type, m1, syntaxDefs);

                        return new SemanticValue(yyValue, yyRepetition1, yyError);
                      } // End scope for a4s.
                    }
                  }
                }
              }
            } // End scope for a2.
          }

          // Nested alternative 2.

          yyResult = pSyntax$colon(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice2 = yyResult.index;

            // Nested alternative 1.

            yyOption1  = yyChoice2;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pType$TraitType(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TraitType v$el$4 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$4;
              }
            }
            { // Start scope for a2.
              TraitType a2 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcolonequals(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pSyntaxDef(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      SyntaxDef a4 = yyResult.semanticValue();

                      yyRepetition1 = yyResult.index;
                      yyRepValue1   = Pair.empty();
                      while (true) {

                        yyResult = pw(yyRepetition1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pSyntaxDefOr(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            SyntaxDef v$el$5 = yyResult.semanticValue();

                            yyRepetition1 = yyResult.index;
                            yyRepValue1   = 
                              new Pair<SyntaxDef>(v$el$5, yyRepValue1);
                            continue;
                          }
                        }
                        break;
                      }
                      { // Start scope for a4s.
                        Pair<SyntaxDef> a4s = yyRepValue1.reverse();

                        Option<TraitType> type = Option.none();
                        if (a2 != null) type = Option.some(a2);
                        if ( m1 == null) m1 = Option.none();
                        List<SyntaxDef> syntaxDefs = a4s.list();
                        syntaxDefs.add(0, a4);
                        yyValue = new NonterminalDef(createSpan(yyStart,yyCount), NodeFactory.makeQualifiedIdName(a1), type, m1, syntaxDefs);

                        return new SemanticValue(yyValue, yyRepetition1, yyError);
                      } // End scope for a4s.
                    }
                  }
                }
              }
            } // End scope for a2.

            // Nested alternative 2.

            yyResult = pw(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pType$TraitType(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TraitType a2 = yyResult.semanticValue();

                Option<TraitType> type = Option.some(a2);
                List<SyntaxDef> syntaxDefs = Collections.<SyntaxDef>emptyList();
                if (m1 == null) m1 = Option.none();
                yyValue = new NonterminalDef(createSpan(yyStart,yyCount), NodeFactory.makeQualifiedIdName(a1), type, m1, syntaxDefs);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 3.

          yyResult = pSyntax$bar(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pType$TraitType(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TraitType a2 = yyResult.semanticValue();

                Option<TraitType> type = Option.some(a2);
                if ( m1 == null) m1 = Option.none();
                List<SyntaxDef> syntaxDefs = Collections.<SyntaxDef>emptyList();
                yyValue = new NonterminalExtensionDef(createSpan(yyStart,yyCount), NodeFactory.makeQualifiedIdName(a1), type, m1, syntaxDefs);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    } // End scope for m1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.NonTermMod.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonTermMod(final int yyStart) throws IOException {
    Result                  yyResult;
    Option<ModifierPrivate> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pprivate(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Option.wrap(new ModifierPrivate(createSpan(yyStart,yyCount)));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SyntaxDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntaxDef(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fSyntaxDef) 
      yyColumn.chunk13.fSyntaxDef = pSyntaxDef$1(yyStart);
    return yyColumn.chunk13.fSyntaxDef;
  }

  /** Actually parse Syntax.SyntaxDef. */
  private Result pSyntaxDef$1(final int yyStart) throws IOException {
    Result     yyResult;
    SyntaxDef  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSyntaxSymbols(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<SyntaxSymbol> a1s = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBlockExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Do a2 = yyResult.semanticValue();

          yyValue = NodeFactory.makeSyntaxDef(createSpan(yyStart,yyCount), a1s, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SyntaxDefOr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntaxDefOr(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fSyntaxDefOr) 
      yyColumn.chunk13.fSyntaxDefOr = pSyntaxDefOr$1(yyStart);
    return yyColumn.chunk13.fSyntaxDefOr;
  }

  /** Actually parse Syntax.SyntaxDefOr. */
  private Result pSyntaxDefOr$1(final int yyStart) throws IOException {
    Result     yyResult;
    SyntaxDef  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSyntax$bar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSyntaxSymbols(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<SyntaxSymbol> a1s = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockExpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Do a2 = yyResult.semanticValue();

              yyValue = NodeFactory.makeSyntaxDef(createSpan(yyStart,yyCount), a1s, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.BlockExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockExpr(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fBlockExpr) 
      yyColumn.chunk13.fBlockExpr = pBlockExpr$1(yyStart);
    return yyColumn.chunk13.fBlockExpr;
  }

  /** Actually parse Syntax.BlockExpr. */
  private Result pBlockExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Do         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSyntax$do(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pBlockExpr$$Choice1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Block a3 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pend(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            Span span = createSpan(yyStart, yyCount);
            if (a3 == null) a3 = FortressUtil.doBlock(span);
            yyValue = new Do(span, false,
            FortressUtil.mkList(new DoFront(span, Option.<Expr>none(), false, a3)));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.BlockExpr$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockExpr$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Block      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pBlockElems(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SyntaxSymbols.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntaxSymbols(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fSyntaxSymbols) 
      yyColumn.chunk14.fSyntaxSymbols = pSyntaxSymbols$1(yyStart);
    return yyColumn.chunk14.fSyntaxSymbols;
  }

  /** Actually parse Syntax.SyntaxSymbols. */
  private Result pSyntaxSymbols$1(final int yyStart) throws IOException {
    Result             yyResult;
    Result             yyPredResult;
    List<SyntaxSymbol> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSyntaxSymbol(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SyntaxSymbol a1 = yyResult.semanticValue();

      yyResult = pSyntaxSymbols$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<List<SyntaxSymbol>> a1s = yyResult.semanticValue();

        yyPredResult = pw(yyResult.index);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyPredResult = pSyntax$do(yyPredResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            List<SyntaxSymbol> ls = FortressUtil.mkList(a1);
            for(List<SyntaxSymbol> sl: a1s.list()) {
              ls.addAll(sl);
            }
            yyValue = ls;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.SyntaxSymbols$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntaxSymbols$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fSyntaxSymbols$$Star1) 
      yyColumn.chunk14.fSyntaxSymbols$$Star1 = pSyntaxSymbols$$Star1$1(yyStart);
    return yyColumn.chunk14.fSyntaxSymbols$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.SyntaxSymbols$$Star1. */
  private Result pSyntaxSymbols$$Star1$1(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    Pair<List<SyntaxSymbol>> yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbs(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<SyntaxSymbol> v$el$1 = yyResult.semanticValue();

      yyResult = pSyntaxSymbols$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<List<SyntaxSymbol>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<List<SyntaxSymbol>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Symbs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbs(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    boolean            yyRepeated1;
    Pair<SyntaxSymbol> yyRepValue1;
    List<SyntaxSymbol> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pSpaceOrBreakline(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        SyntaxSymbol v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<SyntaxSymbol>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      Pair<SyntaxSymbol> a1 = yyRepValue1.reverse();

      yyResult = pSyntaxSymbol(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        SyntaxSymbol a2 = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1.list(),a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SpaceOrBreakline.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpaceOrBreakline(final int yyStart) throws IOException {
    Result       yyResult;
    SyntaxSymbol yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSyntax$sr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = new WhitespaceSymbol(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pBreakline(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SyntaxSymbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntaxSymbol(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fSyntaxSymbol) 
      yyColumn.chunk14.fSyntaxSymbol = pSyntaxSymbol$1(yyStart);
    return yyColumn.chunk14.fSyntaxSymbol;
  }

  /** Actually parse Syntax.SyntaxSymbol. */
  private Result pSyntaxSymbol$1(final int yyStart) throws IOException {
    Result       yyResult;
    SyntaxSymbol yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSymbol(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          SyntaxSymbol s1 = yyResult.semanticValue();

          if (s1 instanceof NoWhitespaceSymbol) {
            SyntaxSymbol tmp = ((NoWhitespaceSymbol) s1).getSymbol();
            yyValue = new NoWhitespaceSymbol(createSpan(yyStart,yyCount), new NotPredicateSymbol(s1.getSpan(), tmp));
          }
          else {
            yyValue = new NotPredicateSymbol(createSpan(yyStart,yyCount), s1);
          }

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pAnd(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSymbol(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          SyntaxSymbol s1 = yyResult.semanticValue();

          if (s1 instanceof NoWhitespaceSymbol) {
            SyntaxSymbol tmp = ((NoWhitespaceSymbol) s1).getSymbol();
            yyValue = new NoWhitespaceSymbol(createSpan(yyStart,yyCount), new AndPredicateSymbol(s1.getSpan(), tmp));
          }
          else {
            yyValue = new AndPredicateSymbol(createSpan(yyStart,yyCount), s1);
          }

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pSyntax$colon(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSymbol(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          SyntaxSymbol s1 = yyResult.semanticValue();

          Option<Id> prefix = Option.some(a1);
          if (s1 instanceof NoWhitespaceSymbol) {
            SyntaxSymbol tmp = ((NoWhitespaceSymbol) s1).getSymbol();
            yyValue = new NoWhitespaceSymbol(s1.getSpan(), new PrefixedSymbol(prefix, tmp));
          }
          else {
            yyValue = new PrefixedSymbol(prefix, s1);
          }

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyResult = pSymbol(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SyntaxSymbol s1 = yyResult.semanticValue();

      Option<Id> prefix = Option.none();
      if (s1 instanceof NoWhitespaceSymbol) {
        SyntaxSymbol tmp = ((NoWhitespaceSymbol) s1).getSymbol();
        yyValue = new NoWhitespaceSymbol(s1.getSpan(), new PrefixedSymbol(prefix, tmp));
      }
      else
      if (s1 instanceof SpecialSymbol) {
        yyValue = s1;
      }
      else {
        yyValue = new PrefixedSymbol(prefix, s1);
      }

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Breakline.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBreakline(final int yyStart) throws IOException {
    Result       yyResult;
    SyntaxSymbol yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbreakline(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = new BreaklineSymbol(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Symbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fSymbol) 
      yyColumn.chunk14.fSymbol = pSymbol$1(yyStart);
    return yyColumn.chunk14.fSymbol;
  }

  /** Actually parse Syntax.Symbol. */
  private Result pSymbol$1(final int yyStart) throws IOException {
    Result       yyResult;
    SyntaxSymbol yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSuffix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SyntaxSymbol a1 = yyResult.semanticValue();

      yyResult = phash(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new NoWhitespaceSymbol(createSpan(yyStart,yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSuffix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Suffix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSuffix(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fSuffix) 
      yyColumn.chunk14.fSuffix = pSuffix$1(yyStart);
    return yyColumn.chunk14.fSuffix;
  }

  /** Actually parse Syntax.Suffix. */
  private Result pSuffix$1(final int yyStart) throws IOException {
    Result       yyResult;
    SyntaxSymbol yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pItem(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SyntaxSymbol a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pquestionmark(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new OptionalSymbol(createSpan(yyStart,yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pSyntax$star(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new RepeatSymbol(createSpan(yyStart,yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pSyntax$plus(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new RepeatOneOrMoreSymbol(createSpan(yyStart,yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pItem(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Item.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pItem(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fItem) 
      yyColumn.chunk14.fItem = pItem$1(yyStart);
    return yyColumn.chunk14.fItem;
  }

  /** Actually parse Syntax.Item. */
  private Result pItem$1(final int yyStart) throws IOException {
    Result       yyResult;
    Result       yyPredResult;
    boolean      yyPredMatched;
    SyntaxSymbol yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pw(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredResult = pSyntax$do(yyPredResult.index);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }
    }

    if (! yyPredMatched) {

      yyResult = pItemText(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String s = yyResult.semanticValue();

        yyValue = new ItemSymbol(s);

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("item expected", yyStart);
    }

    // Alternative 2.

    yyResult = pTab(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new TabSymbol();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pFormfeed(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new FormfeedSymbol();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pReturn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new CarriageReturnSymbol();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pSyntax$Newline(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new NewlineSymbol();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pSyntax$Space(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new WhitespaceSymbol(" ");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pBackspace(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new BackspaceSymbol();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = popenSquareBraket(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pItem$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<CharacterSymbol> a1 = yyResult.semanticValue();

        yyResult = pcloseSquareBraket(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = new CharacterClassSymbol(a1.list());

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.Item$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pItem$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fItem$$Star1) 
      yyColumn.chunk14.fItem$$Star1 = pItem$$Star1$1(yyStart);
    return yyColumn.chunk14.fItem$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.Item$$Star1. */
  private Result pItem$$Star1$1(final int yyStart) throws IOException {
    Result                yyResult;
    Pair<CharacterSymbol> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCharacterClass(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      CharacterSymbol v$el$1 = yyResult.semanticValue();

      yyResult = pItem$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<CharacterSymbol> v$2 = yyResult.semanticValue();

        yyValue = new Pair<CharacterSymbol>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.CharacterClass.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterClass(final int yyStart) throws IOException {
    Result          yyResult;
    CharacterSymbol yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pChar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String c1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pSyntax$colon(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pChar(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String c2 = yyResult.semanticValue();

          yyValue = new CharacterInterval(c1, c2);

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyValue = new CharSymbol(c1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Char.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pChar(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fChar) 
      yyColumn.chunk14.fChar = pChar$1(yyStart);
    return yyColumn.chunk14.fChar;
  }

  /** Actually parse Syntax.Char. */
  private Result pChar$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTab(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "\t";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pFormfeed(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "\f";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pReturn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "\r";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pSyntax$Newline(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "\n";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pSyntax$Space(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = " ";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pBackspace(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = "\u2408";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = putf16(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.ItemText.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pItemText(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pSpecialSymbols(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = putf16(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        while (true) {

          yyResult = putf16(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            continue;
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    } else {
      yyError = yyError.select("item text expected", yyStart);
    }

    // Alternative 2.

    yyResult = pSpecialSymbols(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      while (true) {

        yyResult = putf16(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          continue;
        }
        break;
      }

      if (yyRepeated1) {

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.utf16.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result putf16(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.futf16) 
      yyColumn.chunk14.futf16 = putf16$1(yyStart);
    return yyColumn.chunk14.futf16;
  }

  /** Actually parse Syntax.utf16. */
  private Result putf16$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('`' == yyC) {

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyResult = pSpecialChars(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pSpecialSymbols(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyPredMatched = false;

    yyPredResult = pSpecialChars(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char c1 = (char)yyC;

        if (('\u0000' <= c1) && (c1 <= '\uffff')) {

          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    } else {
      yyError = yyError.select("utf16 expected", yyStart);
    }

    // Done.
    yyError = yyError.select("utf16 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SpecialChars.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpecialChars(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk14) yyColumn.chunk14 = new Chunk14();
    if (null == yyColumn.chunk14.fSpecialChars) 
      yyColumn.chunk14.fSpecialChars = pSpecialChars$1(yyStart);
    return yyColumn.chunk14.fSpecialChars;
  }

  /** Actually parse Syntax.SpecialChars. */
  private Result pSpecialChars$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (' ' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyResult = pbreakline(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ':':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '?':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '#':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '+':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '*':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '`':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '|':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("special chars expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.SpecialSymbols.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpecialSymbols(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fSpecialSymbols) 
      yyColumn.chunk15.fSpecialSymbols = pSpecialSymbols$1(yyStart);
    return yyColumn.chunk15.fSpecialSymbols;
  }

  /** Actually parse Syntax.SpecialSymbols. */
  private Result pSpecialSymbols$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'T':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('A' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('B' == yyC) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case 'F':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('O' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('R' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('M' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('_' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('F' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('E' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('E' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('D' == yyC) {

                                          yyValue = null;

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'R':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('E' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('T' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('U' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('R' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('N' == yyC) {

                              yyValue = null;

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'N':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'E':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('W' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('L' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('I' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('N' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('E' == yyC) {

                                    yyValue = null;

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'O':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('T' == yyC) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'S':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('P' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('A' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('C' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('E' == yyC) {

                          yyValue = null;

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'B':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('A' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('C' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('K' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('S' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('P' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('A' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('C' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('E' == yyC) {

                                          yyValue = null;

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'A':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('N' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('D' == yyC) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case 'd':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('o' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyResult = pend(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("special symbols expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.bar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$bar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("bar expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.hash.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result phash(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('#' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("hash expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.colon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$colon(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("colon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.plus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$plus(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("plus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.questionmark.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pquestionmark(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('?' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("questionmark expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.star.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$star(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("star expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.openSquareBraket.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popenSquareBraket(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("open square braket expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.closeSquareBraket.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcloseSquareBraket(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (']' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("close square braket expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.And.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAnd(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('A' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('N' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('D' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("and expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Backspace.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBackspace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('B' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('A' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('C' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('K' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('S' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('P' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('A' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('C' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('E' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("backspace expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.do.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$do(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("do expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Formfeed.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFormfeed(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('F' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('O' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('R' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('M' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('_' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('F' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('E' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('E' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('D' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("formfeed expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Newline.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$Newline(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('N' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('E' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('W' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('L' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('I' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('N' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('E' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("newline expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Not.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNot(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('N' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('O' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('T' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("not expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Return.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pReturn(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('R' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('E' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('T' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('U' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('R' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('N' == yyC) {
                yyIndex = yyIndex + 1;

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("return expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$Space(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('S' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('P' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('A' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('C' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('E' == yyC) {
              yyIndex = yyIndex + 1;

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.Tab.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTab(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('T' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('A' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('B' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("tab expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.sr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSyntax$sr(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyBase = yyRepetition1;
      yyC    = character(yyBase);
      if (' ' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyRepetition1 = yyIndex;
        yyRepeated1   = true;
        continue;
      } else {
        yyError = yyError.select("\" \" expected", yyBase);
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Syntax.breakline.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbreakline(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fbreakline) 
      yyColumn.chunk15.fbreakline = pbreakline$1(yyStart);
    return yyColumn.chunk15.fbreakline;
  }

  /** Actually parse Syntax.breakline. */
  private Result pbreakline$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('\n' == yyC) {

              yyValue = "\r\n";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "\r";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\n':
        {
          yyValue = "\n";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("breakline expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$Type(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fType$Type) 
      yyColumn.chunk15.fType$Type = pType$Type$1(yyStart);
    return yyColumn.chunk15.fType$Type;
  }

  /** Actually parse Type.Type. */
  private Result pType$Type$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyOption1;
    Expr       yyOpValue1;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pone(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pType$TypePrimary(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pin(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExpression$Expr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$1 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$1;
              }
            }
          }
        }
        { // Start scope for a2.
          Expr a2 = yyOpValue1;

          Type ty = TypeResolver.resolveOps(a1);
          if (a2 == null)
          yyValue = ty;
          else {
            if (ty instanceof TaggedDimType) {
              TaggedDimType _ty = (TaggedDimType)ty;
              yyValue = new TaggedDimType(_ty.getSpan(), _ty.getType(),
              _ty.getDim(), Option.some(a2));
            } else {
              yyValue = error(ty, "A dimension type is expected.");
            }
          }

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }
    } else {
      yyError = yyError.select("type expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.OpType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$OpType(final int yyStart) throws IOException {
    Result                  yyResult;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$TypePrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pType$TypePrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TypePrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TypePrimary(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fType$TypePrimary) 
      yyColumn.chunk15.fType$TypePrimary = pType$TypePrimary$1(yyStart);
    return yyColumn.chunk15.fType$TypePrimary;
  }

  /** Actually parse Type.TypePrimary. */
  private Result pType$TypePrimary$1(final int yyStart) throws IOException {
    Result                  yyResult;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$TypePrimaryFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pType$TightInfixPostfix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealType(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pType$TypePrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealType(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pType$LooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealType(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 3.

      yyValue = PureList.make((PostfixOpExpr)new RealType(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TypePrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TypePrefix(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fType$TypePrefix) 
      yyColumn.chunk15.fType$TypePrefix = pType$TypePrefix$1(yyStart);
    return yyColumn.chunk15.fType$TypePrefix;
  }

  /** Actually parse Type.TypePrefix. */
  private Result pType$TypePrefix$1(final int yyStart) throws IOException {
    Result                  yyResult;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared15(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pType$TypePrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PostfixOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pType$TypePrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PostfixOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pType$TypePrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pType$TypePrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TightInfixPostfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TightInfixPostfix(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    int                     yyOption1;
    List<TraitType>         yyOpValue1;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared13(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pType$TypePrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pThrows(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<TraitType> v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        }
        { // Start scope for a3.
          List<TraitType> a3 = yyOpValue1;

          yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1, Option.wrap(a3)));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      }

      // Nested alternative 2.

      yyResult = pType$TypePrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pThrows(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<TraitType> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a3.
          List<TraitType> a3 = yyOpValue1;

          yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1, Option.wrap(a3)));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      }
    }

    // Alternative 2.

    yyResult = p$$Shared14(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pType$TypePrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pType$TypePrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = p$$Shared16(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pType$TypePrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pType$TypePrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyValue = PureList.make((PostfixOpExpr)new Postfix(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.LooseInfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$LooseInfix(final int yyStart) throws IOException {
    Result                  yyResult;
    int                     yyOption1;
    List<TraitType>         yyOpValue1;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared13(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pwr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pType$TypePrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pThrows(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<TraitType> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a3.
            List<TraitType> a3 = yyOpValue1;

            yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1, Option.wrap(a3)));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }

        // Nested alternative 2.

        yyResult = pType$TypePrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pThrows(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<TraitType> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
          { // Start scope for a3.
            List<TraitType> a3 = yyOpValue1;

            yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1, Option.wrap(a3)));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }
      }
    }

    // Alternative 2.

    yyResult = p$$Shared14(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pwr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pType$TypePrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pType$TypePrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TypePrimaryFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TypePrimaryFront(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Type>> yyRepValue1;
    Type               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$TypeFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pType$TypeTail(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Action<Type> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Type>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for list.
        Pair<Action<Type>> list = yyRepValue1.reverse();

        yyValue = (Type)apply(list, seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for list.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TypeFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TypeFront(final int yyStart) throws IOException {
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$ParenthesizedType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pType$ArgType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = p$$Shared9(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pone(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new BaseDim(createSpan(yyStart,1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.ParenthesizedType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$ParenthesizedType(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fType$ParenthesizedType) 
      yyColumn.chunk15.fType$ParenthesizedType = pType$ParenthesizedType$1(yyStart);
    return yyColumn.chunk15.fType$ParenthesizedType;
  }

  /** Actually parse Type.ParenthesizedType. */
  private Result pType$ParenthesizedType$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType$Type(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.ArgType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$ArgType(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fType$ArgType) 
      yyColumn.chunk15.fType$ArgType = pType$ArgType$1(yyStart);
    return yyColumn.chunk15.fType$ArgType;
  }

  /** Actually parse Type.ArgType. */
  private Result pType$ArgType$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Type       yyOpValue1;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType$ArgType$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Type> a1s = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyOption1  = yyChoice1;
          yyOpValue1 = null;

          yyResult = pType$Type(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Type v$el$4 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcomma(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$4;
                    }
                  }
                }
              }
            }
          }
          { // Start scope for a2.
            Type a2 = yyOpValue1;

            yyResult = pType$KeywordType(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              KeywordType a3 = yyResult.semanticValue();

              yyResult = pType$ArgType$$Star2(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Pair<KeywordType> a4s = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    List<Type>   ts1 = a1s.list();
                    Span span = createSpan(yyStart,yyCount);
                    Option<VarargsType> ts2 = ((a2 != null)?
                    Option.some(new VarargsType(span, a2)) :
                    Option.<VarargsType>none());
                    List<KeywordType> ts3 = a4s.list();
                    ts3.add(0, a3);
                    yyValue = new ArgType(span, ts1, ts2, ts3);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          } // End scope for a2.

          // Nested alternative 2.

          yyResult = pType$Type(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Type a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    List<Type> ts1 = FortressUtil.mkList(a1s.list());
                    Span span = createSpan(yyStart,yyCount);
                    Option<VarargsType> ts2 =
                    Option.some(new VarargsType(span, a2));
                    yyValue = NodeFactory.makeArgType(span, ts1, ts2);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pType$TupleType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Type.ArgType$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$ArgType$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fType$ArgType$$Star1) 
      yyColumn.chunk15.fType$ArgType$$Star1 = pType$ArgType$$Star1$1(yyStart);
    return yyColumn.chunk15.fType$ArgType$$Star1;
  }

  /** Actually parse Type.ArgType$$Star1. */
  private Result pType$ArgType$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$Type(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type v$el$2 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType$ArgType$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Type> v$3 = yyResult.semanticValue();

              yyValue = new Pair<Type>(v$el$2, v$3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Type.ArgType$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$ArgType$$Star2(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fType$ArgType$$Star2) 
      yyColumn.chunk15.fType$ArgType$$Star2 = pType$ArgType$$Star2$1(yyStart);
    return yyColumn.chunk15.fType$ArgType$$Star2;
  }

  /** Actually parse Type.ArgType$$Star2. */
  private Result pType$ArgType$$Star2$1(final int yyStart) 
    throws IOException {

    Result            yyResult;
    Pair<KeywordType> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pType$KeywordType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            KeywordType v$el$5 = yyResult.semanticValue();

            yyResult = pType$ArgType$$Star2(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<KeywordType> v$6 = yyResult.semanticValue();

              yyValue = new Pair<KeywordType>(v$el$5, v$6);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.KeywordType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$KeywordType(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk15) yyColumn.chunk15 = new Chunk15();
    if (null == yyColumn.chunk15.fType$KeywordType) 
      yyColumn.chunk15.fType$KeywordType = pType$KeywordType$1(yyStart);
    return yyColumn.chunk15.fType$KeywordType;
  }

  /** Actually parse Type.KeywordType. */
  private Result pType$KeywordType$1(final int yyStart) throws IOException {
    Result      yyResult;
    KeywordType yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType$Type(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyValue = new KeywordType(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TupleType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TupleType(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fType$TupleType) 
      yyColumn.chunk16.fType$TupleType = pType$TupleType$1(yyStart);
    return yyColumn.chunk16.fType$TupleType;
  }

  /** Actually parse Type.TupleType. */
  private Result pType$TupleType$1(final int yyStart) throws IOException {
    Result     yyResult;
    TupleType  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType$Type(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcomma(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pType$TypeList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Type> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      List<Type> ts = FortressUtil.mkList(a1, a2);
                      yyValue = NodeFactory.makeTupleType(createSpan(yyStart,yyCount), ts);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TypeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TypeList(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fType$TypeList) 
      yyColumn.chunk16.fType$TypeList = pType$TypeList$1(yyStart);
    return yyColumn.chunk16.fType$TypeList;
  }

  /** Actually parse Type.TypeList. */
  private Result pType$TypeList$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$Type(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyResult = pType$TypeList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Type> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Type.TypeList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TypeList$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.fType$TypeList$$Star1) 
      yyColumn.chunk16.fType$TypeList$$Star1 = pType$TypeList$$Star1$1(yyStart);
    return yyColumn.chunk16.fType$TypeList$$Star1;
  }

  /** Actually parse Type.TypeList$$Star1. */
  private Result pType$TypeList$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pType$Type(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Type v$el$1 = yyResult.semanticValue();

            yyResult = pType$TypeList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Type> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Type>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared8.
   * This nonterminal represents the duplicate productions Type.TypeRef 
   * and NoNewlineType.TypeRef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared8(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.f$$Shared8) 
      yyColumn.chunk16.f$$Shared8 = p$$Shared8$1(yyStart);
    return yyColumn.chunk16.f$$Shared8;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared8. */
  private Result p$$Shared8$1(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    List<StaticArg> yyOpValue1;
    Type            yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pStaticArgs(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<StaticArg> v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for a2.
        List<StaticArg> a2 = yyOpValue1;

        QualifiedIdName name = NodeFactory.makeQualifiedIdName(a1.getSpan(), a1);
        if (a2 == null)
        yyValue = new IdType(createSpan(yyStart,yyCount), name);
        else yyValue = new InstantiatedType(createSpan(yyStart,yyCount),name,a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared9.
   * This nonterminal represents the duplicate productions Type.VoidType 
   * and NoNewlineType.VoidType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared9(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.f$$Shared9) 
      yyColumn.chunk16.f$$Shared9 = p$$Shared9$1(yyStart);
    return yyColumn.chunk16.f$$Shared9;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared9. */
  private Result p$$Shared9$1(final int yyStart) throws IOException {
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcloseparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = new VoidType(createSpan(yyStart,yyCount));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TypeTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TypeTail(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<ExtentRange> yyRepValue1;
    int               yyOption1;
    Indices           yyOpValue1;
    Action<Type>      yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared32(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Indices v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        final Indices a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pclosesquare(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Action<Type>() {
              public Type run(Type base) {
                if (NodeUtil.isExponentiation((Type)base))
                return error((Type)base, "It is a static error if an " +
                "exponentiation or a vector type or an array " +
                "type is immediately followed by a left " +
                "square bracket.");
                return NodeFactory.makeArrayType(createSpan(yyStart,yyCount),
                (Type)base, Option.wrap(a1));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pIntExpr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final IntExpr a1 = yyResult.semanticValue();

        yyValue = new Action<Type>() {
          public Type run(Type base) {
            if (NodeUtil.isExponentiation((Type)base) ||
            NodeUtil.isExponentiation(a1))
            return error((Type)base, "It is a static error if an " +
            "exponentiation is immediately followed by " +
            "an exponentiation.");
            if (base instanceof DimExpr) {
              return new ExponentDim(createSpan(yyStart,yyCount),
              (DimExpr)base, a1);
            } else { // !(base instanceof DimExpr)
              return new ExponentType(createSpan(yyStart,yyCount),
              (Type)base, a1);
            }
        }};

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = popenparen(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared11(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final ExtentRange a1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = pw(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcross(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = p$$Shared11(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      final ExtentRange v$el$1 = yyResult.semanticValue();

                      yyRepetition1 = yyResult.index;
                      yyRepValue1   = 
                        new Pair<ExtentRange>(v$el$1, yyRepValue1);
                      continue;
                    }
                  }
                }
              }
              break;
            }
            { // Start scope for a2s.
              final Pair<ExtentRange> a2s = yyRepValue1.reverse();

              yyResult = pw(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = new Action<Type>() {
                    public Type run(Type base) {
                      if (NodeUtil.isExponentiation((Type)base))
                      return error((Type)base, "It is a static error if an " +
                      "exponentiation is immediately followed by " +
                      "an exponentiation.");
                      return NodeFactory.makeMatrixType(createSpan(yyStart,yyCount),
                      (Type)base,a1,a2s.list());
                  }};

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for a2s.
          }
        }
      }
    }

    // Alternative 3.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType$OpType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final PureList<PostfixOpExpr> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = new Action<Type>() {
                public Type run(Type base) {
                  DimExpr dim = TypeResolver.resolveOpsDim(a1);
                  return new TaggedDimType(createSpan(yyStart,yyCount), (Type)base,
                  NodeFactory.makeInParentheses(dim),
                  Option.<Expr>none());
              }};

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Id a1 = yyResult.semanticValue();

      yyValue = new Action<Type>() {
        public Type run(Type base) {
          Span span = a1.getSpan();
          DimRef dim = new DimRef(span,
          NodeFactory.makeQualifiedIdName(span,a1));
          return new TaggedDimType(createSpan(yyStart,yyCount), (Type)base,
          dim, Option.<Expr>none());
      }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared32.
   * This nonterminal represents the duplicate productions Type.ArraySize 
   * and NoNewlineType.ArraySize.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared32(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<ExtentRange> yyRepValue1;
    Indices           yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared11(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExtentRange a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = p$$Shared11(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                ExtentRange v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<ExtentRange>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<ExtentRange> a2s = yyRepValue1.reverse();

        List<ExtentRange> es = FortressUtil.mkList(a1, a2s.list());
        yyValue = new Indices(createSpan(yyStart,yyCount), es);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared11.
   * This nonterminal represents the duplicate productions Type.ExtentRange 
   * and NoNewlineType.ExtentRange.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared11(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.f$$Shared11) 
      yyColumn.chunk16.f$$Shared11 = p$$Shared11$1(yyStart);
    return yyColumn.chunk16.f$$Shared11;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared11. */
  private Result p$$Shared11$1(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    StaticArg   yyOpValue1;
    ExtentRange yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pStaticArg(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StaticArg v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      StaticArg a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = ppound(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStaticArg(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            StaticArg v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a2.
          StaticArg a2 = yyOpValue1;

          Option<StaticArg> base = Option.wrap(a1);
          Option<StaticArg> size = Option.wrap(a2);
          yyValue = new ExtentRange(createSpan(yyStart,yyCount), base, size);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }

      // Nested alternative 2.

      yyResult = pSymbol$colon(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pStaticArg(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            StaticArg v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
        }
        { // Start scope for a2.
          StaticArg a2 = yyOpValue1;

          Option<StaticArg> base = Option.wrap(a1);
          Option<StaticArg> size = Option.wrap(a2);
          yyValue = new ExtentRange(createSpan(yyStart,yyCount), base, size);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }
    } // End scope for a1.

    // Alternative 2.

    yyResult = pStaticArg(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StaticArg a1 = yyResult.semanticValue();

      yyValue = new ExtentRange(createSpan(yyStart,yyCount),
      Option.<StaticArg>none(),
      Option.some(a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared13.
   * This nonterminal represents the duplicate productions Type.TypeInfixOp 
   * and NoNewlineType.TypeInfixOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared13(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.f$$Shared13) 
      yyColumn.chunk16.f$$Shared13 = p$$Shared13$1(yyStart);
    return yyColumn.chunk16.f$$Shared13;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared13. */
  private Result p$$Shared13$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = prightarrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpInfix(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared14.
   * This nonterminal represents the duplicate productions Type.DimInfixOp 
   * and NoNewlineType.DimInfixOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared14(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.f$$Shared14) 
      yyColumn.chunk16.f$$Shared14 = p$$Shared14$1(yyStart);
    return yyColumn.chunk16.f$$Shared14;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared14. */
  private Result p$$Shared14$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared14$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpInfix(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.$$Shared14$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared14$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDOT(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pslash(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pper(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared15.
   * This nonterminal represents the duplicate productions Type.DimPrefixOp 
   * and NoNewlineType.DimPrefixOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared15(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.f$$Shared15) 
      yyColumn.chunk16.f$$Shared15 = p$$Shared15$1(yyStart);
    return yyColumn.chunk16.f$$Shared15;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared15. */
  private Result p$$Shared15$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared15$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpPrefix(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.$$Shared15$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared15$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 's':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('q' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('u' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('a' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('r' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('e' == yyC) {

                              yyPredMatched = false;

                              yyPredResult = pidrest(yyIndex);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = "square";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select(" expected", yyStart);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'c':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('u' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('b' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('i' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('c' == yyC) {

                          yyPredMatched = false;

                          yyPredResult = pidrest(yyIndex);
                          if (yyPredResult.hasValue()) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyValue = "cubic";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          } else {
                            yyError = yyError.select(" expected", yyStart);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'i':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('n' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('v' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('r' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('s' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('e' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "inverse";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select(" expected", yyStart);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared16.
   * This nonterminal represents the duplicate productions Type.DimPostfixOp 
   * and NoNewlineType.DimPostfixOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared16(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk16) yyColumn.chunk16 = new Chunk16();
    if (null == yyColumn.chunk16.f$$Shared16) 
      yyColumn.chunk16.f$$Shared16 = p$$Shared16$1(yyStart);
    return yyColumn.chunk16.f$$Shared16;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared16. */
  private Result p$$Shared16$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared16$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpPostfix(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.$$Shared16$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared16$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 's':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('q' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('u' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('a' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('r' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('e' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('d' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "squared";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select(" expected", yyStart);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'c':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('u' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('b' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('d' == yyC) {

                          yyPredMatched = false;

                          yyPredResult = pidrest(yyIndex);
                          if (yyPredResult.hasValue()) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyValue = "cubed";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          } else {
                            yyError = yyError.select(" expected", yyStart);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TraitType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TraitType(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fType$TraitType) 
      yyColumn.chunk17.fType$TraitType = pType$TraitType$1(yyStart);
    return yyColumn.chunk17.fType$TraitType;
  }

  /** Actually parse Type.TraitType. */
  private Result pType$TraitType$1(final int yyStart) throws IOException {
    Result     yyResult;
    TraitType  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$TraitTypeFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type seed = yyResult.semanticValue();

      yyResult = p$$Shared59(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Type>> list = yyResult.semanticValue();

        yyValue = (TraitType)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared59.
   * This nonterminal represents the duplicate productions 
   * Type.TraitType$$Plus1 and NoNewlineType.TraitType$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared59(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.f$$Shared59) 
      yyColumn.chunk17.f$$Shared59 = p$$Shared59$1(yyStart);
    return yyColumn.chunk17.f$$Shared59;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared59. */
  private Result p$$Shared59$1(final int yyStart) throws IOException {
    Result             yyResult;
    Pair<Action<Type>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared46(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Type> v$el$2 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = p$$Shared59(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Type>> v$3 = yyResult.semanticValue();

        yyValue = new Pair<Action<Type>>(v$el$2, v$3);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Action<Type>>(v$el$2);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Type.TraitTypeFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType$TraitTypeFront(final int yyStart) throws IOException {
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$ParenthesizedType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pType$ArgType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = p$$Shared9(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared46.
   * This nonterminal represents the duplicate productions Type.TraitTypeTail 
   * and NoNewlineType.TraitTypeTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared46(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<ExtentRange> yyRepValue1;
    int               yyOption1;
    Indices           yyOpValue1;
    Action<Type>      yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared32(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Indices v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        final Indices a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pclosesquare(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Action<Type>() {
              public Type run(Type base) {
                if (NodeUtil.isExponentiation((Type)base))
                return error((Type)base, "It is a static error if an " +
                "exponentiation or a vector type or an array " +
                "type is immediately followed by a left " +
                "square bracket.");
                return NodeFactory.makeArrayType(createSpan(yyStart,yyCount),
                (Type)base, Option.wrap(a1));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pIntExpr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final IntExpr a1 = yyResult.semanticValue();

        yyValue = new Action<Type>() {
          public Type run(Type base) {
            if (NodeUtil.isExponentiation((Type)base) ||
            NodeUtil.isExponentiation(a1))
            return error((Type)base, "It is a static error if an " +
            "exponentiation is immediately followed by " +
            "an exponentiation.");
            return TypeResolver.makeMatrixType(createSpan(yyStart,yyCount),
            (Type)base, a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = popenparen(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared11(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final ExtentRange a1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = pw(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcross(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = p$$Shared11(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      final ExtentRange v$el$1 = yyResult.semanticValue();

                      yyRepetition1 = yyResult.index;
                      yyRepValue1   = 
                        new Pair<ExtentRange>(v$el$1, yyRepValue1);
                      continue;
                    }
                  }
                }
              }
              break;
            }
            { // Start scope for a2s.
              final Pair<ExtentRange> a2s = yyRepValue1.reverse();

              yyResult = pw(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = new Action<Type>() {
                    public Type run(Type base) {
                      if (NodeUtil.isExponentiation((Type)base))
                      return error((Type)base, "It is a static error if an " +
                      "exponentiation is immediately followed by " +
                      "an exponentiation.");
                      return NodeFactory.makeMatrixType(createSpan(yyStart,yyCount),
                      (Type)base,a1,a2s.list());
                  }};

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for a2s.
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$Type(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fNoNewlineType$Type) 
      yyColumn.chunk17.fNoNewlineType$Type = pNoNewlineType$Type$1(yyStart);
    return yyColumn.chunk17.fNoNewlineType$Type;
  }

  /** Actually parse NoNewlineType.Type. */
  private Result pNoNewlineType$Type$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyOption1;
    Expr       yyOpValue1;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pone(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pNoNewlineType$TypePrimary(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pin(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExpression$Expr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$1 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$1;
              }
            }
          }
        }
        { // Start scope for a2.
          Expr a2 = yyOpValue1;

          Type ty = TypeResolver.resolveOps(a1);
          if (a2 == null)
          yyValue = ty;
          else {
            if (ty instanceof TaggedDimType) {
              TaggedDimType _ty = (TaggedDimType)ty;
              yyValue = new TaggedDimType(_ty.getSpan(), _ty.getType(),
              _ty.getDim(), Option.some(a2));
            } else {
              yyValue = error(ty, "A dimension type is expected.");
            }
          }

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }
    } else {
      yyError = yyError.select("type expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.OpType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$OpType(final int yyStart) throws IOException {
    Result                  yyResult;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TypePrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineType$TypePrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TypePrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TypePrimary(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fNoNewlineType$TypePrimary) 
      yyColumn.chunk17.fNoNewlineType$TypePrimary = pNoNewlineType$TypePrimary$1(yyStart);
    return yyColumn.chunk17.fNoNewlineType$TypePrimary;
  }

  /** Actually parse NoNewlineType.TypePrimary. */
  private Result pNoNewlineType$TypePrimary$1(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TypePrimaryFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineType$TightInfixPostfix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealType(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pSpacing$sr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineType$TypePrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealType(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineType$LooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealType(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 3.

      yyValue = PureList.make((PostfixOpExpr)new RealType(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TypePrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TypePrefix(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fNoNewlineType$TypePrefix) 
      yyColumn.chunk17.fNoNewlineType$TypePrefix = pNoNewlineType$TypePrefix$1(yyStart);
    return yyColumn.chunk17.fNoNewlineType$TypePrefix;
  }

  /** Actually parse NoNewlineType.TypePrefix. */
  private Result pNoNewlineType$TypePrefix$1(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared15(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineType$TypePrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PostfixOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoNewlineType$TypePrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PostfixOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pSpacing$sr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineType$TypePrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineType$TypePrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TightInfixPostfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TightInfixPostfix(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    int                     yyOption1;
    List<TraitType>         yyOpValue1;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared13(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineType$TypePrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = ps(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pThrows(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<TraitType> v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        }
        { // Start scope for a3.
          List<TraitType> a3 = yyOpValue1;

          yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1, Option.wrap(a3)));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      }

      // Nested alternative 2.

      yyResult = pNoNewlineType$TypePrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = ps(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pThrows(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<TraitType> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a3.
          List<TraitType> a3 = yyOpValue1;

          yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1, Option.wrap(a3)));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a3.
      }
    }

    // Alternative 2.

    yyResult = p$$Shared14(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineType$TypePrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoNewlineType$TypePrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PostfixOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = p$$Shared16(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pSpacing$sr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineType$TypePrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineType$TypePrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyValue = PureList.make((PostfixOpExpr)new Postfix(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.LooseInfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$LooseInfix(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    int                     yyOption1;
    List<TraitType>         yyOpValue1;
    PureList<PostfixOpExpr> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared13(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pSpacing$sr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineType$TypePrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = ps(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pThrows(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<TraitType> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a3.
            List<TraitType> a3 = yyOpValue1;

            yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1, Option.wrap(a3)));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }

        // Nested alternative 2.

        yyResult = pNoNewlineType$TypePrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = ps(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pThrows(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<TraitType> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
          { // Start scope for a3.
            List<TraitType> a3 = yyOpValue1;

            yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1, Option.wrap(a3)));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }
      }
    }

    // Alternative 2.

    yyResult = p$$Shared14(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pSpacing$sr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineType$TypePrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineType$TypePrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PostfixOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PostfixOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TypePrimaryFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TypePrimaryFront(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Type>> yyRepValue1;
    Type               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TypeFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pNoNewlineType$TypeTail(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Action<Type> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Type>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for list.
        Pair<Action<Type>> list = yyRepValue1.reverse();

        yyValue = (Type)apply(list, seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for list.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TypeFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TypeFront(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$ParenthesizedType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineType$ArgType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = p$$Shared9(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pone(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new BaseDim(createSpan(yyStart,1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.ParenthesizedType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$ParenthesizedType(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fNoNewlineType$ParenthesizedType) 
      yyColumn.chunk17.fNoNewlineType$ParenthesizedType = pNoNewlineType$ParenthesizedType$1(yyStart);
    return yyColumn.chunk17.fNoNewlineType$ParenthesizedType;
  }

  /** Actually parse NoNewlineType.ParenthesizedType. */
  private Result pNoNewlineType$ParenthesizedType$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineType$Type(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = NodeFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.ArgType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$ArgType(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fNoNewlineType$ArgType) 
      yyColumn.chunk17.fNoNewlineType$ArgType = pNoNewlineType$ArgType$1(yyStart);
    return yyColumn.chunk17.fNoNewlineType$ArgType;
  }

  /** Actually parse NoNewlineType.ArgType. */
  private Result pNoNewlineType$ArgType$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Type       yyOpValue1;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineType$ArgType$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Type> a1s = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyOption1  = yyChoice1;
          yyOpValue1 = null;

          yyResult = pNoNewlineType$Type(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Type v$el$4 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcomma(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$4;
                    }
                  }
                }
              }
            }
          }
          { // Start scope for a2.
            Type a2 = yyOpValue1;

            yyResult = pNoNewlineType$KeywordType(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              KeywordType a3 = yyResult.semanticValue();

              yyResult = pNoNewlineType$ArgType$$Star2(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Pair<KeywordType> a4s = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    List<Type>   ts1 = a1s.list();
                    Span span = createSpan(yyStart,yyCount);
                    Option<VarargsType> ts2 = ((a2 != null)?
                    Option.some(new VarargsType(span, a2)) :
                    Option.<VarargsType>none());
                    List<KeywordType> ts3 = a4s.list();
                    ts3.add(0, a3);
                    yyValue = new ArgType(span, ts1, ts2, ts3);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          } // End scope for a2.

          // Nested alternative 2.

          yyResult = pNoNewlineType$Type(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Type a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    List<Type> ts1 = FortressUtil.mkList(a1s.list());
                    Span span = createSpan(yyStart,yyCount);
                    Option<VarargsType> ts2 =
                    Option.some(new VarargsType(span, a2));
                    yyValue = NodeFactory.makeArgType(span, ts1, ts2);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pNoNewlineType$TupleType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal NoNewlineType.ArgType$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$ArgType$$Star1(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fNoNewlineType$ArgType$$Star1) 
      yyColumn.chunk17.fNoNewlineType$ArgType$$Star1 = pNoNewlineType$ArgType$$Star1$1(yyStart);
    return yyColumn.chunk17.fNoNewlineType$ArgType$$Star1;
  }

  /** Actually parse NoNewlineType.ArgType$$Star1. */
  private Result pNoNewlineType$ArgType$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$Type(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type v$el$2 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineType$ArgType$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Type> v$3 = yyResult.semanticValue();

              yyValue = new Pair<Type>(v$el$2, v$3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal NoNewlineType.ArgType$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$ArgType$$Star2(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fNoNewlineType$ArgType$$Star2) 
      yyColumn.chunk17.fNoNewlineType$ArgType$$Star2 = pNoNewlineType$ArgType$$Star2$1(yyStart);
    return yyColumn.chunk17.fNoNewlineType$ArgType$$Star2;
  }

  /** Actually parse NoNewlineType.ArgType$$Star2. */
  private Result pNoNewlineType$ArgType$$Star2$1(final int yyStart) 
    throws IOException {

    Result            yyResult;
    Pair<KeywordType> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineType$KeywordType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            KeywordType v$el$5 = yyResult.semanticValue();

            yyResult = pNoNewlineType$ArgType$$Star2(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<KeywordType> v$6 = yyResult.semanticValue();

              yyValue = new Pair<KeywordType>(v$el$5, v$6);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.KeywordType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$KeywordType(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk17) yyColumn.chunk17 = new Chunk17();
    if (null == yyColumn.chunk17.fNoNewlineType$KeywordType) 
      yyColumn.chunk17.fNoNewlineType$KeywordType = pNoNewlineType$KeywordType$1(yyStart);
    return yyColumn.chunk17.fNoNewlineType$KeywordType;
  }

  /** Actually parse NoNewlineType.KeywordType. */
  private Result pNoNewlineType$KeywordType$1(final int yyStart) 
    throws IOException {

    Result      yyResult;
    KeywordType yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineType$Type(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type a2 = yyResult.semanticValue();

              yyValue = new KeywordType(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TupleType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TupleType(final int yyStart) 
    throws IOException {

    Result     yyResult;
    TupleType  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineType$Type(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcomma(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineType$TypeList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Type> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      List<Type> ts = FortressUtil.mkList(a1, a2);
                      yyValue = NodeFactory.makeTupleType(createSpan(yyStart,yyCount), ts);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TypeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TypeList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    Pair<Type> yyRepValue1;
    List<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$Type(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineType$Type(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Type v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Type>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Type> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TypeTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TypeTail(final int yyStart) 
    throws IOException {

    Result            yyResult;
    int               yyRepetition1;
    Pair<ExtentRange> yyRepValue1;
    int               yyOption1;
    Indices           yyOpValue1;
    Action<Type>      yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared32(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Indices v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        final Indices a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pclosesquare(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Action<Type>() {
              public Type run(Type base) {
                if (NodeUtil.isExponentiation((Type)base))
                return error((Type)base, "It is a static error if an " +
                "exponentiation or a vector type or an array " +
                "type is immediately followed by a left " +
                "square bracket.");
                return NodeFactory.makeArrayType(createSpan(yyStart,yyCount),
                (Type)base, Option.wrap(a1));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pIntExpr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final IntExpr a1 = yyResult.semanticValue();

        yyValue = new Action<Type>() {
          public Type run(Type base) {
            if (NodeUtil.isExponentiation((Type)base) ||
            NodeUtil.isExponentiation(a1))
            return error((Type)base, "It is a static error if an " +
            "exponentiation is immediately followed by " +
            "an exponentiation.");
            if (base instanceof DimExpr) {
              return new ExponentDim(createSpan(yyStart,yyCount),
              (DimExpr)base, a1);
            } else { // !(base instanceof DimExpr)
              return new ExponentType(createSpan(yyStart,yyCount),
              (Type)base, a1);
            }
        }};

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = popenparen(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared11(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final ExtentRange a1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = pw(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcross(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = p$$Shared11(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      final ExtentRange v$el$1 = yyResult.semanticValue();

                      yyRepetition1 = yyResult.index;
                      yyRepValue1   = 
                        new Pair<ExtentRange>(v$el$1, yyRepValue1);
                      continue;
                    }
                  }
                }
              }
              break;
            }
            { // Start scope for a2s.
              final Pair<ExtentRange> a2s = yyRepValue1.reverse();

              yyResult = pw(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = new Action<Type>() {
                    public Type run(Type base) {
                      if (NodeUtil.isExponentiation((Type)base))
                      return error((Type)base, "It is a static error if an " +
                      "exponentiation is immediately followed by " +
                      "an exponentiation.");
                      return NodeFactory.makeMatrixType(createSpan(yyStart,yyCount),
                      (Type)base,a1,a2s.list());
                  }};

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } // End scope for a2s.
          }
        }
      }
    }

    // Alternative 3.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineType$OpType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final PureList<PostfixOpExpr> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = new Action<Type>() {
                public Type run(Type base) {
                  DimExpr dim = TypeResolver.resolveOpsDim(a1);
                  return new TaggedDimType(createSpan(yyStart,yyCount), (Type)base,
                  NodeFactory.makeInParentheses(dim),
                  Option.<Expr>none());
              }};

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Id a1 = yyResult.semanticValue();

      yyValue = new Action<Type>() {
        public Type run(Type base) {
          Span span = a1.getSpan();
          DimRef dim = new DimRef(span,
          NodeFactory.makeQualifiedIdName(span,a1));
          return new TaggedDimType(createSpan(yyStart,yyCount), (Type)base,
          dim, Option.<Expr>none());
      }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TraitType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TraitType(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fNoNewlineType$TraitType) 
      yyColumn.chunk18.fNoNewlineType$TraitType = pNoNewlineType$TraitType$1(yyStart);
    return yyColumn.chunk18.fNoNewlineType$TraitType;
  }

  /** Actually parse NoNewlineType.TraitType. */
  private Result pNoNewlineType$TraitType$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    TraitType  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$TraitTypeFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type seed = yyResult.semanticValue();

      yyResult = p$$Shared59(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Type>> list = yyResult.semanticValue();

        yyValue = (TraitType)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.TraitTypeFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType$TraitTypeFront(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineType$ParenthesizedType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineType$ArgType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = p$$Shared9(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineType.NoNewlineType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineType(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fNoNewlineType) 
      yyColumn.chunk18.fNoNewlineType = pNoNewlineType$1(yyStart);
    return yyColumn.chunk18.fNoNewlineType;
  }

  /** Actually parse NoNewlineType.NoNewlineType. */
  private Result pNoNewlineType$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyOption1;
    Expr       yyOpValue1;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pone(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pNoNewlineType$TypePrimary(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PostfixOpExpr> a1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pin(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineExpr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$1 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$1;
              }
            }
          }
        }
        { // Start scope for a2.
          Expr a2 = yyOpValue1;

          Type ty = TypeResolver.resolveOps(a1);
          if (a2 == null)
          yyValue = ty;
          else {
            if (ty instanceof TaggedDimType) {
              TaggedDimType _ty = (TaggedDimType)ty;
              yyValue = new TaggedDimType(_ty.getSpan(), _ty.getType(),
              _ty.getDim(), Option.some(a2));
            } else {
              yyValue = error(ty, "A dimension type is expected.");
            }
          }

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }
    } else {
      yyError = yyError.select("no newline type expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Expr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$Expr(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fExpression$Expr) 
      yyColumn.chunk18.fExpression$Expr = pExpression$Expr$1(yyStart);
    return yyColumn.chunk18.fExpression$Expr;
  }

  /** Actually parse Expression.Expr. */
  private Result pExpression$Expr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$ExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr seed = yyResult.semanticValue();

      yyResult = pExpression$Expr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> list = yyResult.semanticValue();

        yyValue = (Expr)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Expression.Expr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$Expr$$Star1(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fExpression$Expr$$Star1) 
      yyColumn.chunk18.fExpression$Expr$$Star1 = pExpression$Expr$$Star1$1(yyStart);
    return yyColumn.chunk18.fExpression$Expr$$Star1;
  }

  /** Actually parse Expression.Expr$$Star1. */
  private Result pExpression$Expr$$Star1$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    Pair<Action<Expr>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared35(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Expr> v$el$1 = yyResult.semanticValue();

      yyResult = pExpression$Expr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.ExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$ExprFront(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$AssignExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExpression$OpExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDelimitedExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Flow>.

    yyResult = pExpression$FlowExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Fn>.

    yyResult = pfn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pParameter$ValParam(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIsType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type v$el$5 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$5;
            }
          }
          { // Start scope for a2.
            Type a2 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pThrows(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<TraitType> v$el$6 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$6;
              }
            }
            { // Start scope for a3.
              List<TraitType> a3 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pmatch(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pExpression$Expr(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Expr a4 = yyResult.semanticValue();

                      Option<Type> ty_opt = Option.wrap(a2);
                      Option<List<TraitType>> tys = Option.wrap(a3);
                      yyValue = ExprFactory.makeFnExpr(createSpan(yyStart,yyCount), a1, ty_opt,
                      tys, a4);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            } // End scope for a3.
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared35.
   * This nonterminal represents the duplicate productions 
   * Expression.ExprTail and NoSpaceExpr.ExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared35(final int yyStart) throws IOException {
    Result       yyResult;
    Action<Expr> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pas(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pType$Type(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Type a1 = yyResult.semanticValue();

            yyValue = new Action<Expr>() {
              public Expr run(Expr base) {
                return new AsExpr(createSpan(yyStart,yyCount), false, (Expr)base,
                a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pasif(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pType$Type(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Type a1 = yyResult.semanticValue();

            yyValue = new Action<Expr>() {
              public Expr run(Expr base) {
                return new AsIfExpr(createSpan(yyStart,yyCount), false,
                (Expr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.AssignExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$AssignExpr(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fExpression$AssignExpr) 
      yyColumn.chunk18.fExpression$AssignExpr = pExpression$AssignExpr$1(yyStart);
    return yyColumn.chunk18.fExpression$AssignExpr;
  }

  /** Actually parse Expression.AssignExpr. */
  private Result pExpression$AssignExpr$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared47(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<LHS> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAssignOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Option<Op> a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              yyValue = new Assignment(createSpan(yyStart,yyCount), false, a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared47.
   * This nonterminal represents the duplicate productions 
   * Expression.AssignLefts, NoNewlineExpr.AssignLefts, 
   * and NoSpaceExpr.AssignLefts.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared47(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.f$$Shared47) 
      yyColumn.chunk18.f$$Shared47 = p$$Shared47$1(yyStart);
    return yyColumn.chunk18.f$$Shared47;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared47. */
  private Result p$$Shared47$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<LHS>  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared42(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          LHS a1 = yyResult.semanticValue();

          yyResult = p$$Shared47$$Star1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<LHS> a2s = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = FortressUtil.mkList(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = p$$Shared42(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LHS a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.$$Shared47$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared47$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.f$$Shared47$$Star1) 
      yyColumn.chunk18.f$$Shared47$$Star1 = p$$Shared47$$Star1$1(yyStart);
    return yyColumn.chunk18.f$$Shared47$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared47$$Star1. */
  private Result p$$Shared47$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<LHS>  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared42(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            LHS v$el$1 = yyResult.semanticValue();

            yyResult = p$$Shared47$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<LHS> v$2 = yyResult.semanticValue();

              yyValue = new Pair<LHS>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared42.
   * This nonterminal represents the duplicate productions 
   * Expression.AssignLeft, NoNewlineExpr.AssignLeft, 
   * and NoSpaceExpr.AssignLeft.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared42(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.f$$Shared42) 
      yyColumn.chunk18.f$$Shared42 = p$$Shared42$1(yyStart);
    return yyColumn.chunk18.f$$Shared42;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared42. */
  private Result p$$Shared42$1(final int yyStart) throws IOException {
    Result     yyResult;
    LHS        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared37(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr seed = yyResult.semanticValue();

      yyResult = p$$Shared42$$Plus1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> list = yyResult.semanticValue();

        Expr left = (Expr)apply(list, seed);
        if (left instanceof LHS) yyValue = (LHS)left;
        else yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyValue = new VarRef(createSpan(yyStart,yyCount), false, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.$$Shared42$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared42$$Plus1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.f$$Shared42$$Plus1) 
      yyColumn.chunk18.f$$Shared42$$Plus1 = p$$Shared42$$Plus1$1(yyStart);
    return yyColumn.chunk18.f$$Shared42$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared42$$Plus1. */
  private Result p$$Shared42$$Plus1$1(final int yyStart) throws IOException {
    Result             yyResult;
    Pair<Action<Expr>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared36(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Expr> v$el$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = p$$Shared42$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Action<Expr>>(v$el$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared36.
   * This nonterminal represents the duplicate productions 
   * Expression.AssignLeftTail, NoNewlineExpr.AssignLeftTail, 
   * and NoSpaceExpr.AssignLeftTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared36(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    List<Expr>   yyOpValue1;
    Action<Expr> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExprList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<Expr> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        final List<Expr> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pRightEncloser(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Op a3 = yyResult.semanticValue();

            yyValue = new Action<Expr>() {
              public Expr run(Expr base) {
                Span span = createSpan(yyStart,yyCount);
                List<Expr> es;
                if (a2 == null) es = FortressUtil.emptyExprs();
                else            es = a2;
                Enclosing op = new Enclosing(FortressUtil.spanTwo(a1,a3),a1,a3);
                return ExprFactory.makeSubscriptExpr(span,base,es,Option.some(op));
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pdot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Id a1 = yyResult.semanticValue();

        yyValue = new Action<Expr>() {
          public Expr run(Expr base) {
            return new FieldRef(createSpan(yyStart,yyCount), false, base, a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.OpExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$OpExpr(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk18) yyColumn.chunk18 = new Chunk18();
    if (null == yyColumn.chunk18.fExpression$OpExpr) 
      yyColumn.chunk18.fExpression$OpExpr = pExpression$OpExpr$1(yyStart);
    return yyColumn.chunk18.fExpression$OpExpr;
  }

  /** Actually parse Expression.OpExpr. */
  private Result pExpression$OpExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$OpExprNoEnc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      yyValue = Resolver.resolveOps(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExpression$OpExprLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      yyValue = Resolver.resolveOps(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      PrecedenceOpExpr e =
      new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
      yyValue = Resolver.resolveOps(PureList.make(e));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.OpExprNoEnc.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$OpExprNoEnc(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fExpression$OpExprNoEnc) 
      yyColumn.chunk19.fExpression$OpExprNoEnc = pExpression$OpExprNoEnc$1(yyStart);
    return yyColumn.chunk19.fExpression$OpExprNoEnc;
  }

  /** Actually parse Expression.OpExprNoEnc. */
  private Result pExpression$OpExprNoEnc$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$OpExprPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExpression$OpExprPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
      yyValue = PureList.make(e);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.TightInfixRight.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$TightInfixRight(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExpression$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pExpression$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$LooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$LeftLooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 4.

      yyValue = PureList.make((PrecedenceOpExpr)new Right(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.LeftLooseInfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$LeftLooseInfix(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fExpression$LeftLooseInfix) 
      yyColumn.chunk19.fExpression$LeftLooseInfix = pExpression$LeftLooseInfix$1(yyStart);
    return yyColumn.chunk19.fExpression$LeftLooseInfix;
  }

  /** Actually parse Expression.LeftLooseInfix. */
  private Result pExpression$LeftLooseInfix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$OpExprLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pwr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$OpExprPrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$OpExprLeftEncloser(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.OpExprLeftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$OpExprLeftEncloser(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fExpression$OpExprLeftEncloser) 
      yyColumn.chunk19.fExpression$OpExprLeftEncloser = pExpression$OpExprLeftEncloser$1(yyStart);
    return yyColumn.chunk19.fExpression$OpExprLeftEncloser;
  }

  /** Actually parse Expression.OpExprLeftEncloser. */
  private Result pExpression$OpExprLeftEncloser$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pExpression$OpExprNoEnc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new Left(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.OpExprPrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$OpExprPrimary(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fExpression$OpExprPrimary) 
      yyColumn.chunk19.fExpression$OpExprPrimary = pExpression$OpExprPrimary$1(yyStart);
    return yyColumn.chunk19.fExpression$OpExprPrimary;
  }

  /** Actually parse Expression.OpExprPrimary. */
  private Result pExpression$OpExprPrimary$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared52(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<Expr> a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExpression$TightInfixPostfix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pExpression$TightInfixRight(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$LooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$LeftLooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 4.

      yyValue =
      PureList.make((PrecedenceOpExpr)new RealExpr(FortressUtil.buildPrimary(a1)));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.OpExprPrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$OpExprPrefix(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fExpression$OpExprPrefix) 
      yyColumn.chunk19.fExpression$OpExprPrefix = pExpression$OpExprPrefix$1(yyStart);
    return yyColumn.chunk19.fExpression$OpExprPrefix;
  }

  /** Actually parse Expression.OpExprPrefix. */
  private Result pExpression$OpExprPrefix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExpression$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pExpression$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pExpression$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$OpExprLeftEncloser(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.TightInfixPostfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$TightInfixPostfix(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExpression$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pExpression$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pExpression$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$OpExprLeftEncloser(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 5.

      yyValue = PureList.make((PrecedenceOpExpr)new Postfix(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.LooseInfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$LooseInfix(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.fExpression$LooseInfix) 
      yyColumn.chunk19.fExpression$LooseInfix = pExpression$LooseInfix$1(yyStart);
    return yyColumn.chunk19.fExpression$LooseInfix;
  }

  /** Actually parse Expression.LooseInfix. */
  private Result pExpression$LooseInfix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pwr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$OpExprPrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pExpression$OpExprPrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pExpression$OpExprLeftEncloser(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared52.
   * This nonterminal represents the duplicate productions 
   * Expression.Primary, NoNewlineExpr.Primary, and NoSpaceExpr.Primary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared52(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.f$$Shared52) 
      yyColumn.chunk19.f$$Shared52 = p$$Shared52$1(yyStart);
    return yyColumn.chunk19.f$$Shared52;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared52. */
  private Result p$$Shared52$1(final int yyStart) throws IOException {
    Result         yyResult;
    PureList<Expr> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared52$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expr a1 = yyResult.semanticValue();

      yyValue = PureList.make(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.$$Shared52$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared52$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared50(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = p$$Shared51(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared50.
   * This nonterminal represents the duplicate productions 
   * Expression.LeftAssociatedPrimary, NoNewlineExpr.LeftAssociatedPrimary, 
   * and NoSpaceExpr.LeftAssociatedPrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared50(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    boolean            yyRepeated1;
    Pair<Action<Expr>> yyRepValue1;
    Expr               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared22(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final List<Id> a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pStaticArgs(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<StaticArg> a2 = yyResult.semanticValue();

        yyResult = p$$Shared25(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Expr a3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = p$$Shared38(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Action<Expr> v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Action<Expr>>(v$el$1, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for a4s.
            final Pair<Action<Expr>> a4s = yyRepValue1.reverse();

            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = p$$Shared48(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Action<Expr> v$el$2 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Action<Expr>>(v$el$2, yyRepValue1);
                continue;
              }
              break;
            }
            { // Start scope for a5s.
              final Pair<Action<Expr>> a5s = yyRepValue1.reverse();

              Id last = IterUtil.last(a1);
              Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
              Span span = FortressUtil.spanTwo(receiver,a3);
              Expr e1 = new MethodInvocation(span, receiver, last, a2, a3);
              Expr e2 = (Expr)apply(a4s, e1);
              yyValue = (Expr)apply(a5s, e2);

              return new SemanticValue(yyValue, yyRepetition1, yyError);
            } // End scope for a5s.
          } // End scope for a4s.
        }
      }

      // Nested alternative 2.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = p$$Shared24(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Action<Expr> v$el$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<Action<Expr>>(v$el$3, yyRepValue1);
          continue;
        }
        break;
      }

      if (yyRepeated1) {
        final Pair<Action<Expr>> a2s = yyRepValue1.reverse();

        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = p$$Shared38(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Action<Expr> v$el$4 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Action<Expr>>(v$el$4, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for a3s.
          final Pair<Action<Expr>> a3s = yyRepValue1.reverse();

          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = p$$Shared48(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Action<Expr> v$el$5 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Action<Expr>>(v$el$5, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for a4s.
            final Pair<Action<Expr>> a4s = yyRepValue1.reverse();

            Id last = IterUtil.last(a1);
            Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
            Span span = FortressUtil.spanTwo(receiver,last);
            Expr e1 = new FieldRef(span, receiver, last);
            Expr e2 = (Expr)apply(a2s, e1);
            Expr e3 = (Expr)apply(a3s, e2);
            yyValue = (Expr)apply(a4s, e3);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for a4s.
        } // End scope for a3s.
      }

      // Nested alternative 3.

      yyResult = p$$Shared25(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Expr a2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = false;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = p$$Shared38(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Action<Expr> v$el$6 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepeated1   = true;
            yyRepValue1   = new Pair<Action<Expr>>(v$el$6, yyRepValue1);
            continue;
          }
          break;
        }

        if (yyRepeated1) {
          final Pair<Action<Expr>> a3s = yyRepValue1.reverse();

          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = p$$Shared48(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Action<Expr> v$el$7 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Action<Expr>>(v$el$7, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for a4s.
            final Pair<Action<Expr>> a4s = yyRepValue1.reverse();

            Id last = IterUtil.last(a1);
            Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
            Span span = FortressUtil.spanTwo(receiver,a2);
            Expr e1 = new MethodInvocation(span, receiver, last, a2);
            Expr e2 = (Expr)apply(a3s, e1);
            yyValue = (Expr)apply(a4s, e2);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for a4s.
        }
      }

      // Nested alternative 4.

      yyRepetition1 = yyChoice1;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = p$$Shared38(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Action<Expr> v$el$8 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Expr>>(v$el$8, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        final Pair<Action<Expr>> a2s = yyRepValue1.reverse();

        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = p$$Shared48(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Action<Expr> v$el$9 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Action<Expr>>(v$el$9, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for a3s.
          final Pair<Action<Expr>> a3s = yyRepValue1.reverse();

          Id last = IterUtil.last(a1);
          Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
          Span span = FortressUtil.spanTwo(receiver,last);
          Expr e1 = new FieldRef(span, receiver, last);
          Expr e2 = (Expr)apply(a2s, e1);
          yyValue = (Expr)apply(a3s, e2);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for a3s.
      } // End scope for a2s.
    }

    // Alternative 2.

    yyResult = p$$Shared37(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = p$$Shared24(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Action<Expr> v$el$10 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Expr>>(v$el$10, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        final Pair<Action<Expr>> a2s = yyRepValue1.reverse();

        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = p$$Shared38(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Action<Expr> v$el$11 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Action<Expr>>(v$el$11, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for a3s.
          final Pair<Action<Expr>> a3s = yyRepValue1.reverse();

          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = p$$Shared48(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Action<Expr> v$el$12 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepeated1   = true;
              yyRepValue1   = new Pair<Action<Expr>>(v$el$12, yyRepValue1);
              continue;
            }
            break;
          }

          if (yyRepeated1) {
            final Pair<Action<Expr>> a4s = yyRepValue1.reverse();

            Expr e1 = (Expr)apply(a2s, a1);
            Expr e2 = (Expr)apply(a3s, e1);
            yyValue = (Expr)apply(a4s, e2);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          }
        } // End scope for a3s.
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared22.
   * This nonterminal represents the duplicate productions 
   * Expression.DottedIdChain, NoNewlineExpr.DottedIdChain, 
   * and NoSpaceExpr.DottedIdChain.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared22(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Id>   yyRepValue1;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pdot(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepeated1   = true;
              yyRepValue1   = new Pair<Id>(v$el$1, yyRepValue1);
              continue;
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<Id> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared51.
   * This nonterminal represents the duplicate productions 
   * Expression.MathPrimary, NoNewlineExpr.MathPrimary, 
   * and NoSpaceExpr.MathPrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared51(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyRepetition1;
    Pair<MathItem> yyRepValue1;
    Expr           yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared37(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = p$$Shared49(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final MathItem v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<MathItem>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        final Pair<MathItem> a2s = yyRepValue1.reverse();

        Span span = createSpan(yyStart,yyCount);
        List<MathItem> mis = a2s.list();
        if (mis.size() == 0) {
          yyValue = a1;
        } else if (mis.size() == 1) {
          yyValue = ExprFactory.simplifyMathPrimary(span, a1, mis.get(0));
        } else { // mis.size() > 1
          yyValue = new MathPrimary(span, a1, mis);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared37.
   * This nonterminal represents the duplicate productions 
   * Expression.PrimaryFront, NoNewlineExpr.PrimaryFront, 
   * and NoSpaceExpr.PrimaryFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared37(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.f$$Shared37) 
      yyColumn.chunk19.f$$Shared37 = p$$Shared37$1(yyStart);
    return yyColumn.chunk19.f$$Shared37;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared37. */
  private Result p$$Shared37$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Expr> yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArrayExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMapExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pComprehension(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExprList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Expr> v$el$7 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$7;
        }
      }
      { // Start scope for a2.
        List<Expr> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pRightEncloser(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Op a3 = yyResult.semanticValue();

            if (a2 == null) a2 = FortressUtil.emptyExprs();
            yyValue = ASTUtil.enclosing(FortressUtil.spanTwo(a1, a3), a1, a2, a3);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Alternative 5.

    yyResult = p$$Shared25(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = p$$Shared23(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pself(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeVarRef(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared23.
   * This nonterminal represents the duplicate productions 
   * Expression.VarOrFnRef, NoNewlineExpr.VarOrFnRef, 
   * and NoSpaceExpr.VarOrFnRef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared23(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.f$$Shared23) 
      yyColumn.chunk19.f$$Shared23 = p$$Shared23$1(yyStart);
    return yyColumn.chunk19.f$$Shared23;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared23. */
  private Result p$$Shared23$1(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    List<StaticArg> yyOpValue1;
    Expr            yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pStaticArgs(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<StaticArg> v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for a2.
        List<StaticArg> a2 = yyOpValue1;

        QualifiedIdName name = NodeFactory.makeQualifiedIdName(a1.getSpan(), a1);
        if (a2 == null)
        yyValue = new VarRef(createSpan(yyStart,yyCount),false,name);
        else yyValue = ExprFactory.makeFnRef(createSpan(yyStart,yyCount),name,a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared24.
   * This nonterminal represents the duplicate productions 
   * Expression.SubscriptingLeft, NoNewlineExpr.SubscriptingLeft, 
   * and NoSpaceExpr.SubscriptingLeft.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared24(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    List<Expr>   yyOpValue1;
    Action<Expr> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared24$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExprList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<Expr> v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
      }
      { // Start scope for a2.
        final List<Expr> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared24$$Choice2(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final String a3 = yyResult.semanticValue();

            yyValue = new Action<Expr>() {
              public Expr run(Expr base) {
                if (PrecedenceMap.ONLY.matchedBrackets(a1, a3)) {
                  Span span = createSpan(yyStart,yyCount);
                  Span spanOpen = createSpan(yyStart, yyStart+1);
                  Span spanClose = createSpan(yyCount-1,1);
                  return FortressUtil.makeSubscripting(span,spanOpen,spanClose,
                  a1, a3, base, a2);
                } else return error("Mismatched subscripting operator: " + a1 +
                " and " + a3);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExprList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final List<Expr> v$el$6 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$6;
        }
      }
      { // Start scope for a2.
        final List<Expr> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pRightEncloser(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Op a3 = yyResult.semanticValue();

            yyValue = new Action<Expr>() {
              public Expr run(Expr base) {
                Span span = createSpan(yyStart,yyCount);
                return FortressUtil.makeSubscripting(span, base, a1, a3, a2);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.$$Shared24$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared24$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.$$Shared24$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared24$$Choice2(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pclosesquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pclosecurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared38.
   * This nonterminal represents the duplicate productions 
   * Expression.ParenthesisDelimitedLeft, 
   * NoNewlineExpr.ParenthesisDelimitedLeft, 
   * and NoSpaceExpr.ParenthesisDelimitedLeft.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared38(final int yyStart) throws IOException {
    Result       yyResult;
    Action<Expr> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared25(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Expr a1 = yyResult.semanticValue();

      yyValue = new Action<Expr>() {
        public Expr run(Expr base) {
          List<Expr> exprs = FortressUtil.mkList(base, a1);
          return new TightJuxt(FortressUtil.spanTwo(base, a1), false, exprs);
      }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared25.
   * This nonterminal represents the duplicate productions 
   * Expression.ParenthesisDelimited, NoNewlineExpr.ParenthesisDelimited, 
   * and NoSpaceExpr.ParenthesisDelimited.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared25(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk19) yyColumn.chunk19 = new Chunk19();
    if (null == yyColumn.chunk19.f$$Shared25) 
      yyColumn.chunk19.f$$Shared25 = p$$Shared25$1(yyStart);
    return yyColumn.chunk19.f$$Shared25;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared25. */
  private Result p$$Shared25$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParenthesized(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pArgExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcloseparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = ExprFactory.makeVoidLiteralExpr(createSpan(yyStart,yyCount));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared48.
   * This nonterminal represents the duplicate productions 
   * Expression.Selector, NoNewlineExpr.Selector, and NoSpaceExpr.Selector.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared48(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Expr>> yyRepValue1;
    int                yyOption1;
    List<StaticArg>    yyOpValue1;
    Action<Expr>       yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pdot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Id a1 = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyOption1  = yyChoice1;
          yyOpValue1 = null;

          yyResult = pStaticArgs(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final List<StaticArg> v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for a2.
            final List<StaticArg> a2 = yyOpValue1;

            yyResult = p$$Shared25(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Expr a3 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = p$$Shared38(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Action<Expr> v$el$2 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = new Pair<Action<Expr>>(v$el$2, yyRepValue1);
                  continue;
                }
                break;
              }
              { // Start scope for a4s.
                final Pair<Action<Expr>> a4s = yyRepValue1.reverse();

                yyValue = new Action<Expr>() {
                  public Expr run(Expr base) {
                    List<StaticArg> sargs;
                    if (a2 == null) sargs = Collections.<StaticArg>emptyList();
                    else            sargs = a2;
                    Expr mtdInv = new MethodInvocation(FortressUtil.spanTwo(base, a3),
                    false, base, a1, sargs, a3);
                    return (Expr)apply(a4s, mtdInv);
                }};

                return new SemanticValue(yyValue, yyRepetition1, yyError);
              } // End scope for a4s.
            }
          } // End scope for a2.

          // Nested alternative 2.

          yyRepetition1 = yyChoice1;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = p$$Shared24(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Action<Expr> v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Action<Expr>>(v$el$1, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for a2s.
            final Pair<Action<Expr>> a2s = yyRepValue1.reverse();

            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = p$$Shared38(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Action<Expr> v$el$2 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Action<Expr>>(v$el$2, yyRepValue1);
                continue;
              }
              break;
            }
            { // Start scope for a3s.
              final Pair<Action<Expr>> a3s = yyRepValue1.reverse();

              yyValue = new Action<Expr>() {
                public Expr run(Expr base) {
                  Expr fldSel = new FieldRef(createSpan(yyStart,yyCount), false,
                  base, a1);
                  return (Expr)apply(a3s, (Expr)apply(a2s, fldSel));
              }};

              return new SemanticValue(yyValue, yyRepetition1, yyError);
            } // End scope for a3s.
          } // End scope for a2s.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared49.
   * This nonterminal represents the duplicate productions 
   * Expression.MathItem, NoNewlineExpr.MathItem, and NoSpaceExpr.MathItem.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared49(final int yyStart) throws IOException {
    Result     yyResult;
    MathItem   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared26(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = p$$Shared45(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = p$$Shared25(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyValue = new ParenthesisDelimitedMI(a1.getSpan(), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = p$$Shared23(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyValue = new NonParenthesisDelimitedMI(a1.getSpan(), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyValue = new NonParenthesisDelimitedMI(a1.getSpan(), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pself(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      Expr expr = ExprFactory.makeVarRef(span, a1);
      yyValue = new NonParenthesisDelimitedMI(span, expr);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared26.
   * This nonterminal represents the duplicate productions 
   * Expression.Subscripting, NoNewlineExpr.Subscripting, 
   * and NoSpaceExpr.Subscripting.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared26(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    List<Expr>     yyOpValue1;
    SubscriptingMI yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared26$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExprList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Expr> v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
      }
      { // Start scope for a2.
        List<Expr> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared26$$Choice2(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a3 = yyResult.semanticValue();

            if (PrecedenceMap.ONLY.matchedBrackets(a1, a3)) {
              Span span = createSpan(yyStart,yyCount);
              Span spanOpen = createSpan(yyStart, yyStart+1);
              Span spanClose = createSpan(yyCount-1,1);
              Op open  = NodeFactory.makeOpEnclosing(spanOpen, a1);
              Op close = NodeFactory.makeOpEnclosing(spanClose, a3);
              Enclosing op = new Enclosing(FortressUtil.spanTwo(open,close),
              open,close);
              yyValue = new SubscriptingMI(span, op, a2);
            } else return error("Mismatched subscripting operator: " + a1 + " and "
            + a3);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExprList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Expr> v$el$6 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$6;
        }
      }
      { // Start scope for a2.
        List<Expr> a2 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pRightEncloser(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Op a3 = yyResult.semanticValue();

            Span span = createSpan(yyStart,yyCount);
            Enclosing op = new Enclosing(FortressUtil.spanTwo(a1,a3),a1,a3);
            yyValue = new SubscriptingMI(span, op, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.$$Shared26$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared26$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.$$Shared26$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared26$$Choice2(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pclosesquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pclosecurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared45.
   * This nonterminal represents the duplicate productions 
   * Expression.Exponentiation, NoNewlineExpr.Exponentiation, 
   * and NoSpaceExpr.Exponentiation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared45(final int yyStart) throws IOException {
    Result           yyResult;
    ExponentiationMI yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcaret(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = p$$Shared39(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expr a2 = yyResult.semanticValue();

        Span span = createSpan(yyStart,yyCount);
        yyValue = new ExponentiationMI(span, NodeFactory.makeOpInfix(span, a1),
        Option.wrap(a2));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pExponentOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyValue = new ExponentiationMI(a1.getSpan(), a1, Option.<Expr>none());

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared39.
   * This nonterminal represents the duplicate productions 
   * Expression.Exponent, NoNewlineExpr.Exponent, and NoSpaceExpr.Exponent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared39(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeVarRef(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = p$$Shared25(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pself(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeVarRef(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.FlowExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$FlowExpr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        Id a1 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pwith(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExpression$Expr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
          }
        }
        { // Start scope for a2.
          Expr a2 = cast(yyOpValue1);

          Option<Id> name = (a1 == null) ? Option.<Id>none() : Option.some(a1);
          Option<Expr> expr = Option.wrap(a2);
          yyValue = new Exit(createSpan(yyStart,yyCount), false, name, expr);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pAccumulator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pStaticArgs(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<StaticArg> v$el$3 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$3;
      }
      { // Start scope for a2.
        List<StaticArg> a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = popensquare(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExpression$GeneratorClauseList(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<GeneratorClause> v$el$4 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pclosesquare(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$4;
                  }
                }
              }
            }
          }
        }
        { // Start scope for a3.
          List<GeneratorClause> a3 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a4 = yyResult.semanticValue();

              if (a3 == null) a3 = Collections.<GeneratorClause>emptyList();
              if (a2 == null) a2 = Collections.<StaticArg>emptyList();
              yyValue = new Accumulator(createSpan(yyStart,yyCount), a2, a1, a3, a4);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a3.
      } // End scope for a2.
    }

    // Alternative 3.

    yyResult = patomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$AtomicBack(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = new AtomicExpr(createSpan(yyStart,yyCount), false, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyResult = ptryatomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$AtomicBack(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = new TryAtomicExpr(createSpan(yyStart,yyCount), false, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = pspawn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = new Spawn(createSpan(yyStart,yyCount), false, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 6.

    yyResult = pthrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = new Throw(createSpan(yyStart,yyCount), false, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.AtomicBack.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$AtomicBack(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fExpression$AtomicBack) 
      yyColumn.chunk20.fExpression$AtomicBack = pExpression$AtomicBack$1(yyStart);
    return yyColumn.chunk20.fExpression$AtomicBack;
  }

  /** Actually parse Expression.AtomicBack. */
  private Result pExpression$AtomicBack$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$AssignExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExpression$OpExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDelimitedExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.GeneratorClauseList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$GeneratorClauseList(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fExpression$GeneratorClauseList) 
      yyColumn.chunk20.fExpression$GeneratorClauseList = pExpression$GeneratorClauseList$1(yyStart);
    return yyColumn.chunk20.fExpression$GeneratorClauseList;
  }

  /** Actually parse Expression.GeneratorClauseList. */
  private Result pExpression$GeneratorClauseList$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    List<GeneratorClause> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$GeneratorBinding(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      GeneratorClause a1 = yyResult.semanticValue();

      yyResult = pExpression$GeneratorClauseList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<GeneratorClause> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Expression.GeneratorClauseList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$GeneratorClauseList$$Star1(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fExpression$GeneratorClauseList$$Star1) 
      yyColumn.chunk20.fExpression$GeneratorClauseList$$Star1 = pExpression$GeneratorClauseList$$Star1$1(yyStart);
    return yyColumn.chunk20.fExpression$GeneratorClauseList$$Star1;
  }

  /** Actually parse Expression.GeneratorClauseList$$Star1. */
  private Result pExpression$GeneratorClauseList$$Star1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<GeneratorClause> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression$GeneratorClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            GeneratorClause v$el$1 = yyResult.semanticValue();

            yyResult = pExpression$GeneratorClauseList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<GeneratorClause> v$2 = yyResult.semanticValue();

              yyValue = new Pair<GeneratorClause>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.GeneratorBinding.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$GeneratorBinding(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fExpression$GeneratorBinding) 
      yyColumn.chunk20.fExpression$GeneratorBinding = pExpression$GeneratorBinding$1(yyStart);
    return yyColumn.chunk20.fExpression$GeneratorBinding;
  }

  /** Actually parse Expression.GeneratorBinding. */
  private Result pExpression$GeneratorBinding$1(final int yyStart) 
    throws IOException {

    Result          yyResult;
    GeneratorClause yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindIdOrBindIdTuple(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Id> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pleftarrow(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = ExprFactory.makeGeneratorClause(createSpan(yyStart,yyCount),
              a1,a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.GeneratorClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$GeneratorClause(final int yyStart) 
    throws IOException {

    Result          yyResult;
    GeneratorClause yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$GeneratorBinding(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyValue = new GeneratorClause(createSpan(yyStart,yyCount),
      Collections.<Id>emptyList(), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.DelimitedExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDelimitedExpr(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fDelimitedExpr) 
      yyColumn.chunk20.fDelimitedExpr = pDelimitedExpr$1(yyStart);
    return yyColumn.chunk20.fDelimitedExpr;
  }

  /** Actually parse DelimitedExpr.DelimitedExpr. */
  private Result pDelimitedExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArgExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pParenthesized(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pobject(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendsWhere(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<TraitTypeWhere> v$el$4 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$4;
        }
      }
      { // Start scope for a1.
        List<TraitTypeWhere> a1 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pGoInAnObject(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Decl> v$el$5 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$5;
          }
        }
        { // Start scope for a2.
          List<Decl> a2 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pend(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              if (a1 == null) a1 = FortressUtil.emptyTraitTypeWheres();
              if (a2 == null) a2 = Collections.<Decl>emptyList();
              yyValue = new ObjectExpr(createSpan(yyStart,yyCount), false, a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a2.
      } // End scope for a1.
    }

    // Alternative 4.

    yyResult = pDo(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = plabel(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Block a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pend(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pId(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Id a3 = yyResult.semanticValue();

                      if (!a1.getText().equals(a3.getText()))
                      error(a1, "Mismatched identifiers for label expressions.");
                      yyValue = new Label(createSpan(yyStart,yyCount), false, a1, a2);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 6.

    yyResult = pwhile(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDo(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Do a2 = yyResult.semanticValue();

              yyValue = new While(createSpan(yyStart,yyCount), false, a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 7.

    yyResult = pfor(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$GeneratorClauseList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<GeneratorClause> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDoFront(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              DoFront a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pend(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = new For(createSpan(yyStart,yyCount), false, a1, a2);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Alternative 8.

    yyResult = pif(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pthen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pBlockElems(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Block a2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pElifs(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<IfClause> v$el$6 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$6;
                    }
                  }
                  { // Start scope for a3.
                    List<IfClause> a3 = cast(yyOpValue1);

                    yyOpValue1 = null;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pElse(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Block v$el$7 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = v$el$7;
                      }
                    }
                    { // Start scope for a4.
                      Block a4 = cast(yyOpValue1);

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pend(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          IfClause ic = new IfClause(FortressUtil.spanTwo(a1,a2), a1, a2);
                          List<IfClause> clauses = FortressUtil.mkList(ic);
                          if (a3 != null) clauses.addAll(a3);
                          Option<Block> elseC = Option.wrap(a4);
                          yyValue = new If(createSpan(yyStart,yyCount), false, clauses, elseC);

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    } // End scope for a4.
                  } // End scope for a3.
                }
              }
            }
          }
        }
      }
    }

    // Alternative 9.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pif(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pthen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pBlockElems(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Block a2 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pElifs(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          List<IfClause> v$el$8 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$8;
                        }
                      }
                      { // Start scope for a3.
                        List<IfClause> a3 = cast(yyOpValue1);

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pElse(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            Block a4 = yyResult.semanticValue();

                            yyOption1  = yyResult.index;

                            yyResult = pw(yyOption1);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pend(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyOption1  = yyResult.index;
                              }
                            }

                            yyResult = pw(yyOption1);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pcloseparen(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                IfClause ic = new IfClause(FortressUtil.spanTwo(a1,a2), a1, a2);
                                List<IfClause> clauses = FortressUtil.mkList(ic);
                                if (a3 != null) clauses.addAll(a3);
                                yyValue = new If(createSpan(yyStart,yyCount),false,clauses,
                                Option.some(a4));

                                return yyResult.createValue(yyValue, yyError);
                              }
                            }
                          }
                        }
                      } // End scope for a3.
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 10.

    yyResult = pcase(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExpression$Expr(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pOp(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Op v$el$9 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$9;
            }
          }
          { // Start scope for a2.
            Op a2 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pof(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pCaseClauses(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<CaseClause> a3 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = null;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pCaseElse(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Block v$el$10 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = v$el$10;
                      }
                    }
                    { // Start scope for a4.
                      Block a4 = cast(yyOpValue1);

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pend(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          Option<Op> compare;
                          if (a2 == null) compare = Option.none();
                          else            compare = Option.some(a2);
                          Option<Block> _else;
                          if (a4 == null)
                          _else = Option.none();
                          else _else = Option.some(a4);
                          yyValue = new CaseExpr(createSpan(yyStart,yyCount), false,
                          Option.some(a1), compare, a3, _else);

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    } // End scope for a4.
                  }
                }
              }
            }
          } // End scope for a2.
        }

        // Nested alternative 2.

        yyResult = pmost(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pOp(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Op a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pof(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pCaseClauses(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<CaseClause> a2 = yyResult.semanticValue();

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pend(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          Option<Op> compare = Option.some(a1);
                          yyValue = new CaseExpr(createSpan(yyStart,yyCount), false,
                          Option.<Expr>none(), compare, a2,
                          Option.<Block>none());

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 11.

    yyResult = ptypecase(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTypecaseBindings(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          com.sun.fortress.useful.Pair<List<Id>,Option<Expr>> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pof(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pTypecaseClauses(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<TypecaseClause> a2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pbr(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pCaseElse(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Block v$el$11 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$11;
                    }
                  }
                  { // Start scope for a3.
                    Block a3 = cast(yyOpValue1);

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pend(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        Option<Block> caseElse = Option.wrap(a3);
                        yyValue = new Typecase(createSpan(yyStart,yyCount), false, a1, a2,
                        caseElse);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  } // End scope for a3.
                }
              }
            }
          }
        }
      }
    }

    // Alternative <TRY>.

    yyResult = ptry(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBlockElems(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Block a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pCatch(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Catch v$el$12 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$12;
            }
          }
          { // Start scope for a2.
            Catch a2 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pforbid(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pTraitTypes(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<TraitType> v$el$13 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$13;
                  }
                }
              }
            }
            { // Start scope for a3.
              List<TraitType> a3 = cast(yyOpValue1);

              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pfinally(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pBlockElems(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Block v$el$14 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$14;
                    }
                  }
                }
              }
              { // Start scope for a4.
                Block a4 = cast(yyOpValue1);

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pend(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    Option<Catch> catch_ = Option.wrap(a2);
                    if (a3 == null) a3 = FortressUtil.emptyTraitTypes();
                    Option<Block> finally_ = Option.wrap(a4);
                    yyValue = new Try(createSpan(yyStart,yyCount), false, a1, catch_, a3,
                    finally_);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for a4.
            } // End scope for a3.
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Do.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDo(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fDo) yyColumn.chunk20.fDo = pDo$1(yyStart);
    return yyColumn.chunk20.fDo;
  }

  /** Actually parse DelimitedExpr.Do. */
  private Result pDo$1(final int yyStart) throws IOException {
    Result     yyResult;
    Do         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDo$$Star1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<DoFront> a1s = yyResult.semanticValue();

      yyResult = pDoFront(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        DoFront a2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pend(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new Do(createSpan(yyStart, yyCount), false,
            FortressUtil.mkList(a1s.list(), a2));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.Do$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDo$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fDo$$Star1) 
      yyColumn.chunk20.fDo$$Star1 = pDo$$Star1$1(yyStart);
    return yyColumn.chunk20.fDo$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.Do$$Star1. */
  private Result pDo$$Star1$1(final int yyStart) throws IOException {
    Result        yyResult;
    Pair<DoFront> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDoFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      DoFront v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = palso(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDo$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<DoFront> v$2 = yyResult.semanticValue();

              yyValue = new Pair<DoFront>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.DoFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDoFront(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fDoFront) 
      yyColumn.chunk20.fDoFront = pDoFront$1(yyStart);
    return yyColumn.chunk20.fDoFront;
  }

  /** Actually parse DelimitedExpr.DoFront. */
  private Result pDoFront$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    DoFront    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pat(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr v$el$1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        }
      }
    }
    { // Start scope for a1.
      Expr a1 = cast(yyOpValue1);

      yyOpValue1 = null;

      yyResult = patomic(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$2 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a2.
        String a2 = cast(yyOpValue1);

        yyResult = pKeyword$do(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Block v$el$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
          }
          { // Start scope for a3.
            Block a3 = cast(yyOpValue1);

            Span span = createSpan(yyStart,yyCount);
            Option<Expr> at = Option.wrap(a1);
            boolean atomic = (a2 == null) ? false : true;
            if (a3 == null) a3 = FortressUtil.doBlock(span);
            yyValue = new DoFront(span, at, atomic, a3);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }
      } // End scope for a2.
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.ArgExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgExpr(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fArgExpr) 
      yyColumn.chunk20.fArgExpr = pArgExpr$1(yyStart);
    return yyColumn.chunk20.fArgExpr;
  }

  /** Actually parse DelimitedExpr.ArgExpr. */
  private Result pArgExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Expr       yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pArgExpr$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Expr> a1s = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyOption1  = yyChoice1;
          yyOpValue1 = null;

          yyResult = pExpression$Expr(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr v$el$4 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcomma(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$4;
                    }
                  }
                }
              }
            }
          }
          { // Start scope for a2.
            Expr a2 = yyOpValue1;

            yyResult = pKeywordExpr(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              KeywordExpr a3 = yyResult.semanticValue();

              yyResult = pArgExpr$$Star2(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Pair<KeywordExpr> a4s = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    List<Expr> es = a1s.list();
                    Option<VarargsExpr> vs = ((a2 != null) ?
                    Option.some(new VarargsExpr(a2.getSpan(), a2)) :
                    Option.<VarargsExpr>none());
                    List<KeywordExpr> ks = new ArrayList<KeywordExpr>();
                    ks.add(a3);
                    for (KeywordExpr b : (List<KeywordExpr>)a4s.list()) {
                      ks.add(b);
                    }
                    yyValue = new ArgExpr(createSpan(yyStart,yyCount), false, es, vs, ks);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          } // End scope for a2.

          // Nested alternative 2.

          yyResult = pExpression$Expr(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pellipses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    Option<VarargsExpr> vs = Option.some(new VarargsExpr(a2.getSpan(), a2));
                    yyValue = new ArgExpr(createSpan(yyStart,yyCount),false,a1s.list(),vs);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pTupleExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.ArgExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgExpr$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk20) yyColumn.chunk20 = new Chunk20();
    if (null == yyColumn.chunk20.fArgExpr$$Star1) 
      yyColumn.chunk20.fArgExpr$$Star1 = pArgExpr$$Star1$1(yyStart);
    return yyColumn.chunk20.fArgExpr$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.ArgExpr$$Star1. */
  private Result pArgExpr$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr v$el$2 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pArgExpr$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Expr> v$3 = yyResult.semanticValue();

              yyValue = new Pair<Expr>(v$el$2, v$3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.ArgExpr$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgExpr$$Star2(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fArgExpr$$Star2) 
      yyColumn.chunk21.fArgExpr$$Star2 = pArgExpr$$Star2$1(yyStart);
    return yyColumn.chunk21.fArgExpr$$Star2;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.ArgExpr$$Star2. */
  private Result pArgExpr$$Star2$1(final int yyStart) throws IOException {
    Result            yyResult;
    Pair<KeywordExpr> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pKeywordExpr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            KeywordExpr v$el$5 = yyResult.semanticValue();

            yyResult = pArgExpr$$Star2(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<KeywordExpr> v$6 = yyResult.semanticValue();

              yyValue = new Pair<KeywordExpr>(v$el$5, v$6);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.TupleExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTupleExpr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Expr> yyRepValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepeated1   = false;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pExpression$Expr(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr v$el$1 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyRepetition1 = yyResult.index;
                  yyRepeated1   = true;
                  yyRepValue1   = new Pair<Expr>(v$el$1, yyRepValue1);
                  continue;
                }
              }
            }
          }
          break;
        }

        if (yyRepeated1) {
          Pair<Expr> a1s = yyRepValue1.reverse();

          yyResult = pExpression$Expr(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                List<Expr> es = FortressUtil.mkList(a1s.list(), a2);
                yyValue = new TupleExpr(createSpan(yyStart,yyCount), false, es);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.KeywordExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pKeywordExpr(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fKeywordExpr) 
      yyColumn.chunk21.fKeywordExpr = pKeywordExpr$1(yyStart);
    return yyColumn.chunk21.fKeywordExpr;
  }

  /** Actually parse DelimitedExpr.KeywordExpr. */
  private Result pKeywordExpr$1(final int yyStart) throws IOException {
    Result      yyResult;
    KeywordExpr yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = new KeywordExpr(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Parenthesized.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParenthesized(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fParenthesized) 
      yyColumn.chunk21.fParenthesized = pParenthesized$1(yyStart);
    return yyColumn.chunk21.fParenthesized;
  }

  /** Actually parse DelimitedExpr.Parenthesized. */
  private Result pParenthesized$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = ExprFactory.makeInParentheses(a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Elifs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElifs(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fElifs) 
      yyColumn.chunk21.fElifs = pElifs$1(yyStart);
    return yyColumn.chunk21.fElifs;
  }

  /** Actually parse DelimitedExpr.Elifs. */
  private Result pElifs$1(final int yyStart) throws IOException {
    Result         yyResult;
    List<IfClause> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pElif(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      IfClause a1 = yyResult.semanticValue();

      yyResult = pElifs$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<IfClause> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.Elifs$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElifs$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fElifs$$Star1) 
      yyColumn.chunk21.fElifs$$Star1 = pElifs$$Star1$1(yyStart);
    return yyColumn.chunk21.fElifs$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.Elifs$$Star1. */
  private Result pElifs$$Star1$1(final int yyStart) throws IOException {
    Result         yyResult;
    Pair<IfClause> yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pElif(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        IfClause v$el$1 = yyResult.semanticValue();

        yyResult = pElifs$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<IfClause> v$2 = yyResult.semanticValue();

          yyValue = new Pair<IfClause>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Elif.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElif(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fElif) 
      yyColumn.chunk21.fElif = pElif$1(yyStart);
    return yyColumn.chunk21.fElif;
  }

  /** Actually parse DelimitedExpr.Elif. */
  private Result pElif$1(final int yyStart) throws IOException {
    Result     yyResult;
    IfClause   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pelif(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pthen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pBlockElems(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Block a2 = yyResult.semanticValue();

                  yyValue = new IfClause(createSpan(yyStart,yyCount), a1, a2);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Else.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElse(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fElse) 
      yyColumn.chunk21.fElse = pElse$1(yyStart);
    return yyColumn.chunk21.fElse;
  }

  /** Actually parse DelimitedExpr.Else. */
  private Result pElse$1(final int yyStart) throws IOException {
    Result     yyResult;
    Block      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pelse(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBlockElems(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.CaseClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseClauses(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fCaseClauses) 
      yyColumn.chunk21.fCaseClauses = pCaseClauses$1(yyStart);
    return yyColumn.chunk21.fCaseClauses;
  }

  /** Actually parse DelimitedExpr.CaseClauses. */
  private Result pCaseClauses$1(final int yyStart) throws IOException {
    Result           yyResult;
    List<CaseClause> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCaseClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      CaseClause a1 = yyResult.semanticValue();

      yyResult = pCaseClauses$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<CaseClause> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.CaseClauses$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseClauses$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fCaseClauses$$Star1) 
      yyColumn.chunk21.fCaseClauses$$Star1 = pCaseClauses$$Star1$1(yyStart);
    return yyColumn.chunk21.fCaseClauses$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.CaseClauses$$Star1. */
  private Result pCaseClauses$$Star1$1(final int yyStart) throws IOException {
    Result           yyResult;
    Pair<CaseClause> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pCaseClause(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        CaseClause v$el$1 = yyResult.semanticValue();

        yyResult = pCaseClauses$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<CaseClause> v$2 = yyResult.semanticValue();

          yyValue = new Pair<CaseClause>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.CaseElse.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseElse(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk21) yyColumn.chunk21 = new Chunk21();
    if (null == yyColumn.chunk21.fCaseElse) 
      yyColumn.chunk21.fCaseElse = pCaseElse$1(yyStart);
    return yyColumn.chunk21.fCaseElse;
  }

  /** Actually parse DelimitedExpr.CaseElse. */
  private Result pCaseElse$1(final int yyStart) throws IOException {
    Result     yyResult;
    Block      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pelse(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmatch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              yyValue = yyResult.semanticValue();

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.TypecaseBindings.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypecaseBindings(final int yyStart) throws IOException {
    Result                                              yyResult;
    int                                                 yyOption1;
    Expr                                                yyOpValue1;
    com.sun.fortress.useful.Pair<List<Id>,Option<Expr>> yyValue;
    ParseError                                          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypecaseVars(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Id> a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        Expr a2 = yyOpValue1;

        yyValue = new com.sun.fortress.useful.Pair(a1, Option.wrap(a2));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.TypecaseVars.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypecaseVars(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Id>   yyRepValue1;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBindId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pBindId(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Id v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = new Pair<Id>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<Id> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = FortressUtil.mkList(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.TypecaseClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypecaseClauses(final int yyStart) throws IOException {
    Result               yyResult;
    int                  yyRepetition1;
    Pair<TypecaseClause> yyRepValue1;
    List<TypecaseClause> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypecaseClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypecaseClause a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pbr(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pTypecaseClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            TypecaseClause v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<TypecaseClause>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<TypecaseClause> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.TypecaseClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypecaseClause(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fTypecaseClause) 
      yyColumn.chunk22.fTypecaseClause = pTypecaseClause$1(yyStart);
    return yyColumn.chunk22.fTypecaseClause;
  }

  /** Actually parse DelimitedExpr.TypecaseClause. */
  private Result pTypecaseClause$1(final int yyStart) throws IOException {
    Result         yyResult;
    TypecaseClause yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypecaseTypes(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Type> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmatch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Block a2 = yyResult.semanticValue();

              yyValue = new TypecaseClause(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.TypecaseTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypecaseTypes(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fTypecaseTypes) 
      yyColumn.chunk22.fTypecaseTypes = pTypecaseTypes$1(yyStart);
    return yyColumn.chunk22.fTypecaseTypes;
  }

  /** Actually parse DelimitedExpr.TypecaseTypes. */
  private Result pTypecaseTypes$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Type> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pType$TypeList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pType$Type(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Catch.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCatch(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fCatch) 
      yyColumn.chunk22.fCatch = pCatch$1(yyStart);
    return yyColumn.chunk22.fCatch;
  }

  /** Actually parse DelimitedExpr.Catch. */
  private Result pCatch$1(final int yyStart) throws IOException {
    Result     yyResult;
    Catch      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcatch(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBindId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pCatchClauses(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<CatchClause> a2 = yyResult.semanticValue();

              yyValue = new Catch(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.CatchClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCatchClauses(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<CatchClause> yyRepValue1;
    List<CatchClause> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCatchClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      CatchClause a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pbr(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pCatchClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            CatchClause v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<CatchClause>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<CatchClause> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.CatchClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCatchClause(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fCatchClause) 
      yyColumn.chunk22.fCatchClause = pCatchClause$1(yyStart);
    return yyColumn.chunk22.fCatchClause;
  }

  /** Actually parse DelimitedExpr.CatchClause. */
  private Result pCatchClause$1(final int yyStart) throws IOException {
    Result      yyResult;
    CatchClause yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType$TraitType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TraitType a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmatch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Block a2 = yyResult.semanticValue();

              yyValue = new CatchClause(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.MapExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMapExpr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<Expr> yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pEntryList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Expr> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<Expr> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pclosecurly(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (a1 == null) a1 = FortressUtil.emptyExprs();
            Op open  = NodeFactory.makeOpEnclosing(createSpan(yyStart,yyStart+1),
            "{|->");
            Op close = NodeFactory.makeOpEnclosing(createSpan(yyCount-1,1), "}");
            yyValue = ASTUtil.enclosing(createSpan(yyStart,yyCount), open, a1, close);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Comprehension.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComprehension(final int yyStart) throws IOException {
    Result                         yyResult;
    int                            yyRepetition1;
    Pair<ArrayComprehensionClause> yyRepValue1;
    int                            yyOption1;
    List<StaticArg>                yyOpValue1;
    FlowExpr                       yyValue;
    ParseError                     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyResult = pBIG(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }
    }
    { // Start scope for nested choice.

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = popensquare(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pStaticArgs(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticArg> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for a1.
          List<StaticArg> a1 = yyOpValue1;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pArrayComprehensionClause(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              ArrayComprehensionClause a2 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = pbr(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pArrayComprehensionClause(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    ArrayComprehensionClause v$el$2 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepValue1   = 
                      new Pair<ArrayComprehensionClause>(v$el$2, yyRepValue1);
                    continue;
                  }
                }
                break;
              }
              { // Start scope for a3s.
                Pair<ArrayComprehensionClause> a3s = yyRepValue1.reverse();

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pclosesquare(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    List<ArrayComprehensionClause> clauses = FortressUtil.mkList(a2,
                    a3s.list());
                    if (a1 == null) a1 = Collections.<StaticArg>emptyList();
                    yyValue = new ArrayComprehension(createSpan(yyStart,yyCount),a1,clauses);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for a3s.
            }
          }
        } // End scope for a1.
      }

      // Nested alternative 2.

      yyResult = popencurly(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pStaticArgs(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticArg> v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
        { // Start scope for a1.
          List<StaticArg> a1 = yyOpValue1;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pEntry(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyResult = pwr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pSymbol$bar(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pwr(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = 
                      pExpression$GeneratorClauseList(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<GeneratorClause> a3 = yyResult.semanticValue();

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pclosecurly(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          Span span = createSpan(yyStart,yyCount);
                          Op open  = NodeFactory.makeOpBig(span, "BIG {|->");
                          Op close = NodeFactory.makeOpBig(span, "BIG }");
                          OpName opr = new Enclosing(span, open, close);
                          if (a1 == null) a1 = Collections.<StaticArg>emptyList();
                          yyValue = new Accumulator(createSpan(yyStart,yyCount), a1, opr, a3, a2);

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } // End scope for a1.
      }

      // Nested alternative 3.

      yyResult = pLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pStaticArgs(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<StaticArg> v$el$4 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$4;
        }
        { // Start scope for a2.
          List<StaticArg> a2 = yyOpValue1;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              yyResult = pwr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pSymbol$bar(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pwr(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = 
                      pExpression$GeneratorClauseList(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<GeneratorClause> a4 = yyResult.semanticValue();

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pRightEncloser(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          Op a5 = yyResult.semanticValue();

                          Span span = createSpan(yyStart,yyCount);
                          Op open  = NodeFactory.makeOpBig(span, "BIG " + a1.getText());
                          Op close = NodeFactory.makeOpBig(span, "BIG " + a5.getText());
                          OpName opr = new Enclosing(span, open, close);
                          if (a2 == null) a2 = Collections.<StaticArg>emptyList();
                          yyValue = new Accumulator(createSpan(yyStart,yyCount), a2, opr, a4, a3);

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } // End scope for a2.
      }
    } // End scope for nested choice.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.mapstoOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmapstoOp(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pmapstoOp$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if ('|' == yyC) {
        yyIndex = yyStart + 1;

        yyC = character(yyIndex);
        if ('-' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('>' == yyC) {
            yyIndex = yyIndex + 1;
            yyValue = "|->";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    } else {
      yyError = yyError.select("mapsto op expected", yyStart);
    }

    // Done.
    yyError = yyError.select("mapsto op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.mapstoOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmapstoOp$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pw(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              final int yyChoice1 = yyResult.index;

              // Nested alternative 1.

              yyResult = pw(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pmapsto(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }

              // Nested alternative 2.

              yyResult = pwr(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pSymbol$bar(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }

              // Nested alternative 3.

              yyResult = pw(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                final int yyChoice2 = yyResult.index;

                // Nested alternative 1.

                yyResult = pclosecurly(yyChoice2);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }

                // Nested alternative 2.

                yyResult = pcomma(yyChoice2);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("mapsto op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.Entry.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEntry(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fEntry) 
      yyColumn.chunk22.fEntry = pEntry$1(yyStart);
    return yyColumn.chunk22.fEntry;
  }

  /** Actually parse DelimitedExpr.Entry. */
  private Result pEntry$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmapsto(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = ExprFactory.makeTuple(a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.ArrayComprehensionLeft.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayComprehensionLeft(final int yyStart) 
    throws IOException {

    Result                                        yyResult;
    com.sun.fortress.useful.Pair<List<Expr>,Expr> yyValue;
    ParseError                                    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdOrInt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmapsto(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              List<Expr> exprs = FortressUtil.mkList(a1);
              yyValue = new com.sun.fortress.useful.Pair<List<Expr>,Expr>(exprs, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdOrInt(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcomma(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pIdOrIntList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Expr> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pmapsto(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pExpression$Expr(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              Expr a3 = yyResult.semanticValue();

                              List<Expr> exprs = FortressUtil.mkList(a1);
                              for (Expr i : a2) {
                                exprs.add(i);
                              }
                              yyValue = new com.sun.fortress.useful.Pair<List<Expr>,Expr>(exprs, a3);

                              return yyResult.createValue(yyValue, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.IdOrInt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdOrInt(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fIdOrInt) 
      yyColumn.chunk22.fIdOrInt = pIdOrInt$1(yyStart);
    return yyColumn.chunk22.fIdOrInt;
  }

  /** Actually parse DelimitedExpr.IdOrInt. */
  private Result pIdOrInt$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeVarRef(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIntLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.IdOrIntList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdOrIntList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Expr> yyRepValue1;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdOrInt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pIdOrInt(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Expr>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Expr> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.ExprList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprList(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fExprList) 
      yyColumn.chunk22.fExprList = pExprList$1(yyStart);
    return yyColumn.chunk22.fExprList;
  }

  /** Actually parse DelimitedExpr.ExprList. */
  private Result pExprList$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pExprList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Expr> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.ExprList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprList$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fExprList$$Star1) 
      yyColumn.chunk22.fExprList$$Star1 = pExprList$$Star1$1(yyStart);
    return yyColumn.chunk22.fExprList$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.ExprList$$Star1. */
  private Result pExprList$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression$Expr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr v$el$1 = yyResult.semanticValue();

            yyResult = pExprList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Expr> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Expr>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal DelimitedExpr.EntryList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEntryList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Expr> yyRepValue1;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEntry(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pEntry(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Expr>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Expr> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.Expr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$Expr(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fNoNewlineExpr$Expr) 
      yyColumn.chunk22.fNoNewlineExpr$Expr = pNoNewlineExpr$Expr$1(yyStart);
    return yyColumn.chunk22.fNoNewlineExpr$Expr;
  }

  /** Actually parse NoNewlineExpr.Expr. */
  private Result pNoNewlineExpr$Expr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$ExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr seed = yyResult.semanticValue();

      yyResult = pNoNewlineExpr$Expr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> list = yyResult.semanticValue();

        yyValue = (Expr)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal NoNewlineExpr.Expr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$Expr$$Star1(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk22) yyColumn.chunk22 = new Chunk22();
    if (null == yyColumn.chunk22.fNoNewlineExpr$Expr$$Star1) 
      yyColumn.chunk22.fNoNewlineExpr$Expr$$Star1 = pNoNewlineExpr$Expr$$Star1$1(yyStart);
    return yyColumn.chunk22.fNoNewlineExpr$Expr$$Star1;
  }

  /** Actually parse NoNewlineExpr.Expr$$Star1. */
  private Result pNoNewlineExpr$Expr$$Star1$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    Pair<Action<Expr>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$ExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Expr> v$el$1 = yyResult.semanticValue();

      yyResult = pNoNewlineExpr$Expr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<Expr>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<Expr>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.ExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$ExprFront(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$AssignExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr$OpExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDelimitedExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Flow>.

    yyResult = pNoNewlineExpr$FlowExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Fn>.

    yyResult = pfn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pParameter$ValParam(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Param> a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIsType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type v$el$5 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$5;
            }
          }
          { // Start scope for a2.
            Type a2 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pThrows(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<TraitType> v$el$6 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$6;
              }
            }
            { // Start scope for a3.
              List<TraitType> a3 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pmatch(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pNoNewlineExpr$Expr(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Expr a4 = yyResult.semanticValue();

                      Option<Type> ty_opt = Option.wrap(a2);
                      Option<List<TraitType>> tys = Option.wrap(a3);
                      yyValue = ExprFactory.makeFnExpr(createSpan(yyStart,yyCount), a1, ty_opt,
                      tys, a4);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            } // End scope for a3.
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.ExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$ExprTail(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Expr> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pas(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Type a1 = yyResult.semanticValue();

            yyValue = new Action<Expr>() {
              public Expr run(Expr base) {
                return new AsExpr(createSpan(yyStart,yyCount), false, (Expr)base,
                a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pasif(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Type a1 = yyResult.semanticValue();

            yyValue = new Action<Expr>() {
              public Expr run(Expr base) {
                return new AsIfExpr(createSpan(yyStart,yyCount), false,
                (Expr)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.AssignExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$AssignExpr(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fNoNewlineExpr$AssignExpr) 
      yyColumn.chunk23.fNoNewlineExpr$AssignExpr = pNoNewlineExpr$AssignExpr$1(yyStart);
    return yyColumn.chunk23.fNoNewlineExpr$AssignExpr;
  }

  /** Actually parse NoNewlineExpr.AssignExpr. */
  private Result pNoNewlineExpr$AssignExpr$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared47(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<LHS> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAssignOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Option<Op> a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              yyValue = new Assignment(createSpan(yyStart,yyCount), false, a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.OpExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$OpExpr(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fNoNewlineExpr$OpExpr) 
      yyColumn.chunk23.fNoNewlineExpr$OpExpr = pNoNewlineExpr$OpExpr$1(yyStart);
    return yyColumn.chunk23.fNoNewlineExpr$OpExpr;
  }

  /** Actually parse NoNewlineExpr.OpExpr. */
  private Result pNoNewlineExpr$OpExpr$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$OpExprNoEnc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      yyValue = Resolver.resolveOps(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      yyValue = Resolver.resolveOps(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      PrecedenceOpExpr e =
      new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
      yyValue = Resolver.resolveOps(PureList.make(e));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.OpExprNoEnc.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$OpExprNoEnc(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fNoNewlineExpr$OpExprNoEnc) 
      yyColumn.chunk23.fNoNewlineExpr$OpExprNoEnc = pNoNewlineExpr$OpExprNoEnc$1(yyStart);
    return yyColumn.chunk23.fNoNewlineExpr$OpExprNoEnc;
  }

  /** Actually parse NoNewlineExpr.OpExprNoEnc. */
  private Result pNoNewlineExpr$OpExprNoEnc$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$OpExprPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr$OpExprPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
      yyValue = PureList.make(e);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.TightInfixRight.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$TightInfixRight(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pSpacing$sr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$LooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$LeftLooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Right(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 4.

      yyValue = PureList.make((PrecedenceOpExpr)new Right(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.LeftLooseInfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$LeftLooseInfix(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fNoNewlineExpr$LeftLooseInfix) 
      yyColumn.chunk23.fNoNewlineExpr$LeftLooseInfix = pNoNewlineExpr$LeftLooseInfix$1(yyStart);
    return yyColumn.chunk23.fNoNewlineExpr$LeftLooseInfix;
  }

  /** Actually parse NoNewlineExpr.LeftLooseInfix. */
  private Result pNoNewlineExpr$LeftLooseInfix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pSpacing$sr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.OpExprLeftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$OpExprLeftEncloser(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fNoNewlineExpr$OpExprLeftEncloser) 
      yyColumn.chunk23.fNoNewlineExpr$OpExprLeftEncloser = pNoNewlineExpr$OpExprLeftEncloser$1(yyStart);
    return yyColumn.chunk23.fNoNewlineExpr$OpExprLeftEncloser;
  }

  /** Actually parse NoNewlineExpr.OpExprLeftEncloser. */
  private Result pNoNewlineExpr$OpExprLeftEncloser$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pNoNewlineExpr$OpExprNoEnc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new Left(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.OpExprPrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$OpExprPrimary(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fNoNewlineExpr$OpExprPrimary) 
      yyColumn.chunk23.fNoNewlineExpr$OpExprPrimary = pNoNewlineExpr$OpExprPrimary$1(yyStart);
    return yyColumn.chunk23.fNoNewlineExpr$OpExprPrimary;
  }

  /** Actually parse NoNewlineExpr.OpExprPrimary. */
  private Result pNoNewlineExpr$OpExprPrimary$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared52(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<Expr> a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineExpr$TightInfixPostfix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoNewlineExpr$TightInfixRight(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pSpacing$sr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$LooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$LeftLooseInfix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 4.

      yyValue =
      PureList.make((PrecedenceOpExpr)new RealExpr(FortressUtil.buildPrimary(a1)));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.OpExprPrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$OpExprPrefix(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fNoNewlineExpr$OpExprPrefix) 
      yyColumn.chunk23.fNoNewlineExpr$OpExprPrefix = pNoNewlineExpr$OpExprPrefix$1(yyStart);
    return yyColumn.chunk23.fNoNewlineExpr$OpExprPrefix;
  }

  /** Actually parse NoNewlineExpr.OpExprPrefix. */
  private Result pNoNewlineExpr$OpExprPrefix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = pSpacing$sr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.TightInfixPostfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$TightInfixPostfix(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = pSpacing$sr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 5.

      yyValue = PureList.make((PrecedenceOpExpr)new Postfix(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.LooseInfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$LooseInfix(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fNoNewlineExpr$LooseInfix) 
      yyColumn.chunk23.fNoNewlineExpr$LooseInfix = pNoNewlineExpr$LooseInfix$1(yyStart);
    return yyColumn.chunk23.fNoNewlineExpr$LooseInfix;
  }

  /** Actually parse NoNewlineExpr.LooseInfix. */
  private Result pNoNewlineExpr$LooseInfix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pwr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pNoNewlineExpr$OpExprPrimary(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pNoNewlineExpr$OpExprPrefix(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyResult = pSpacing$sr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$OpExprLeftEncloser(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

          yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.FlowExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$FlowExpr(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        Id a1 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pwith(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineExpr$Expr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
          }
        }
        { // Start scope for a2.
          Expr a2 = cast(yyOpValue1);

          Option<Id> name = (a1 == null) ? Option.<Id>none() : Option.some(a1);
          Option<Expr> expr = Option.wrap(a2);
          yyValue = new Exit(createSpan(yyStart,yyCount), false, name, expr);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = pAccumulator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pStaticArgs(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<StaticArg> v$el$3 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$3;
      }
      { // Start scope for a2.
        List<StaticArg> a2 = cast(yyOpValue1);

        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = popensquare(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineExpr$GeneratorClauseList(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<GeneratorClause> v$el$4 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pclosesquare(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$4;
                  }
                }
              }
            }
          }
        }
        { // Start scope for a3.
          List<GeneratorClause> a3 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a4 = yyResult.semanticValue();

              if (a3 == null) a3 = Collections.<GeneratorClause>emptyList();
              if (a2 == null) a2 = Collections.<StaticArg>emptyList();
              yyValue = new Accumulator(createSpan(yyStart,yyCount), a2, a1, a3, a4);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a3.
      } // End scope for a2.
    }

    // Alternative 3.

    yyResult = patomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$AtomicBack(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = new AtomicExpr(createSpan(yyStart,yyCount), false, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyResult = ptryatomic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$AtomicBack(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = new TryAtomicExpr(createSpan(yyStart,yyCount), false, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = pspawn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = new Spawn(createSpan(yyStart,yyCount), false, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 6.

    yyResult = pthrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineExpr$Expr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyValue = new Throw(createSpan(yyStart,yyCount), false, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.AtomicBack.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$AtomicBack(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fNoNewlineExpr$AtomicBack) 
      yyColumn.chunk23.fNoNewlineExpr$AtomicBack = pNoNewlineExpr$AtomicBack$1(yyStart);
    return yyColumn.chunk23.fNoNewlineExpr$AtomicBack;
  }

  /** Actually parse NoNewlineExpr.AtomicBack. */
  private Result pNoNewlineExpr$AtomicBack$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$AssignExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr$OpExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDelimitedExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.GeneratorClauseList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$GeneratorClauseList(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk23) yyColumn.chunk23 = new Chunk23();
    if (null == yyColumn.chunk23.fNoNewlineExpr$GeneratorClauseList) 
      yyColumn.chunk23.fNoNewlineExpr$GeneratorClauseList = pNoNewlineExpr$GeneratorClauseList$1(yyStart);
    return yyColumn.chunk23.fNoNewlineExpr$GeneratorClauseList;
  }

  /** Actually parse NoNewlineExpr.GeneratorClauseList. */
  private Result pNoNewlineExpr$GeneratorClauseList$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    List<GeneratorClause> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$GeneratorBinding(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      GeneratorClause a1 = yyResult.semanticValue();

      yyResult = pNoNewlineExpr$GeneratorClauseList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<GeneratorClause> a2s = yyResult.semanticValue();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal NoNewlineExpr.GeneratorClauseList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$GeneratorClauseList$$Star1(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fNoNewlineExpr$GeneratorClauseList$$Star1) 
      yyColumn.chunk24.fNoNewlineExpr$GeneratorClauseList$$Star1 = pNoNewlineExpr$GeneratorClauseList$$Star1$1(yyStart);
    return yyColumn.chunk24.fNoNewlineExpr$GeneratorClauseList$$Star1;
  }

  /** Actually parse NoNewlineExpr.GeneratorClauseList$$Star1. */
  private Result pNoNewlineExpr$GeneratorClauseList$$Star1$1(final int yyStart) 
    throws IOException {

    Result                yyResult;
    Pair<GeneratorClause> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineExpr$GeneratorClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            GeneratorClause v$el$1 = yyResult.semanticValue();

            yyResult = 
              pNoNewlineExpr$GeneratorClauseList$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<GeneratorClause> v$2 = yyResult.semanticValue();

              yyValue = new Pair<GeneratorClause>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.GeneratorBinding.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$GeneratorBinding(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fNoNewlineExpr$GeneratorBinding) 
      yyColumn.chunk24.fNoNewlineExpr$GeneratorBinding = pNoNewlineExpr$GeneratorBinding$1(yyStart);
    return yyColumn.chunk24.fNoNewlineExpr$GeneratorBinding;
  }

  /** Actually parse NoNewlineExpr.GeneratorBinding. */
  private Result pNoNewlineExpr$GeneratorBinding$1(final int yyStart) 
    throws IOException {

    Result          yyResult;
    GeneratorClause yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindIdOrBindIdTuple(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Id> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pleftarrow(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyValue = ExprFactory.makeGeneratorClause(createSpan(yyStart,yyCount),
              a1,a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.GeneratorClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr$GeneratorClause(final int yyStart) 
    throws IOException {

    Result          yyResult;
    GeneratorClause yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$GeneratorBinding(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyValue = new GeneratorClause(createSpan(yyStart,yyCount),
      Collections.<Id>emptyList(), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.NoNewlineExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineExpr(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fNoNewlineExpr) 
      yyColumn.chunk24.fNoNewlineExpr = pNoNewlineExpr$1(yyStart);
    return yyColumn.chunk24.fNoNewlineExpr;
  }

  /** Actually parse NoNewlineExpr.NoNewlineExpr. */
  private Result pNoNewlineExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr$Expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.NoNewlineVarWTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineVarWTypes(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fNoNewlineVarWTypes) 
      yyColumn.chunk24.fNoNewlineVarWTypes = pNoNewlineVarWTypes$1(yyStart);
    return yyColumn.chunk24.fNoNewlineVarWTypes;
  }

  /** Actually parse NoNewlineExpr.NoNewlineVarWTypes. */
  private Result pNoNewlineVarWTypes$1(final int yyStart) throws IOException {
    Result           yyResult;
    List<LValueBind> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineVarWType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LValueBind a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineVarWType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          LValueBind a1 = yyResult.semanticValue();

          yyResult = pNoNewlineVarWTypes$$Plus1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Pair<LValueBind> a2s = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = FortressUtil.mkList(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.NoNewlineVarWTypes$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineVarWTypes$$Plus1(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fNoNewlineVarWTypes$$Plus1) 
      yyColumn.chunk24.fNoNewlineVarWTypes$$Plus1 = pNoNewlineVarWTypes$$Plus1$1(yyStart);
    return yyColumn.chunk24.fNoNewlineVarWTypes$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.NoNewlineVarWTypes$$Plus1. */
  private Result pNoNewlineVarWTypes$$Plus1$1(final int yyStart) 
    throws IOException {

    Result           yyResult;
    Pair<LValueBind> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pNoNewlineVarWType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            LValueBind v$el$1 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pNoNewlineVarWTypes$$Plus1(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<LValueBind> v$2 = yyResult.semanticValue();

              yyValue = new Pair<LValueBind>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyValue = new Pair<LValueBind>(v$el$1);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.NoNewlineVarWType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineVarWType(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fNoNewlineVarWType) 
      yyColumn.chunk24.fNoNewlineVarWType = pNoNewlineVarWType$1(yyStart);
    return yyColumn.chunk24.fNoNewlineVarWType;
  }

  /** Actually parse NoNewlineExpr.NoNewlineVarWType. */
  private Result pNoNewlineVarWType$1(final int yyStart) throws IOException {
    Result     yyResult;
    LValueBind yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineIsType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Type a2 = yyResult.semanticValue();

          yyValue = FortressUtil.mkLValueBind(createSpan(yyStart,yyCount),a1,a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoNewlineExpr.NoNewlineIsType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineIsType(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fNoNewlineIsType) 
      yyColumn.chunk24.fNoNewlineIsType = pNoNewlineIsType$1(yyStart);
    return yyColumn.chunk24.fNoNewlineIsType;
  }

  /** Actually parse NoNewlineExpr.NoNewlineIsType. */
  private Result pNoNewlineIsType$1(final int yyStart) throws IOException {
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol$colon(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNoNewlineType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.Expr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$Expr(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Expr>> yyRepValue1;
    Expr               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr$ExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = p$$Shared35(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Action<Expr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Expr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for list.
        Pair<Action<Expr>> list = yyRepValue1.reverse();

        yyValue = (Expr)apply(list, seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for list.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.ExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$ExprFront(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fNoSpaceExpr$ExprFront) 
      yyColumn.chunk24.fNoSpaceExpr$ExprFront = pNoSpaceExpr$ExprFront$1(yyStart);
    return yyColumn.chunk24.fNoSpaceExpr$ExprFront;
  }

  /** Actually parse NoSpaceExpr.ExprFront. */
  private Result pNoSpaceExpr$ExprFront$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr$AssignExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoSpaceExpr$OpExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDelimitedExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.AssignExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$AssignExpr(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared47(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<LHS> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAssignOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Option<Op> a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoSpaceExpr$Expr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              yyValue = new Assignment(createSpan(yyStart,yyCount), false, a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.OpExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$OpExpr(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr$OpExprNoEnc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      yyValue = Resolver.resolveOpsNoSpace(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoSpaceExpr$OpExprLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<PrecedenceOpExpr> a1 = yyResult.semanticValue();

      yyValue = Resolver.resolveOpsNoSpace(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      PrecedenceOpExpr e =
      new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
      yyValue = Resolver.resolveOpsNoSpace(PureList.make(e));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.OpExprNoEnc.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$OpExprNoEnc(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fNoSpaceExpr$OpExprNoEnc) 
      yyColumn.chunk24.fNoSpaceExpr$OpExprNoEnc = pNoSpaceExpr$OpExprNoEnc$1(yyStart);
    return yyColumn.chunk24.fNoSpaceExpr$OpExprNoEnc;
  }

  /** Actually parse NoSpaceExpr.OpExprNoEnc. */
  private Result pNoSpaceExpr$OpExprNoEnc$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr$OpExprPrimary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoSpaceExpr$OpExprPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
      yyValue = PureList.make(e);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.TightInfixRight.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$TightInfixRight(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoSpaceExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoSpaceExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyValue = PureList.make((PrecedenceOpExpr)new Right(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.OpExprLeftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$OpExprLeftEncloser(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk24) yyColumn.chunk24 = new Chunk24();
    if (null == yyColumn.chunk24.fNoSpaceExpr$OpExprLeftEncloser) 
      yyColumn.chunk24.fNoSpaceExpr$OpExprLeftEncloser = pNoSpaceExpr$OpExprLeftEncloser$1(yyStart);
    return yyColumn.chunk24.fNoSpaceExpr$OpExprLeftEncloser;
  }

  /** Actually parse NoSpaceExpr.OpExprLeftEncloser. */
  private Result pNoSpaceExpr$OpExprLeftEncloser$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pNoSpaceExpr$OpExprNoEnc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new Left(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.OpExprPrimary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$OpExprPrimary(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fNoSpaceExpr$OpExprPrimary) 
      yyColumn.chunk25.fNoSpaceExpr$OpExprPrimary = pNoSpaceExpr$OpExprPrimary$1(yyStart);
    return yyColumn.chunk25.fNoSpaceExpr$OpExprPrimary;
  }

  /** Actually parse NoSpaceExpr.OpExprPrimary. */
  private Result pNoSpaceExpr$OpExprPrimary$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared52(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      PureList<Expr> a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoSpaceExpr$TightInfixPostfix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoSpaceExpr$TightInfixRight(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1)));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyValue =
      PureList.make((PrecedenceOpExpr)new RealExpr(FortressUtil.buildPrimary(a1)));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.OpExprPrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$OpExprPrefix(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fNoSpaceExpr$OpExprPrefix) 
      yyColumn.chunk25.fNoSpaceExpr$OpExprPrefix = pNoSpaceExpr$OpExprPrefix$1(yyStart);
    return yyColumn.chunk25.fNoSpaceExpr$OpExprPrefix;
  }

  /** Actually parse NoSpaceExpr.OpExprPrefix. */
  private Result pNoSpaceExpr$OpExprPrefix$1(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoSpaceExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoSpaceExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pNoSpaceExpr$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.TightInfixPostfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr$TightInfixPostfix(final int yyStart) 
    throws IOException {

    Result                     yyResult;
    PureList<PrecedenceOpExpr> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNoSpaceExpr$OpExprPrimary(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pNoSpaceExpr$OpExprPrefix(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pNoSpaceExpr$OpExprLeftEncloser(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        PureList<PrecedenceOpExpr> a2 = yyResult.semanticValue();

        yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyValue = PureList.make((PrecedenceOpExpr)new Postfix(a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal NoSpaceExpr.NoSpaceExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoSpaceExpr(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fNoSpaceExpr) 
      yyColumn.chunk25.fNoSpaceExpr = pNoSpaceExpr$1(yyStart);
    return yyColumn.chunk25.fNoSpaceExpr;
  }

  /** Actually parse NoSpaceExpr.NoSpaceExpr. */
  private Result pNoSpaceExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr$ExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.LiteralExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteralExpr(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fLiteralExpr) 
      yyColumn.chunk25.fLiteralExpr = pLiteralExpr$1(yyStart);
    return yyColumn.chunk25.fLiteralExpr;
  }

  /** Actually parse Literal.LiteralExpr. */
  private Result pLiteralExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <VOID>.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcloseparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = ExprFactory.makeVoidLiteralExpr(createSpan(yyStart,yyCount));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative <NUMERICAL>.

    yyResult = pNumericLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <CHAR>.

    yyResult = pCharLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <STRING>.

    yyResult = pStringLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.ArrayExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayExpr(final int yyStart) throws IOException {
    Result     yyResult;
    ArrayExpr  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pRectElements(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosesquare(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.RectElements.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRectElements(final int yyStart) throws IOException {
    Result                                           yyResult;
    int                                              yyRepetition1;
    Pair<com.sun.fortress.useful.Pair<Integer,Expr>> yyRepValue1;
    ArrayExpr                                        yyValue;
    ParseError                                       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSpaceExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pMultiDimCons(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          com.sun.fortress.useful.Pair<Integer,Expr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<com.sun.fortress.useful.Pair<Integer,Expr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<com.sun.fortress.useful.Pair<Integer,Expr>> a2s = yyRepValue1.reverse();

        if (a2s == null || a2s.isEmpty())
        yyValue = new ArrayElement(a1.getSpan(), false, a1);
        else
        yyValue = FortressUtil.multiDimCons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.MultiDimCons.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiDimCons(final int yyStart) throws IOException {
    Result                                     yyResult;
    com.sun.fortress.useful.Pair<Integer,Expr> yyValue;
    ParseError                                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRectSeparator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Integer a1 = yyResult.semanticValue();

      yyResult = pNoSpaceExpr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expr a2 = yyResult.semanticValue();

        yyValue = new com.sun.fortress.useful.Pair<Integer,Expr>(a1,a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NumericLiteralExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumericLiteralExpr(final int yyStart) throws IOException {
    Result            yyResult;
    NumberLiteralExpr yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFloatLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIntLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.FloatLiteralExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatLiteralExpr(final int yyStart) throws IOException {
    Result           yyResult;
    FloatLiteralExpr yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDigitString(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pdot(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pDigitString(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a2 = yyResult.semanticValue();

          yyValue = ExprFactory.makeFloatLiteralExpr(createSpan(yyStart,yyCount),
          a1 + "." + a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.IntLiteralExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntLiteralExpr(final int yyStart) throws IOException {
    Result         yyResult;
    IntLiteralExpr yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDigitString(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = ExprFactory.makeIntLiteralExpr(createSpan(yyStart,yyCount),
      a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.DigitString.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDigitString(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("digit string expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.CharLiteralExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharLiteralExpr(final int yyStart) throws IOException {
    int             yyC;
    int             yyIndex;
    Result          yyResult;
    int             yyBase;
    CharLiteralExpr yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\'' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pCharLiteralContent(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a1 = yyResult.semanticValue();

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('\'' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = ExprFactory.makeCharLiteralExpr(createSpan(yyStart,yyCount),
          a1);

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"\\\'\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("char literal expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.StringLiteralExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteralExpr(final int yyStart) throws IOException {
    int               yyC;
    int               yyIndex;
    Result            yyResult;
    int               yyRepetition1;
    Pair<String>      yyRepValue1;
    StringLiteralExpr yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pStringLiteralContent(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a1.
        Pair<String> a1 = yyRepValue1.reverse();

        yyC = character(yyRepetition1);
        if ('\"' == yyC) {
          yyIndex = yyRepetition1 + 1;

          String str = "";
          for (String s : (List<String>)a1.list()) {
            str = str.concat(s);
          }
          yyValue = new StringLiteralExpr(createSpan(yyStart,yyCount), false, str);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      } // End scope for a1.
    }

    // Done.
    yyError = yyError.select("string literal expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.StringLiteralContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteralContent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEscapeSequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if (('\"' != a1) &&
          ('\\' != a1)) {

        yyValue = String.valueOf(a1);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("string literal content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.EscapeSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEscapeSequence(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (-1 != yyC) {
        yyIndex = yyIndex + 1;
        char a1 = (char)yyC;

        if (('\"' == a1) ||
            ('\\' == a1) ||
            ('b' == a1) ||
            ('f' == a1) ||
            ('n' == a1) ||
            ('r' == a1) ||
            ('t' == a1)) {

          switch (a1) {
            case 'b': { yyValue = "\b"; break; }
            case 't': { yyValue = "\t"; break; }
            case 'n': { yyValue = "\n"; break; }
            case 'f': { yyValue = "\f"; break; }
            case 'r': { yyValue = "\r"; break; }
            case '"': { yyValue = "\""; break; }
            case '\\': { yyValue = "\\"; break; }
            default: { yyValue = ""; }
          }

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("escape sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.CharLiteralContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharLiteralContent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (-1 != yyC) {
        yyIndex = yyIndex + 1;

        switch (yyC) {
        case '\"':
        case '\\':
        case 'b':
        case 'f':
        case 'n':
        case 'r':
        case 't':
          {
            yyValue = difference(yyStart, yyIndex);

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        default:
          /* No match. */
        }
      }
    }

    // Alternative 2.

    yyPredMatched = false;

    yyC = character(yyStart);
    if ('\'' == yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("char literal content expected", yyStart);
    }

    // Done.
    yyError = yyError.select("char literal content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.BlockElems.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockElems(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fBlockElems) 
      yyColumn.chunk25.fBlockElems = pBlockElems$1(yyStart);
    return yyColumn.chunk25.fBlockElems;
  }

  /** Actually parse LocalDecl.BlockElems. */
  private Result pBlockElems$1(final int yyStart) throws IOException {
    Result     yyResult;
    Block      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBlockElemCollection(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Expr> a1 = yyResult.semanticValue();

      yyValue = FortressUtil.doBlock(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.BlockElemCollection.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockElemCollection(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fBlockElemCollection) 
      yyColumn.chunk25.fBlockElemCollection = pBlockElemCollection$1(yyStart);
    return yyColumn.chunk25.fBlockElemCollection;
  }

  /** Actually parse LocalDecl.BlockElemCollection. */
  private Result pBlockElemCollection$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Result     yyPredResult;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBlockElem(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pbr(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBlockElemCollection(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Expr> a2 = yyResult.semanticValue();

          yyValue = FortressUtil.mkList(a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyPredResult = pBlockElemCollection$$Choice1(yyChoice1);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyValue = FortressUtil.mkList(a1);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }

      // Nested alternative 3.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = psemicolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyPredResult = pBlockElemCollection$$Choice2(yyResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyValue = FortressUtil.mkList(a1);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.BlockElemCollection$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockElemCollection$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pElifs(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pElse(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pCaseClause(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pTypecaseTypes(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pCaseElse(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = palso(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pend(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pCatch(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = pforbid(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 5.

      yyResult = pfinally(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 6.

      yyResult = pcloseparen(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.BlockElemCollection$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockElemCollection$$Choice2(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pElifs(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pElse(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pCaseClause(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 4.

      yyResult = pTypecaseTypes(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 5.

      yyResult = pCaseElse(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 6.

      yyResult = palso(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 7.

      yyResult = pend(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 8.

      yyResult = pCatch(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 9.

      yyResult = pforbid(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 10.

      yyResult = pfinally(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 11.

      yyResult = pcloseparen(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.BlockElem.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockElem(final int yyStart) throws IOException {
    Result                yyResult;
    int                   yyOption1;
    List<GeneratorClause> yyOpValue1;
    Expr                  yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLocalVarFnDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNoNewlineExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = ps(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr$GeneratorClauseList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<GeneratorClause> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
        }
      }
      { // Start scope for a2.
        List<GeneratorClause> a2 = yyOpValue1;

        if (a2 == null) yyValue = a1;
        else yyValue = new GeneratedExpr(createSpan(yyStart,yyCount), false,
        a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.LocalVarFnDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalVarFnDecl(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyRepetition1;
    Pair<FnDef> yyRepValue1;
    LetExpr     yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLocalFnDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      FnDef a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pbr(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pLocalFnDecl(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            FnDef v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<FnDef>(v$el$2, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<FnDef> a2s = yyRepValue1.reverse();

        List<FnDef> fns = FortressUtil.mkList(a1, a2s.list());
        yyValue = new LetFn(createSpan(yyStart,yyCount), false,
        FortressUtil.emptyExprs(), fns);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Alternative 2.

    yyResult = pLocalVarDecl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.LocalFnDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalFnDecl(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fLocalFnDecl) 
      yyColumn.chunk25.fLocalFnDecl = pLocalFnDecl$1(yyStart);
    return yyColumn.chunk25.fLocalFnDecl;
  }

  /** Actually parse LocalDecl.LocalFnDecl. */
  private Result pLocalFnDecl$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    List<Modifier> yyOpValue1;
    FnDef          yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pLocalFnMods(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Modifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<Modifier> a1 = yyOpValue1;

      yyResult = pNamedFnHeaderFront(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        FnHeaderFront a2 = yyResult.semanticValue();

        yyResult = pFnHeaderClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FnHeaderClause a3 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pequals(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pNoNewlineExpr(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Expr a4 = yyResult.semanticValue();

                  if (a1 == null) a1 = FortressUtil.emptyModifiers();
                  yyValue = FortressUtil.mkFnDecl(createSpan(yyStart,yyCount),a1,a2,a3,a4);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.LocalVarDecl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalVarDecl(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Object       yyOpValue1;
    LocalVarDecl yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pvar(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      String a1 = cast(yyOpValue1);

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = pNoNewlineVarWTypes(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<LValueBind> a2 = yyResult.semanticValue();

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = ps(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = p$$Shared6(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            com.sun.fortress.useful.Pair<Expr,Boolean> a3 = yyResult.semanticValue();

            if (a1 != null) a2 = FortressUtil.setMutable(a2, createSpan(yyStart,3));
            else if (a3.getB()) a2 = FortressUtil.setMutable(a2);
            yyValue = FortressUtil.mkLocalVarDecl(createSpan(yyStart,yyCount),
            FortressUtil.toLValueList(a2),
            a3.getA());

            return yyResult.createValue(yyValue, yyError);
          }
        }

        // Nested alternative 2.

        if (a1 != null) a2 = FortressUtil.setMutable(a2, createSpan(yyStart,3));
        yyValue = FortressUtil.mkLocalVarDecl(createSpan(yyStart,yyCount),
        FortressUtil.toLValueList(a2));

        return new SemanticValue(yyValue, yyChoice2, yyError);
      }

      // Nested alternative 2.

      yyResult = pVarWoTypes(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<LValue> a2 = yyResult.semanticValue();

        yyResult = ps(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice2 = yyResult.index;

          // Nested alternative 1.

          yyResult = pequals(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pNoNewlineExpr(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr a3 = yyResult.semanticValue();

                if (a1 != null) a2 = FortressUtil.setMutableLValue(a2,
                createSpan(yyStart,3));
                yyValue = FortressUtil.mkLocalVarDecl(createSpan(yyStart,yyCount),a2,a3);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }

          // Nested alternative 2.

          yyResult = pSymbol$colon(yyChoice2);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = ps(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              final int yyChoice3 = yyResult.index;

              // Nested alternative 1.

              yyResult = pType$Type(yyChoice3);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Type a3 = yyResult.semanticValue();

                yyResult = ps(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pellipses(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption1  = yyResult.index;
                    yyOpValue1 = null;

                    yyResult = ps(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = p$$Shared6(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        com.sun.fortress.useful.Pair<Expr,Boolean> v$el$2 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = v$el$2;
                      }
                    }
                    { // Start scope for a4.
                      com.sun.fortress.useful.Pair<Expr,Boolean> a4 = cast(yyOpValue1);

                      Option<Expr> init;
                      if (a1 != null) {
                        a2 = FortressUtil.setMutableAndType(a2, createSpan(yyStart,3), a3);
                        if (a4 == null) init = Option.none();
                        else            init = Option.some(a4.getA());
                      } else {
                        if (a4 == null) {
                          init = Option.none();
                          a2 = FortressUtil.setType(a2, a3);
                        } else {
                          init = Option.some(a4.getA());
                          if (a4.getB()) a2 = FortressUtil.setMutableAndType(a2, a3);
                          else a2 = FortressUtil.setType(a2, a3);
                        }
                      }
                      yyValue = FortressUtil.mkLocalVarDecl(createSpan(yyStart,yyCount), a2,
                      init);

                      return new SemanticValue(yyValue, yyOption1, yyError);
                    } // End scope for a4.
                  }
                }
              }

              // Nested alternative 2.

              yyResult = pType$TupleType(yyChoice3);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                TupleType a3 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = ps(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = p$$Shared6(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    com.sun.fortress.useful.Pair<Expr,Boolean> v$el$3 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$3;
                  }
                }
                { // Start scope for a4.
                  com.sun.fortress.useful.Pair<Expr,Boolean> a4 = cast(yyOpValue1);

                  Span span = createSpan(yyStart,yyCount);
                  List<Type> tys = a3.getElements();
                  Option<Expr> init;
                  if (a2.size() != tys.size())
                  error(new Id(span,"_"),"Mismatched numbers of variables and types.");
                  if (a1 != null) {
                    a2 = FortressUtil.setMutableAndType(a2, createSpan(yyStart,3), tys);
                    if (a4 == null) init = Option.none();
                    else            init = Option.some(a4.getA());
                  } else {
                    if (a4 == null) {
                      init = Option.none();
                      a2 = FortressUtil.setType(a2, tys);
                    } else {
                      init = Option.some(a4.getA());
                      if (a4.getB()) a2 = FortressUtil.setMutableAndType(a2, tys);
                      else a2 = FortressUtil.setType(a2, tys);
                    }
                  }
                  yyValue = FortressUtil.mkLocalVarDecl(span, a2, init);

                  return new SemanticValue(yyValue, yyOption1, yyError);
                } // End scope for a4.
              }
            }
          }
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.VarWoTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVarWoTypes(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    boolean      yyRepeated1;
    Pair<LValue> yyRepValue1;
    List<LValue> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pVarWoType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LValue a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pVarWoType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          LValue a1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = false;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pVarWoType(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    LValue v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    yyRepValue1   = new Pair<LValue>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }

          if (yyRepeated1) {
            Pair<LValue> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = FortressUtil.mkList(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.VarWoType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVarWoType(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fVarWoType) 
      yyColumn.chunk25.fVarWoType = pVarWoType$1(yyStart);
    return yyColumn.chunk25.fVarWoType;
  }

  /** Actually parse LocalDecl.VarWoType. */
  private Result pVarWoType$1(final int yyStart) throws IOException {
    Result     yyResult;
    LValue     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkLValueBind(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pUnpasting(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.Unpasting.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnpasting(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fUnpasting) 
      yyColumn.chunk25.fUnpasting = pUnpasting$1(yyStart);
    return yyColumn.chunk25.fUnpasting;
  }

  /** Actually parse LocalDecl.Unpasting. */
  private Result pUnpasting$1(final int yyStart) throws IOException {
    Result     yyResult;
    Unpasting  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnpastingElems(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosesquare(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.UnpastingElems.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnpastingElems(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk25) yyColumn.chunk25 = new Chunk25();
    if (null == yyColumn.chunk25.fUnpastingElems) 
      yyColumn.chunk25.fUnpastingElems = pUnpastingElems$1(yyStart);
    return yyColumn.chunk25.fUnpastingElems;
  }

  /** Actually parse LocalDecl.UnpastingElems. */
  private Result pUnpastingElems$1(final int yyStart) throws IOException {
    Result     yyResult;
    Unpasting  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUnpastingElem(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Unpasting a1 = yyResult.semanticValue();

      yyResult = pRectSeparator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Integer a2 = yyResult.semanticValue();

        yyResult = pUnpastingElems(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Unpasting a3 = yyResult.semanticValue();

          yyValue = FortressUtil.unpastingCons(createSpan(yyStart,yyCount),
          a1, a2, a3);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pUnpastingElem(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.UnpastingElem.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnpastingElem(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fUnpastingElem) 
      yyColumn.chunk26.fUnpastingElem = pUnpastingElem$1(yyStart);
    return yyColumn.chunk26.fUnpastingElem;
  }

  /** Actually parse LocalDecl.UnpastingElem. */
  private Result pUnpastingElem$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<ExtentRange> yyOpValue1;
    Unpasting         yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = popensquare(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pUnpastingDim(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<ExtentRange> v$el$2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosesquare(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
          }
        }
      }
      { // Start scope for a2.
        List<ExtentRange> a2 = yyOpValue1;

        if (a2 == null)
        yyValue = new UnpastingBind(createSpan(yyStart,yyCount), a1,
        Collections.<ExtentRange>emptyList());
        else
        yyValue = new UnpastingBind(createSpan(yyStart,yyCount), a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pUnpasting(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.UnpastingDim.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnpastingDim(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    boolean           yyRepeated1;
    Pair<ExtentRange> yyRepValue1;
    List<ExtentRange> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared11(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ExtentRange a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcross(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = p$$Shared11(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                ExtentRange v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepeated1   = true;
                yyRepValue1   = new Pair<ExtentRange>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }

      if (yyRepeated1) {
        Pair<ExtentRange> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal LocalDecl.CaseClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseClause(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fCaseClause) 
      yyColumn.chunk26.fCaseClause = pCaseClause$1(yyStart);
    return yyColumn.chunk26.fCaseClause;
  }

  /** Actually parse LocalDecl.CaseClause. */
  private Result pCaseClause$1(final int yyStart) throws IOException {
    Result     yyResult;
    CaseClause yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoNewlineExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pmatch(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pBlockElems(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Block a2 = yyResult.semanticValue();

              yyValue = new CaseClause(createSpan(yyStart,yyCount), a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pid(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fid) yyColumn.chunk26.fid = pid$1(yyStart);
    return yyColumn.chunk26.fid;
  }

  /** Actually parse Identifier.id. */
  private Result pid$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pidstart(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String s1 = yyResult.semanticValue();

      yyResult = pid$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> s2 = yyResult.semanticValue();

        String s = s1;
        for (String ss : s2.list()) {
          s += ss;
        }
        if (!FORTRESS_KEYWORDS.contains(s))
        yyValue = difference(yyStart, yyResult.index);
        else {        // Error production
          return yyError.select(s + " is a keyword!", yyError.index + 10);
        }

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.id$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pid$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fid$$Star1) 
      yyColumn.chunk26.fid$$Star1 = pid$$Star1$1(yyStart);
    return yyColumn.chunk26.fid$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.id$$Star1. */
  private Result pid$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pidrest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pid$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> v$2 = yyResult.semanticValue();

        yyValue = new Pair<String>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.idstart.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidstart(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z')) ||
          ('\u00aa' == yyC) ||
          ('\u00b5' == yyC) ||
          ('\u00ba' == yyC) ||
          (('\u00c0' <= yyC) && (yyC <= '\u00d6')) ||
          (('\u00d8' <= yyC) && (yyC <= '\u00f6')) ||
          (('\u00f8' <= yyC) && (yyC <= '\u02c1')) ||
          (('\u02c6' <= yyC) && (yyC <= '\u02d1')) ||
          (('\u02e0' <= yyC) && (yyC <= '\u02e4')) ||
          ('\u02ee' == yyC) ||
          (('\u037a' <= yyC) && (yyC <= '\u037d')) ||
          ('\u0386' == yyC) ||
          (('\u0388' <= yyC) && (yyC <= '\u038a')) ||
          ('\u038c' == yyC) ||
          (('\u038e' <= yyC) && (yyC <= '\u03a1')) ||
          (('\u03a3' <= yyC) && (yyC <= '\u03ce')) ||
          (('\u03d0' <= yyC) && (yyC <= '\u03f5')) ||
          (('\u03f7' <= yyC) && (yyC <= '\u0481')) ||
          (('\u048a' <= yyC) && (yyC <= '\u0513')) ||
          (('\u0531' <= yyC) && (yyC <= '\u0556')) ||
          ('\u0559' == yyC) ||
          (('\u0561' <= yyC) && (yyC <= '\u0587')) ||
          (('\u05d0' <= yyC) && (yyC <= '\u05ea')) ||
          (('\u05f0' <= yyC) && (yyC <= '\u05f2')) ||
          (('\u0621' <= yyC) && (yyC <= '\u063a')) ||
          (('\u0640' <= yyC) && (yyC <= '\u064a')) ||
          (('\u066e' <= yyC) && (yyC <= '\u066f')) ||
          (('\u0671' <= yyC) && (yyC <= '\u06d3')) ||
          ('\u06d5' == yyC) ||
          (('\u06e5' <= yyC) && (yyC <= '\u06e6')) ||
          (('\u06ee' <= yyC) && (yyC <= '\u06ef')) ||
          (('\u06fa' <= yyC) && (yyC <= '\u06fc')) ||
          ('\u06ff' == yyC) ||
          ('\u0710' == yyC) ||
          (('\u0712' <= yyC) && (yyC <= '\u072f')) ||
          (('\u074d' <= yyC) && (yyC <= '\u076d')) ||
          (('\u0780' <= yyC) && (yyC <= '\u07a5')) ||
          ('\u07b1' == yyC) ||
          (('\u07ca' <= yyC) && (yyC <= '\u07ea')) ||
          (('\u07f4' <= yyC) && (yyC <= '\u07f5')) ||
          ('\u07fa' == yyC) ||
          (('\u0904' <= yyC) && (yyC <= '\u0939')) ||
          ('\u093d' == yyC) ||
          ('\u0950' == yyC) ||
          (('\u0958' <= yyC) && (yyC <= '\u0961')) ||
          (('\u097b' <= yyC) && (yyC <= '\u097f')) ||
          (('\u0985' <= yyC) && (yyC <= '\u098c')) ||
          (('\u098f' <= yyC) && (yyC <= '\u0990')) ||
          (('\u0993' <= yyC) && (yyC <= '\u09a8')) ||
          (('\u09aa' <= yyC) && (yyC <= '\u09b0')) ||
          ('\u09b2' == yyC) ||
          (('\u09b6' <= yyC) && (yyC <= '\u09b9')) ||
          ('\u09bd' == yyC) ||
          ('\u09ce' == yyC) ||
          (('\u09dc' <= yyC) && (yyC <= '\u09dd')) ||
          (('\u09df' <= yyC) && (yyC <= '\u09e1')) ||
          (('\u09f0' <= yyC) && (yyC <= '\u09f1')) ||
          (('\u0a05' <= yyC) && (yyC <= '\u0a0a')) ||
          (('\u0a0f' <= yyC) && (yyC <= '\u0a10')) ||
          (('\u0a13' <= yyC) && (yyC <= '\u0a28')) ||
          (('\u0a2a' <= yyC) && (yyC <= '\u0a30')) ||
          (('\u0a32' <= yyC) && (yyC <= '\u0a33')) ||
          (('\u0a35' <= yyC) && (yyC <= '\u0a36')) ||
          (('\u0a38' <= yyC) && (yyC <= '\u0a39')) ||
          (('\u0a59' <= yyC) && (yyC <= '\u0a5c')) ||
          ('\u0a5e' == yyC) ||
          (('\u0a72' <= yyC) && (yyC <= '\u0a74')) ||
          (('\u0a85' <= yyC) && (yyC <= '\u0a8d')) ||
          (('\u0a8f' <= yyC) && (yyC <= '\u0a91')) ||
          (('\u0a93' <= yyC) && (yyC <= '\u0aa8')) ||
          (('\u0aaa' <= yyC) && (yyC <= '\u0ab0')) ||
          (('\u0ab2' <= yyC) && (yyC <= '\u0ab3')) ||
          (('\u0ab5' <= yyC) && (yyC <= '\u0ab9')) ||
          ('\u0abd' == yyC) ||
          ('\u0ad0' == yyC) ||
          (('\u0ae0' <= yyC) && (yyC <= '\u0ae1')) ||
          (('\u0b05' <= yyC) && (yyC <= '\u0b0c')) ||
          (('\u0b0f' <= yyC) && (yyC <= '\u0b10')) ||
          (('\u0b13' <= yyC) && (yyC <= '\u0b28')) ||
          (('\u0b2a' <= yyC) && (yyC <= '\u0b30')) ||
          (('\u0b32' <= yyC) && (yyC <= '\u0b33')) ||
          (('\u0b35' <= yyC) && (yyC <= '\u0b39')) ||
          ('\u0b3d' == yyC) ||
          (('\u0b5c' <= yyC) && (yyC <= '\u0b5d')) ||
          (('\u0b5f' <= yyC) && (yyC <= '\u0b61')) ||
          ('\u0b71' == yyC) ||
          ('\u0b83' == yyC) ||
          (('\u0b85' <= yyC) && (yyC <= '\u0b8a')) ||
          (('\u0b8e' <= yyC) && (yyC <= '\u0b90')) ||
          (('\u0b92' <= yyC) && (yyC <= '\u0b95')) ||
          (('\u0b99' <= yyC) && (yyC <= '\u0b9a')) ||
          ('\u0b9c' == yyC) ||
          (('\u0b9e' <= yyC) && (yyC <= '\u0b9f')) ||
          (('\u0ba3' <= yyC) && (yyC <= '\u0ba4')) ||
          (('\u0ba8' <= yyC) && (yyC <= '\u0baa')) ||
          (('\u0bae' <= yyC) && (yyC <= '\u0bb9')) ||
          (('\u0c05' <= yyC) && (yyC <= '\u0c0c')) ||
          (('\u0c0e' <= yyC) && (yyC <= '\u0c10')) ||
          (('\u0c12' <= yyC) && (yyC <= '\u0c28')) ||
          (('\u0c2a' <= yyC) && (yyC <= '\u0c33')) ||
          (('\u0c35' <= yyC) && (yyC <= '\u0c39')) ||
          (('\u0c60' <= yyC) && (yyC <= '\u0c61')) ||
          (('\u0c85' <= yyC) && (yyC <= '\u0c8c')) ||
          (('\u0c8e' <= yyC) && (yyC <= '\u0c90')) ||
          (('\u0c92' <= yyC) && (yyC <= '\u0ca8')) ||
          (('\u0caa' <= yyC) && (yyC <= '\u0cb3')) ||
          (('\u0cb5' <= yyC) && (yyC <= '\u0cb9')) ||
          ('\u0cbd' == yyC) ||
          ('\u0cde' == yyC) ||
          (('\u0ce0' <= yyC) && (yyC <= '\u0ce1')) ||
          (('\u0d05' <= yyC) && (yyC <= '\u0d0c')) ||
          (('\u0d0e' <= yyC) && (yyC <= '\u0d10')) ||
          (('\u0d12' <= yyC) && (yyC <= '\u0d28')) ||
          (('\u0d2a' <= yyC) && (yyC <= '\u0d39')) ||
          (('\u0d60' <= yyC) && (yyC <= '\u0d61')) ||
          (('\u0d85' <= yyC) && (yyC <= '\u0d96')) ||
          (('\u0d9a' <= yyC) && (yyC <= '\u0db1')) ||
          (('\u0db3' <= yyC) && (yyC <= '\u0dbb')) ||
          ('\u0dbd' == yyC) ||
          (('\u0dc0' <= yyC) && (yyC <= '\u0dc6')) ||
          (('\u0e01' <= yyC) && (yyC <= '\u0e30')) ||
          (('\u0e32' <= yyC) && (yyC <= '\u0e33')) ||
          (('\u0e40' <= yyC) && (yyC <= '\u0e46')) ||
          (('\u0e81' <= yyC) && (yyC <= '\u0e82')) ||
          ('\u0e84' == yyC) ||
          (('\u0e87' <= yyC) && (yyC <= '\u0e88')) ||
          ('\u0e8a' == yyC) ||
          ('\u0e8d' == yyC) ||
          (('\u0e94' <= yyC) && (yyC <= '\u0e97')) ||
          (('\u0e99' <= yyC) && (yyC <= '\u0e9f')) ||
          (('\u0ea1' <= yyC) && (yyC <= '\u0ea3')) ||
          ('\u0ea5' == yyC) ||
          ('\u0ea7' == yyC) ||
          (('\u0eaa' <= yyC) && (yyC <= '\u0eab')) ||
          (('\u0ead' <= yyC) && (yyC <= '\u0eb0')) ||
          (('\u0eb2' <= yyC) && (yyC <= '\u0eb3')) ||
          ('\u0ebd' == yyC) ||
          (('\u0ec0' <= yyC) && (yyC <= '\u0ec4')) ||
          ('\u0ec6' == yyC) ||
          (('\u0edc' <= yyC) && (yyC <= '\u0edd')) ||
          ('\u0f00' == yyC) ||
          (('\u0f40' <= yyC) && (yyC <= '\u0f47')) ||
          (('\u0f49' <= yyC) && (yyC <= '\u0f6a')) ||
          (('\u0f88' <= yyC) && (yyC <= '\u0f8b')) ||
          (('\u1000' <= yyC) && (yyC <= '\u1021')) ||
          (('\u1023' <= yyC) && (yyC <= '\u1027')) ||
          (('\u1029' <= yyC) && (yyC <= '\u102a')) ||
          (('\u1050' <= yyC) && (yyC <= '\u1055')) ||
          (('\u10a0' <= yyC) && (yyC <= '\u10c5')) ||
          (('\u10d0' <= yyC) && (yyC <= '\u10fa')) ||
          ('\u10fc' == yyC) ||
          (('\u1100' <= yyC) && (yyC <= '\u1159')) ||
          (('\u115f' <= yyC) && (yyC <= '\u11a2')) ||
          (('\u11a8' <= yyC) && (yyC <= '\u11f9')) ||
          (('\u1200' <= yyC) && (yyC <= '\u1248')) ||
          (('\u124a' <= yyC) && (yyC <= '\u124d')) ||
          (('\u1250' <= yyC) && (yyC <= '\u1256')) ||
          ('\u1258' == yyC) ||
          (('\u125a' <= yyC) && (yyC <= '\u125d')) ||
          (('\u1260' <= yyC) && (yyC <= '\u1288')) ||
          (('\u128a' <= yyC) && (yyC <= '\u128d')) ||
          (('\u1290' <= yyC) && (yyC <= '\u12b0')) ||
          (('\u12b2' <= yyC) && (yyC <= '\u12b5')) ||
          (('\u12b8' <= yyC) && (yyC <= '\u12be')) ||
          ('\u12c0' == yyC) ||
          (('\u12c2' <= yyC) && (yyC <= '\u12c5')) ||
          (('\u12c8' <= yyC) && (yyC <= '\u12d6')) ||
          (('\u12d8' <= yyC) && (yyC <= '\u1310')) ||
          (('\u1312' <= yyC) && (yyC <= '\u1315')) ||
          (('\u1318' <= yyC) && (yyC <= '\u135a')) ||
          (('\u1380' <= yyC) && (yyC <= '\u138f')) ||
          (('\u13a0' <= yyC) && (yyC <= '\u13f4')) ||
          (('\u1401' <= yyC) && (yyC <= '\u166c')) ||
          (('\u166f' <= yyC) && (yyC <= '\u1676')) ||
          (('\u1681' <= yyC) && (yyC <= '\u169a')) ||
          (('\u16a0' <= yyC) && (yyC <= '\u16ea')) ||
          (('\u16ee' <= yyC) && (yyC <= '\u16f0')) ||
          (('\u1700' <= yyC) && (yyC <= '\u170c')) ||
          (('\u170e' <= yyC) && (yyC <= '\u1711')) ||
          (('\u1720' <= yyC) && (yyC <= '\u1731')) ||
          (('\u1740' <= yyC) && (yyC <= '\u1751')) ||
          (('\u1760' <= yyC) && (yyC <= '\u176c')) ||
          (('\u176e' <= yyC) && (yyC <= '\u1770')) ||
          (('\u1780' <= yyC) && (yyC <= '\u17b3')) ||
          ('\u17d7' == yyC) ||
          ('\u17dc' == yyC) ||
          (('\u1820' <= yyC) && (yyC <= '\u1877')) ||
          (('\u1880' <= yyC) && (yyC <= '\u18a8')) ||
          (('\u1900' <= yyC) && (yyC <= '\u191c')) ||
          (('\u1950' <= yyC) && (yyC <= '\u196d')) ||
          (('\u1970' <= yyC) && (yyC <= '\u1974')) ||
          (('\u1980' <= yyC) && (yyC <= '\u19a9')) ||
          (('\u19c1' <= yyC) && (yyC <= '\u19c7')) ||
          (('\u1a00' <= yyC) && (yyC <= '\u1a16')) ||
          (('\u1b05' <= yyC) && (yyC <= '\u1b33')) ||
          (('\u1b45' <= yyC) && (yyC <= '\u1b4b')) ||
          (('\u1d00' <= yyC) && (yyC <= '\u1dbf')) ||
          (('\u1e00' <= yyC) && (yyC <= '\u1e9b')) ||
          (('\u1ea0' <= yyC) && (yyC <= '\u1ef9')) ||
          (('\u1f00' <= yyC) && (yyC <= '\u1f15')) ||
          (('\u1f18' <= yyC) && (yyC <= '\u1f1d')) ||
          (('\u1f20' <= yyC) && (yyC <= '\u1f45')) ||
          (('\u1f48' <= yyC) && (yyC <= '\u1f4d')) ||
          (('\u1f50' <= yyC) && (yyC <= '\u1f57')) ||
          ('\u1f59' == yyC) ||
          ('\u1f5b' == yyC) ||
          ('\u1f5d' == yyC) ||
          (('\u1f5f' <= yyC) && (yyC <= '\u1f7d')) ||
          (('\u1f80' <= yyC) && (yyC <= '\u1fb4')) ||
          (('\u1fb6' <= yyC) && (yyC <= '\u1fbc')) ||
          ('\u1fbe' == yyC) ||
          (('\u1fc2' <= yyC) && (yyC <= '\u1fc4')) ||
          (('\u1fc6' <= yyC) && (yyC <= '\u1fcc')) ||
          (('\u1fd0' <= yyC) && (yyC <= '\u1fd3')) ||
          (('\u1fd6' <= yyC) && (yyC <= '\u1fdb')) ||
          (('\u1fe0' <= yyC) && (yyC <= '\u1fec')) ||
          (('\u1ff2' <= yyC) && (yyC <= '\u1ff4')) ||
          (('\u1ff6' <= yyC) && (yyC <= '\u1ffc')) ||
          ('\u2071' == yyC) ||
          ('\u207f' == yyC) ||
          (('\u2090' <= yyC) && (yyC <= '\u2094')) ||
          ('\u2102' == yyC) ||
          ('\u2107' == yyC) ||
          (('\u210a' <= yyC) && (yyC <= '\u2113')) ||
          ('\u2115' == yyC) ||
          (('\u2119' <= yyC) && (yyC <= '\u211d')) ||
          ('\u2124' == yyC) ||
          ('\u2126' == yyC) ||
          ('\u2128' == yyC) ||
          (('\u212a' <= yyC) && (yyC <= '\u212d')) ||
          (('\u212f' <= yyC) && (yyC <= '\u2139')) ||
          (('\u213c' <= yyC) && (yyC <= '\u213f')) ||
          (('\u2145' <= yyC) && (yyC <= '\u2149')) ||
          ('\u214e' == yyC) ||
          (('\u2160' <= yyC) && (yyC <= '\u2184')) ||
          (('\u2c00' <= yyC) && (yyC <= '\u2c2e')) ||
          (('\u2c30' <= yyC) && (yyC <= '\u2c5e')) ||
          (('\u2c60' <= yyC) && (yyC <= '\u2c6c')) ||
          (('\u2c74' <= yyC) && (yyC <= '\u2c77')) ||
          (('\u2c80' <= yyC) && (yyC <= '\u2ce4')) ||
          (('\u2d00' <= yyC) && (yyC <= '\u2d25')) ||
          (('\u2d30' <= yyC) && (yyC <= '\u2d65')) ||
          ('\u2d6f' == yyC) ||
          (('\u2d80' <= yyC) && (yyC <= '\u2d96')) ||
          (('\u2da0' <= yyC) && (yyC <= '\u2da6')) ||
          (('\u2da8' <= yyC) && (yyC <= '\u2dae')) ||
          (('\u2db0' <= yyC) && (yyC <= '\u2db6')) ||
          (('\u2db8' <= yyC) && (yyC <= '\u2dbe')) ||
          (('\u2dc0' <= yyC) && (yyC <= '\u2dc6')) ||
          (('\u2dc8' <= yyC) && (yyC <= '\u2dce')) ||
          (('\u2dd0' <= yyC) && (yyC <= '\u2dd6')) ||
          (('\u2dd8' <= yyC) && (yyC <= '\u2dde')) ||
          (('\u3005' <= yyC) && (yyC <= '\u3007')) ||
          (('\u3021' <= yyC) && (yyC <= '\u3029')) ||
          (('\u3031' <= yyC) && (yyC <= '\u3035')) ||
          (('\u3038' <= yyC) && (yyC <= '\u303c')) ||
          (('\u3041' <= yyC) && (yyC <= '\u3096')) ||
          (('\u309d' <= yyC) && (yyC <= '\u309f')) ||
          (('\u30a1' <= yyC) && (yyC <= '\u30fa')) ||
          (('\u30fc' <= yyC) && (yyC <= '\u30ff')) ||
          (('\u3105' <= yyC) && (yyC <= '\u312c')) ||
          (('\u3131' <= yyC) && (yyC <= '\u318e')) ||
          (('\u31a0' <= yyC) && (yyC <= '\u31b7')) ||
          (('\u31f0' <= yyC) && (yyC <= '\u31ff')) ||
          ('\u3400' == yyC) ||
          ('\u4db5' == yyC) ||
          ('\u4e00' == yyC) ||
          ('\u9fbb' == yyC) ||
          (('\ua000' <= yyC) && (yyC <= '\ua48c')) ||
          (('\ua717' <= yyC) && (yyC <= '\ua71a')) ||
          (('\ua800' <= yyC) && (yyC <= '\ua801')) ||
          (('\ua803' <= yyC) && (yyC <= '\ua805')) ||
          (('\ua807' <= yyC) && (yyC <= '\ua80a')) ||
          (('\ua80c' <= yyC) && (yyC <= '\ua822')) ||
          (('\ua840' <= yyC) && (yyC <= '\ua873')) ||
          ('\uac00' == yyC) ||
          ('\ud7a3' == yyC) ||
          (('\uf900' <= yyC) && (yyC <= '\ufa2d')) ||
          (('\ufa30' <= yyC) && (yyC <= '\ufa6a')) ||
          (('\ufa70' <= yyC) && (yyC <= '\ufad9')) ||
          (('\ufb00' <= yyC) && (yyC <= '\ufb06')) ||
          (('\ufb13' <= yyC) && (yyC <= '\ufb17')) ||
          ('\ufb1d' == yyC) ||
          (('\ufb1f' <= yyC) && (yyC <= '\ufb28')) ||
          (('\ufb2a' <= yyC) && (yyC <= '\ufb36')) ||
          (('\ufb38' <= yyC) && (yyC <= '\ufb3c')) ||
          ('\ufb3e' == yyC) ||
          (('\ufb40' <= yyC) && (yyC <= '\ufb41')) ||
          (('\ufb43' <= yyC) && (yyC <= '\ufb44')) ||
          (('\ufb46' <= yyC) && (yyC <= '\ufbb1')) ||
          (('\ufbd3' <= yyC) && (yyC <= '\ufd3d')) ||
          (('\ufd50' <= yyC) && (yyC <= '\ufd8f')) ||
          (('\ufd92' <= yyC) && (yyC <= '\ufdc7')) ||
          (('\ufdf0' <= yyC) && (yyC <= '\ufdfb')) ||
          (('\ufe70' <= yyC) && (yyC <= '\ufe74')) ||
          (('\ufe76' <= yyC) && (yyC <= '\ufefc')) ||
          (('\uff21' <= yyC) && (yyC <= '\uff3a')) ||
          (('\uff41' <= yyC) && (yyC <= '\uff5a')) ||
          (('\uff66' <= yyC) && (yyC <= '\uffbe')) ||
          (('\uffc2' <= yyC) && (yyC <= '\uffc7')) ||
          (('\uffca' <= yyC) && (yyC <= '\uffcf')) ||
          (('\uffd2' <= yyC) && (yyC <= '\uffd7')) ||
          (('\uffda' <= yyC) && (yyC <= '\uffdc'))) {

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud800':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc0b')) ||
                (('\udc0d' <= yyC) && (yyC <= '\udc26')) ||
                (('\udc28' <= yyC) && (yyC <= '\udc3a')) ||
                (('\udc3c' <= yyC) && (yyC <= '\udc3d')) ||
                (('\udc3f' <= yyC) && (yyC <= '\udc4d')) ||
                (('\udc50' <= yyC) && (yyC <= '\udc5d')) ||
                (('\udc80' <= yyC) && (yyC <= '\udcfa')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd74')) ||
                (('\udf00' <= yyC) && (yyC <= '\udf1e')) ||
                (('\udf30' <= yyC) && (yyC <= '\udf4a')) ||
                (('\udf80' <= yyC) && (yyC <= '\udf9d')) ||
                (('\udfa0' <= yyC) && (yyC <= '\udfc3')) ||
                (('\udfc8' <= yyC) && (yyC <= '\udfcf')) ||
                (('\udfd1' <= yyC) && (yyC <= '\udfd5'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc9d')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc05')) ||
                ('\udc08' == yyC) ||
                (('\udc0a' <= yyC) && (yyC <= '\udc35')) ||
                (('\udc37' <= yyC) && (yyC <= '\udc38')) ||
                ('\udc3c' == yyC) ||
                ('\udc3f' == yyC) ||
                (('\udd00' <= yyC) && (yyC <= '\udd15')) ||
                ('\ude00' == yyC) ||
                (('\ude10' <= yyC) && (yyC <= '\ude13')) ||
                (('\ude15' <= yyC) && (yyC <= '\ude17')) ||
                (('\ude19' <= yyC) && (yyC <= '\ude33'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud808':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udf6e')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud809':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc62')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc54')) ||
                (('\udc56' <= yyC) && (yyC <= '\udc9c')) ||
                (('\udc9e' <= yyC) && (yyC <= '\udc9f')) ||
                ('\udca2' == yyC) ||
                (('\udca5' <= yyC) && (yyC <= '\udca6')) ||
                (('\udca9' <= yyC) && (yyC <= '\udcac')) ||
                (('\udcae' <= yyC) && (yyC <= '\udcb9')) ||
                ('\udcbb' == yyC) ||
                (('\udcbd' <= yyC) && (yyC <= '\udcc3')) ||
                (('\udcc5' <= yyC) && (yyC <= '\udd05')) ||
                (('\udd07' <= yyC) && (yyC <= '\udd0a')) ||
                (('\udd0d' <= yyC) && (yyC <= '\udd14')) ||
                (('\udd16' <= yyC) && (yyC <= '\udd1c')) ||
                (('\udd1e' <= yyC) && (yyC <= '\udd39')) ||
                (('\udd3b' <= yyC) && (yyC <= '\udd3e')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd44')) ||
                ('\udd46' == yyC) ||
                (('\udd4a' <= yyC) && (yyC <= '\udd50')) ||
                (('\udd52' <= yyC) && (yyC <= '\udea5')) ||
                (('\udea8' <= yyC) && (yyC <= '\udec0')) ||
                (('\udec2' <= yyC) && (yyC <= '\udeda')) ||
                (('\udedc' <= yyC) && (yyC <= '\udefa')) ||
                (('\udefc' <= yyC) && (yyC <= '\udf14')) ||
                (('\udf16' <= yyC) && (yyC <= '\udf34')) ||
                (('\udf36' <= yyC) && (yyC <= '\udf4e')) ||
                (('\udf50' <= yyC) && (yyC <= '\udf6e')) ||
                (('\udf70' <= yyC) && (yyC <= '\udf88')) ||
                (('\udf8a' <= yyC) && (yyC <= '\udfa8')) ||
                (('\udfaa' <= yyC) && (yyC <= '\udfc2')) ||
                (('\udfc4' <= yyC) && (yyC <= '\udfcb'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud840':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\udc00' == yyC) {

              yyValue = "\ud840\udc00";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud869':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\uded6' == yyC) {

              yyValue = "\ud869\uded6";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud87e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\ude1d')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '_':
        {
          yyValue = "_";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("idstart expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.idrest.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidrest(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fidrest) 
      yyColumn.chunk26.fidrest = pidrest$1(yyStart);
    return yyColumn.chunk26.fidrest;
  }

  /** Actually parse Identifier.idrest. */
  private Result pidrest$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z')) ||
          ('\u00aa' == yyC) ||
          ('\u00b5' == yyC) ||
          ('\u00ba' == yyC) ||
          (('\u00c0' <= yyC) && (yyC <= '\u00d6')) ||
          (('\u00d8' <= yyC) && (yyC <= '\u00f6')) ||
          (('\u00f8' <= yyC) && (yyC <= '\u02c1')) ||
          (('\u02c6' <= yyC) && (yyC <= '\u02d1')) ||
          (('\u02e0' <= yyC) && (yyC <= '\u02e4')) ||
          ('\u02ee' == yyC) ||
          (('\u037a' <= yyC) && (yyC <= '\u037d')) ||
          ('\u0386' == yyC) ||
          (('\u0388' <= yyC) && (yyC <= '\u038a')) ||
          ('\u038c' == yyC) ||
          (('\u038e' <= yyC) && (yyC <= '\u03a1')) ||
          (('\u03a3' <= yyC) && (yyC <= '\u03ce')) ||
          (('\u03d0' <= yyC) && (yyC <= '\u03f5')) ||
          (('\u03f7' <= yyC) && (yyC <= '\u0481')) ||
          (('\u048a' <= yyC) && (yyC <= '\u0513')) ||
          (('\u0531' <= yyC) && (yyC <= '\u0556')) ||
          ('\u0559' == yyC) ||
          (('\u0561' <= yyC) && (yyC <= '\u0587')) ||
          (('\u05d0' <= yyC) && (yyC <= '\u05ea')) ||
          (('\u05f0' <= yyC) && (yyC <= '\u05f2')) ||
          (('\u0621' <= yyC) && (yyC <= '\u063a')) ||
          (('\u0640' <= yyC) && (yyC <= '\u064a')) ||
          (('\u066e' <= yyC) && (yyC <= '\u066f')) ||
          (('\u0671' <= yyC) && (yyC <= '\u06d3')) ||
          ('\u06d5' == yyC) ||
          (('\u06e5' <= yyC) && (yyC <= '\u06e6')) ||
          (('\u06ee' <= yyC) && (yyC <= '\u06ef')) ||
          (('\u06fa' <= yyC) && (yyC <= '\u06fc')) ||
          ('\u06ff' == yyC) ||
          ('\u0710' == yyC) ||
          (('\u0712' <= yyC) && (yyC <= '\u072f')) ||
          (('\u074d' <= yyC) && (yyC <= '\u076d')) ||
          (('\u0780' <= yyC) && (yyC <= '\u07a5')) ||
          ('\u07b1' == yyC) ||
          (('\u07ca' <= yyC) && (yyC <= '\u07ea')) ||
          (('\u07f4' <= yyC) && (yyC <= '\u07f5')) ||
          ('\u07fa' == yyC) ||
          (('\u0904' <= yyC) && (yyC <= '\u0939')) ||
          ('\u093d' == yyC) ||
          ('\u0950' == yyC) ||
          (('\u0958' <= yyC) && (yyC <= '\u0961')) ||
          (('\u097b' <= yyC) && (yyC <= '\u097f')) ||
          (('\u0985' <= yyC) && (yyC <= '\u098c')) ||
          (('\u098f' <= yyC) && (yyC <= '\u0990')) ||
          (('\u0993' <= yyC) && (yyC <= '\u09a8')) ||
          (('\u09aa' <= yyC) && (yyC <= '\u09b0')) ||
          ('\u09b2' == yyC) ||
          (('\u09b6' <= yyC) && (yyC <= '\u09b9')) ||
          ('\u09bd' == yyC) ||
          ('\u09ce' == yyC) ||
          (('\u09dc' <= yyC) && (yyC <= '\u09dd')) ||
          (('\u09df' <= yyC) && (yyC <= '\u09e1')) ||
          (('\u09f0' <= yyC) && (yyC <= '\u09f1')) ||
          (('\u0a05' <= yyC) && (yyC <= '\u0a0a')) ||
          (('\u0a0f' <= yyC) && (yyC <= '\u0a10')) ||
          (('\u0a13' <= yyC) && (yyC <= '\u0a28')) ||
          (('\u0a2a' <= yyC) && (yyC <= '\u0a30')) ||
          (('\u0a32' <= yyC) && (yyC <= '\u0a33')) ||
          (('\u0a35' <= yyC) && (yyC <= '\u0a36')) ||
          (('\u0a38' <= yyC) && (yyC <= '\u0a39')) ||
          (('\u0a59' <= yyC) && (yyC <= '\u0a5c')) ||
          ('\u0a5e' == yyC) ||
          (('\u0a72' <= yyC) && (yyC <= '\u0a74')) ||
          (('\u0a85' <= yyC) && (yyC <= '\u0a8d')) ||
          (('\u0a8f' <= yyC) && (yyC <= '\u0a91')) ||
          (('\u0a93' <= yyC) && (yyC <= '\u0aa8')) ||
          (('\u0aaa' <= yyC) && (yyC <= '\u0ab0')) ||
          (('\u0ab2' <= yyC) && (yyC <= '\u0ab3')) ||
          (('\u0ab5' <= yyC) && (yyC <= '\u0ab9')) ||
          ('\u0abd' == yyC) ||
          ('\u0ad0' == yyC) ||
          (('\u0ae0' <= yyC) && (yyC <= '\u0ae1')) ||
          (('\u0b05' <= yyC) && (yyC <= '\u0b0c')) ||
          (('\u0b0f' <= yyC) && (yyC <= '\u0b10')) ||
          (('\u0b13' <= yyC) && (yyC <= '\u0b28')) ||
          (('\u0b2a' <= yyC) && (yyC <= '\u0b30')) ||
          (('\u0b32' <= yyC) && (yyC <= '\u0b33')) ||
          (('\u0b35' <= yyC) && (yyC <= '\u0b39')) ||
          ('\u0b3d' == yyC) ||
          (('\u0b5c' <= yyC) && (yyC <= '\u0b5d')) ||
          (('\u0b5f' <= yyC) && (yyC <= '\u0b61')) ||
          ('\u0b71' == yyC) ||
          ('\u0b83' == yyC) ||
          (('\u0b85' <= yyC) && (yyC <= '\u0b8a')) ||
          (('\u0b8e' <= yyC) && (yyC <= '\u0b90')) ||
          (('\u0b92' <= yyC) && (yyC <= '\u0b95')) ||
          (('\u0b99' <= yyC) && (yyC <= '\u0b9a')) ||
          ('\u0b9c' == yyC) ||
          (('\u0b9e' <= yyC) && (yyC <= '\u0b9f')) ||
          (('\u0ba3' <= yyC) && (yyC <= '\u0ba4')) ||
          (('\u0ba8' <= yyC) && (yyC <= '\u0baa')) ||
          (('\u0bae' <= yyC) && (yyC <= '\u0bb9')) ||
          (('\u0c05' <= yyC) && (yyC <= '\u0c0c')) ||
          (('\u0c0e' <= yyC) && (yyC <= '\u0c10')) ||
          (('\u0c12' <= yyC) && (yyC <= '\u0c28')) ||
          (('\u0c2a' <= yyC) && (yyC <= '\u0c33')) ||
          (('\u0c35' <= yyC) && (yyC <= '\u0c39')) ||
          (('\u0c60' <= yyC) && (yyC <= '\u0c61')) ||
          (('\u0c85' <= yyC) && (yyC <= '\u0c8c')) ||
          (('\u0c8e' <= yyC) && (yyC <= '\u0c90')) ||
          (('\u0c92' <= yyC) && (yyC <= '\u0ca8')) ||
          (('\u0caa' <= yyC) && (yyC <= '\u0cb3')) ||
          (('\u0cb5' <= yyC) && (yyC <= '\u0cb9')) ||
          ('\u0cbd' == yyC) ||
          ('\u0cde' == yyC) ||
          (('\u0ce0' <= yyC) && (yyC <= '\u0ce1')) ||
          (('\u0d05' <= yyC) && (yyC <= '\u0d0c')) ||
          (('\u0d0e' <= yyC) && (yyC <= '\u0d10')) ||
          (('\u0d12' <= yyC) && (yyC <= '\u0d28')) ||
          (('\u0d2a' <= yyC) && (yyC <= '\u0d39')) ||
          (('\u0d60' <= yyC) && (yyC <= '\u0d61')) ||
          (('\u0d85' <= yyC) && (yyC <= '\u0d96')) ||
          (('\u0d9a' <= yyC) && (yyC <= '\u0db1')) ||
          (('\u0db3' <= yyC) && (yyC <= '\u0dbb')) ||
          ('\u0dbd' == yyC) ||
          (('\u0dc0' <= yyC) && (yyC <= '\u0dc6')) ||
          (('\u0e01' <= yyC) && (yyC <= '\u0e30')) ||
          (('\u0e32' <= yyC) && (yyC <= '\u0e33')) ||
          (('\u0e40' <= yyC) && (yyC <= '\u0e46')) ||
          (('\u0e81' <= yyC) && (yyC <= '\u0e82')) ||
          ('\u0e84' == yyC) ||
          (('\u0e87' <= yyC) && (yyC <= '\u0e88')) ||
          ('\u0e8a' == yyC) ||
          ('\u0e8d' == yyC) ||
          (('\u0e94' <= yyC) && (yyC <= '\u0e97')) ||
          (('\u0e99' <= yyC) && (yyC <= '\u0e9f')) ||
          (('\u0ea1' <= yyC) && (yyC <= '\u0ea3')) ||
          ('\u0ea5' == yyC) ||
          ('\u0ea7' == yyC) ||
          (('\u0eaa' <= yyC) && (yyC <= '\u0eab')) ||
          (('\u0ead' <= yyC) && (yyC <= '\u0eb0')) ||
          (('\u0eb2' <= yyC) && (yyC <= '\u0eb3')) ||
          ('\u0ebd' == yyC) ||
          (('\u0ec0' <= yyC) && (yyC <= '\u0ec4')) ||
          ('\u0ec6' == yyC) ||
          (('\u0edc' <= yyC) && (yyC <= '\u0edd')) ||
          ('\u0f00' == yyC) ||
          (('\u0f40' <= yyC) && (yyC <= '\u0f47')) ||
          (('\u0f49' <= yyC) && (yyC <= '\u0f6a')) ||
          (('\u0f88' <= yyC) && (yyC <= '\u0f8b')) ||
          (('\u1000' <= yyC) && (yyC <= '\u1021')) ||
          (('\u1023' <= yyC) && (yyC <= '\u1027')) ||
          (('\u1029' <= yyC) && (yyC <= '\u102a')) ||
          (('\u1050' <= yyC) && (yyC <= '\u1055')) ||
          (('\u10a0' <= yyC) && (yyC <= '\u10c5')) ||
          (('\u10d0' <= yyC) && (yyC <= '\u10fa')) ||
          ('\u10fc' == yyC) ||
          (('\u1100' <= yyC) && (yyC <= '\u1159')) ||
          (('\u115f' <= yyC) && (yyC <= '\u11a2')) ||
          (('\u11a8' <= yyC) && (yyC <= '\u11f9')) ||
          (('\u1200' <= yyC) && (yyC <= '\u1248')) ||
          (('\u124a' <= yyC) && (yyC <= '\u124d')) ||
          (('\u1250' <= yyC) && (yyC <= '\u1256')) ||
          ('\u1258' == yyC) ||
          (('\u125a' <= yyC) && (yyC <= '\u125d')) ||
          (('\u1260' <= yyC) && (yyC <= '\u1288')) ||
          (('\u128a' <= yyC) && (yyC <= '\u128d')) ||
          (('\u1290' <= yyC) && (yyC <= '\u12b0')) ||
          (('\u12b2' <= yyC) && (yyC <= '\u12b5')) ||
          (('\u12b8' <= yyC) && (yyC <= '\u12be')) ||
          ('\u12c0' == yyC) ||
          (('\u12c2' <= yyC) && (yyC <= '\u12c5')) ||
          (('\u12c8' <= yyC) && (yyC <= '\u12d6')) ||
          (('\u12d8' <= yyC) && (yyC <= '\u1310')) ||
          (('\u1312' <= yyC) && (yyC <= '\u1315')) ||
          (('\u1318' <= yyC) && (yyC <= '\u135a')) ||
          (('\u1380' <= yyC) && (yyC <= '\u138f')) ||
          (('\u13a0' <= yyC) && (yyC <= '\u13f4')) ||
          (('\u1401' <= yyC) && (yyC <= '\u166c')) ||
          (('\u166f' <= yyC) && (yyC <= '\u1676')) ||
          (('\u1681' <= yyC) && (yyC <= '\u169a')) ||
          (('\u16a0' <= yyC) && (yyC <= '\u16ea')) ||
          (('\u16ee' <= yyC) && (yyC <= '\u16f0')) ||
          (('\u1700' <= yyC) && (yyC <= '\u170c')) ||
          (('\u170e' <= yyC) && (yyC <= '\u1711')) ||
          (('\u1720' <= yyC) && (yyC <= '\u1731')) ||
          (('\u1740' <= yyC) && (yyC <= '\u1751')) ||
          (('\u1760' <= yyC) && (yyC <= '\u176c')) ||
          (('\u176e' <= yyC) && (yyC <= '\u1770')) ||
          (('\u1780' <= yyC) && (yyC <= '\u17b3')) ||
          ('\u17d7' == yyC) ||
          ('\u17dc' == yyC) ||
          (('\u1820' <= yyC) && (yyC <= '\u1877')) ||
          (('\u1880' <= yyC) && (yyC <= '\u18a8')) ||
          (('\u1900' <= yyC) && (yyC <= '\u191c')) ||
          (('\u1950' <= yyC) && (yyC <= '\u196d')) ||
          (('\u1970' <= yyC) && (yyC <= '\u1974')) ||
          (('\u1980' <= yyC) && (yyC <= '\u19a9')) ||
          (('\u19c1' <= yyC) && (yyC <= '\u19c7')) ||
          (('\u1a00' <= yyC) && (yyC <= '\u1a16')) ||
          (('\u1b05' <= yyC) && (yyC <= '\u1b33')) ||
          (('\u1b45' <= yyC) && (yyC <= '\u1b4b')) ||
          (('\u1d00' <= yyC) && (yyC <= '\u1dbf')) ||
          (('\u1e00' <= yyC) && (yyC <= '\u1e9b')) ||
          (('\u1ea0' <= yyC) && (yyC <= '\u1ef9')) ||
          (('\u1f00' <= yyC) && (yyC <= '\u1f15')) ||
          (('\u1f18' <= yyC) && (yyC <= '\u1f1d')) ||
          (('\u1f20' <= yyC) && (yyC <= '\u1f45')) ||
          (('\u1f48' <= yyC) && (yyC <= '\u1f4d')) ||
          (('\u1f50' <= yyC) && (yyC <= '\u1f57')) ||
          ('\u1f59' == yyC) ||
          ('\u1f5b' == yyC) ||
          ('\u1f5d' == yyC) ||
          (('\u1f5f' <= yyC) && (yyC <= '\u1f7d')) ||
          (('\u1f80' <= yyC) && (yyC <= '\u1fb4')) ||
          (('\u1fb6' <= yyC) && (yyC <= '\u1fbc')) ||
          ('\u1fbe' == yyC) ||
          (('\u1fc2' <= yyC) && (yyC <= '\u1fc4')) ||
          (('\u1fc6' <= yyC) && (yyC <= '\u1fcc')) ||
          (('\u1fd0' <= yyC) && (yyC <= '\u1fd3')) ||
          (('\u1fd6' <= yyC) && (yyC <= '\u1fdb')) ||
          (('\u1fe0' <= yyC) && (yyC <= '\u1fec')) ||
          (('\u1ff2' <= yyC) && (yyC <= '\u1ff4')) ||
          (('\u1ff6' <= yyC) && (yyC <= '\u1ffc')) ||
          ('\u2071' == yyC) ||
          ('\u207f' == yyC) ||
          (('\u2090' <= yyC) && (yyC <= '\u2094')) ||
          ('\u2102' == yyC) ||
          ('\u2107' == yyC) ||
          (('\u210a' <= yyC) && (yyC <= '\u2113')) ||
          ('\u2115' == yyC) ||
          (('\u2119' <= yyC) && (yyC <= '\u211d')) ||
          ('\u2124' == yyC) ||
          ('\u2126' == yyC) ||
          ('\u2128' == yyC) ||
          (('\u212a' <= yyC) && (yyC <= '\u212d')) ||
          (('\u212f' <= yyC) && (yyC <= '\u2139')) ||
          (('\u213c' <= yyC) && (yyC <= '\u213f')) ||
          (('\u2145' <= yyC) && (yyC <= '\u2149')) ||
          ('\u214e' == yyC) ||
          (('\u2160' <= yyC) && (yyC <= '\u2184')) ||
          (('\u2c00' <= yyC) && (yyC <= '\u2c2e')) ||
          (('\u2c30' <= yyC) && (yyC <= '\u2c5e')) ||
          (('\u2c60' <= yyC) && (yyC <= '\u2c6c')) ||
          (('\u2c74' <= yyC) && (yyC <= '\u2c77')) ||
          (('\u2c80' <= yyC) && (yyC <= '\u2ce4')) ||
          (('\u2d00' <= yyC) && (yyC <= '\u2d25')) ||
          (('\u2d30' <= yyC) && (yyC <= '\u2d65')) ||
          ('\u2d6f' == yyC) ||
          (('\u2d80' <= yyC) && (yyC <= '\u2d96')) ||
          (('\u2da0' <= yyC) && (yyC <= '\u2da6')) ||
          (('\u2da8' <= yyC) && (yyC <= '\u2dae')) ||
          (('\u2db0' <= yyC) && (yyC <= '\u2db6')) ||
          (('\u2db8' <= yyC) && (yyC <= '\u2dbe')) ||
          (('\u2dc0' <= yyC) && (yyC <= '\u2dc6')) ||
          (('\u2dc8' <= yyC) && (yyC <= '\u2dce')) ||
          (('\u2dd0' <= yyC) && (yyC <= '\u2dd6')) ||
          (('\u2dd8' <= yyC) && (yyC <= '\u2dde')) ||
          (('\u3005' <= yyC) && (yyC <= '\u3007')) ||
          (('\u3021' <= yyC) && (yyC <= '\u3029')) ||
          (('\u3031' <= yyC) && (yyC <= '\u3035')) ||
          (('\u3038' <= yyC) && (yyC <= '\u303c')) ||
          (('\u3041' <= yyC) && (yyC <= '\u3096')) ||
          (('\u309d' <= yyC) && (yyC <= '\u309f')) ||
          (('\u30a1' <= yyC) && (yyC <= '\u30fa')) ||
          (('\u30fc' <= yyC) && (yyC <= '\u30ff')) ||
          (('\u3105' <= yyC) && (yyC <= '\u312c')) ||
          (('\u3131' <= yyC) && (yyC <= '\u318e')) ||
          (('\u31a0' <= yyC) && (yyC <= '\u31b7')) ||
          (('\u31f0' <= yyC) && (yyC <= '\u31ff')) ||
          ('\u3400' == yyC) ||
          ('\u4db5' == yyC) ||
          ('\u4e00' == yyC) ||
          ('\u9fbb' == yyC) ||
          (('\ua000' <= yyC) && (yyC <= '\ua48c')) ||
          (('\ua717' <= yyC) && (yyC <= '\ua71a')) ||
          (('\ua800' <= yyC) && (yyC <= '\ua801')) ||
          (('\ua803' <= yyC) && (yyC <= '\ua805')) ||
          (('\ua807' <= yyC) && (yyC <= '\ua80a')) ||
          (('\ua80c' <= yyC) && (yyC <= '\ua822')) ||
          (('\ua840' <= yyC) && (yyC <= '\ua873')) ||
          ('\uac00' == yyC) ||
          ('\ud7a3' == yyC) ||
          (('\uf900' <= yyC) && (yyC <= '\ufa2d')) ||
          (('\ufa30' <= yyC) && (yyC <= '\ufa6a')) ||
          (('\ufa70' <= yyC) && (yyC <= '\ufad9')) ||
          (('\ufb00' <= yyC) && (yyC <= '\ufb06')) ||
          (('\ufb13' <= yyC) && (yyC <= '\ufb17')) ||
          ('\ufb1d' == yyC) ||
          (('\ufb1f' <= yyC) && (yyC <= '\ufb28')) ||
          (('\ufb2a' <= yyC) && (yyC <= '\ufb36')) ||
          (('\ufb38' <= yyC) && (yyC <= '\ufb3c')) ||
          ('\ufb3e' == yyC) ||
          (('\ufb40' <= yyC) && (yyC <= '\ufb41')) ||
          (('\ufb43' <= yyC) && (yyC <= '\ufb44')) ||
          (('\ufb46' <= yyC) && (yyC <= '\ufbb1')) ||
          (('\ufbd3' <= yyC) && (yyC <= '\ufd3d')) ||
          (('\ufd50' <= yyC) && (yyC <= '\ufd8f')) ||
          (('\ufd92' <= yyC) && (yyC <= '\ufdc7')) ||
          (('\ufdf0' <= yyC) && (yyC <= '\ufdfb')) ||
          (('\ufe70' <= yyC) && (yyC <= '\ufe74')) ||
          (('\ufe76' <= yyC) && (yyC <= '\ufefc')) ||
          (('\uff21' <= yyC) && (yyC <= '\uff3a')) ||
          (('\uff41' <= yyC) && (yyC <= '\uff5a')) ||
          (('\uff66' <= yyC) && (yyC <= '\uffbe')) ||
          (('\uffc2' <= yyC) && (yyC <= '\uffc7')) ||
          (('\uffca' <= yyC) && (yyC <= '\uffcf')) ||
          (('\uffd2' <= yyC) && (yyC <= '\uffd7')) ||
          (('\uffda' <= yyC) && (yyC <= '\uffdc'))) {

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud800':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc0b')) ||
                (('\udc0d' <= yyC) && (yyC <= '\udc26')) ||
                (('\udc28' <= yyC) && (yyC <= '\udc3a')) ||
                (('\udc3c' <= yyC) && (yyC <= '\udc3d')) ||
                (('\udc3f' <= yyC) && (yyC <= '\udc4d')) ||
                (('\udc50' <= yyC) && (yyC <= '\udc5d')) ||
                (('\udc80' <= yyC) && (yyC <= '\udcfa')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd74')) ||
                (('\udf00' <= yyC) && (yyC <= '\udf1e')) ||
                (('\udf30' <= yyC) && (yyC <= '\udf4a')) ||
                (('\udf80' <= yyC) && (yyC <= '\udf9d')) ||
                (('\udfa0' <= yyC) && (yyC <= '\udfc3')) ||
                (('\udfc8' <= yyC) && (yyC <= '\udfcf')) ||
                (('\udfd1' <= yyC) && (yyC <= '\udfd5'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc9d')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc05')) ||
                ('\udc08' == yyC) ||
                (('\udc0a' <= yyC) && (yyC <= '\udc35')) ||
                (('\udc37' <= yyC) && (yyC <= '\udc38')) ||
                ('\udc3c' == yyC) ||
                ('\udc3f' == yyC) ||
                (('\udd00' <= yyC) && (yyC <= '\udd15')) ||
                ('\ude00' == yyC) ||
                (('\ude10' <= yyC) && (yyC <= '\ude13')) ||
                (('\ude15' <= yyC) && (yyC <= '\ude17')) ||
                (('\ude19' <= yyC) && (yyC <= '\ude33'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud808':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udf6e')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud809':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc62')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc54')) ||
                (('\udc56' <= yyC) && (yyC <= '\udc9c')) ||
                (('\udc9e' <= yyC) && (yyC <= '\udc9f')) ||
                ('\udca2' == yyC) ||
                (('\udca5' <= yyC) && (yyC <= '\udca6')) ||
                (('\udca9' <= yyC) && (yyC <= '\udcac')) ||
                (('\udcae' <= yyC) && (yyC <= '\udcb9')) ||
                ('\udcbb' == yyC) ||
                (('\udcbd' <= yyC) && (yyC <= '\udcc3')) ||
                (('\udcc5' <= yyC) && (yyC <= '\udd05')) ||
                (('\udd07' <= yyC) && (yyC <= '\udd0a')) ||
                (('\udd0d' <= yyC) && (yyC <= '\udd14')) ||
                (('\udd16' <= yyC) && (yyC <= '\udd1c')) ||
                (('\udd1e' <= yyC) && (yyC <= '\udd39')) ||
                (('\udd3b' <= yyC) && (yyC <= '\udd3e')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd44')) ||
                ('\udd46' == yyC) ||
                (('\udd4a' <= yyC) && (yyC <= '\udd50')) ||
                (('\udd52' <= yyC) && (yyC <= '\udea5')) ||
                (('\udea8' <= yyC) && (yyC <= '\udec0')) ||
                (('\udec2' <= yyC) && (yyC <= '\udeda')) ||
                (('\udedc' <= yyC) && (yyC <= '\udefa')) ||
                (('\udefc' <= yyC) && (yyC <= '\udf14')) ||
                (('\udf16' <= yyC) && (yyC <= '\udf34')) ||
                (('\udf36' <= yyC) && (yyC <= '\udf4e')) ||
                (('\udf50' <= yyC) && (yyC <= '\udf6e')) ||
                (('\udf70' <= yyC) && (yyC <= '\udf88')) ||
                (('\udf8a' <= yyC) && (yyC <= '\udfa8')) ||
                (('\udfaa' <= yyC) && (yyC <= '\udfc2')) ||
                (('\udfc4' <= yyC) && (yyC <= '\udfcb'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud840':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\udc00' == yyC) {

              yyValue = "\ud840\udc00";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud869':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\uded6' == yyC) {

              yyValue = "\ud869\uded6";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud87e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\ude1d')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\'':
        {
          yyValue = "\'";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          ('_' == yyC) ||
          ('\u00ad' == yyC) ||
          (('\u0300' <= yyC) && (yyC <= '\u036f')) ||
          (('\u0483' <= yyC) && (yyC <= '\u0486')) ||
          (('\u0591' <= yyC) && (yyC <= '\u05bd')) ||
          ('\u05bf' == yyC) ||
          (('\u05c1' <= yyC) && (yyC <= '\u05c2')) ||
          (('\u05c4' <= yyC) && (yyC <= '\u05c5')) ||
          ('\u05c7' == yyC) ||
          (('\u0600' <= yyC) && (yyC <= '\u0603')) ||
          (('\u0610' <= yyC) && (yyC <= '\u0615')) ||
          (('\u064b' <= yyC) && (yyC <= '\u065e')) ||
          (('\u0660' <= yyC) && (yyC <= '\u0669')) ||
          ('\u0670' == yyC) ||
          (('\u06d6' <= yyC) && (yyC <= '\u06dd')) ||
          (('\u06df' <= yyC) && (yyC <= '\u06e4')) ||
          (('\u06e7' <= yyC) && (yyC <= '\u06e8')) ||
          (('\u06ea' <= yyC) && (yyC <= '\u06ed')) ||
          (('\u06f0' <= yyC) && (yyC <= '\u06f9')) ||
          ('\u070f' == yyC) ||
          ('\u0711' == yyC) ||
          (('\u0730' <= yyC) && (yyC <= '\u074a')) ||
          (('\u07a6' <= yyC) && (yyC <= '\u07b0')) ||
          (('\u07c0' <= yyC) && (yyC <= '\u07c9')) ||
          (('\u07eb' <= yyC) && (yyC <= '\u07f3')) ||
          (('\u0901' <= yyC) && (yyC <= '\u0903')) ||
          ('\u093c' == yyC) ||
          (('\u093e' <= yyC) && (yyC <= '\u094d')) ||
          (('\u0951' <= yyC) && (yyC <= '\u0954')) ||
          (('\u0962' <= yyC) && (yyC <= '\u0963')) ||
          (('\u0966' <= yyC) && (yyC <= '\u096f')) ||
          (('\u0981' <= yyC) && (yyC <= '\u0983')) ||
          ('\u09bc' == yyC) ||
          (('\u09be' <= yyC) && (yyC <= '\u09c4')) ||
          (('\u09c7' <= yyC) && (yyC <= '\u09c8')) ||
          (('\u09cb' <= yyC) && (yyC <= '\u09cd')) ||
          ('\u09d7' == yyC) ||
          (('\u09e2' <= yyC) && (yyC <= '\u09e3')) ||
          (('\u09e6' <= yyC) && (yyC <= '\u09ef')) ||
          (('\u0a01' <= yyC) && (yyC <= '\u0a03')) ||
          ('\u0a3c' == yyC) ||
          (('\u0a3e' <= yyC) && (yyC <= '\u0a42')) ||
          (('\u0a47' <= yyC) && (yyC <= '\u0a48')) ||
          (('\u0a4b' <= yyC) && (yyC <= '\u0a4d')) ||
          (('\u0a66' <= yyC) && (yyC <= '\u0a71')) ||
          (('\u0a81' <= yyC) && (yyC <= '\u0a83')) ||
          ('\u0abc' == yyC) ||
          (('\u0abe' <= yyC) && (yyC <= '\u0ac5')) ||
          (('\u0ac7' <= yyC) && (yyC <= '\u0ac9')) ||
          (('\u0acb' <= yyC) && (yyC <= '\u0acd')) ||
          (('\u0ae2' <= yyC) && (yyC <= '\u0ae3')) ||
          (('\u0ae6' <= yyC) && (yyC <= '\u0aef')) ||
          (('\u0b01' <= yyC) && (yyC <= '\u0b03')) ||
          ('\u0b3c' == yyC) ||
          (('\u0b3e' <= yyC) && (yyC <= '\u0b43')) ||
          (('\u0b47' <= yyC) && (yyC <= '\u0b48')) ||
          (('\u0b4b' <= yyC) && (yyC <= '\u0b4d')) ||
          (('\u0b56' <= yyC) && (yyC <= '\u0b57')) ||
          (('\u0b66' <= yyC) && (yyC <= '\u0b6f')) ||
          ('\u0b82' == yyC) ||
          (('\u0bbe' <= yyC) && (yyC <= '\u0bc2')) ||
          (('\u0bc6' <= yyC) && (yyC <= '\u0bc8')) ||
          (('\u0bca' <= yyC) && (yyC <= '\u0bcd')) ||
          ('\u0bd7' == yyC) ||
          (('\u0be6' <= yyC) && (yyC <= '\u0bef')) ||
          (('\u0c01' <= yyC) && (yyC <= '\u0c03')) ||
          (('\u0c3e' <= yyC) && (yyC <= '\u0c44')) ||
          (('\u0c46' <= yyC) && (yyC <= '\u0c48')) ||
          (('\u0c4a' <= yyC) && (yyC <= '\u0c4d')) ||
          (('\u0c55' <= yyC) && (yyC <= '\u0c56')) ||
          (('\u0c66' <= yyC) && (yyC <= '\u0c6f')) ||
          (('\u0c82' <= yyC) && (yyC <= '\u0c83')) ||
          ('\u0cbc' == yyC) ||
          (('\u0cbe' <= yyC) && (yyC <= '\u0cc4')) ||
          (('\u0cc6' <= yyC) && (yyC <= '\u0cc8')) ||
          (('\u0cca' <= yyC) && (yyC <= '\u0ccd')) ||
          (('\u0cd5' <= yyC) && (yyC <= '\u0cd6')) ||
          (('\u0ce2' <= yyC) && (yyC <= '\u0ce3')) ||
          (('\u0ce6' <= yyC) && (yyC <= '\u0cef')) ||
          (('\u0d02' <= yyC) && (yyC <= '\u0d03')) ||
          (('\u0d3e' <= yyC) && (yyC <= '\u0d43')) ||
          (('\u0d46' <= yyC) && (yyC <= '\u0d48')) ||
          (('\u0d4a' <= yyC) && (yyC <= '\u0d4d')) ||
          ('\u0d57' == yyC) ||
          (('\u0d66' <= yyC) && (yyC <= '\u0d6f')) ||
          (('\u0d82' <= yyC) && (yyC <= '\u0d83')) ||
          ('\u0dca' == yyC) ||
          (('\u0dcf' <= yyC) && (yyC <= '\u0dd4')) ||
          ('\u0dd6' == yyC) ||
          (('\u0dd8' <= yyC) && (yyC <= '\u0ddf')) ||
          (('\u0df2' <= yyC) && (yyC <= '\u0df3')) ||
          ('\u0e31' == yyC) ||
          (('\u0e34' <= yyC) && (yyC <= '\u0e3a')) ||
          (('\u0e47' <= yyC) && (yyC <= '\u0e4e')) ||
          (('\u0e50' <= yyC) && (yyC <= '\u0e59')) ||
          ('\u0eb1' == yyC) ||
          (('\u0eb4' <= yyC) && (yyC <= '\u0eb9')) ||
          (('\u0ebb' <= yyC) && (yyC <= '\u0ebc')) ||
          (('\u0ec8' <= yyC) && (yyC <= '\u0ecd')) ||
          (('\u0ed0' <= yyC) && (yyC <= '\u0ed9')) ||
          (('\u0f18' <= yyC) && (yyC <= '\u0f19')) ||
          (('\u0f20' <= yyC) && (yyC <= '\u0f29')) ||
          ('\u0f35' == yyC) ||
          ('\u0f37' == yyC) ||
          ('\u0f39' == yyC) ||
          (('\u0f3e' <= yyC) && (yyC <= '\u0f3f')) ||
          (('\u0f71' <= yyC) && (yyC <= '\u0f84')) ||
          (('\u0f86' <= yyC) && (yyC <= '\u0f87')) ||
          (('\u0f90' <= yyC) && (yyC <= '\u0f97')) ||
          (('\u0f99' <= yyC) && (yyC <= '\u0fbc')) ||
          ('\u0fc6' == yyC) ||
          (('\u102c' <= yyC) && (yyC <= '\u1032')) ||
          (('\u1036' <= yyC) && (yyC <= '\u1039')) ||
          (('\u1040' <= yyC) && (yyC <= '\u1049')) ||
          (('\u1056' <= yyC) && (yyC <= '\u1059')) ||
          ('\u135f' == yyC) ||
          (('\u1712' <= yyC) && (yyC <= '\u1714')) ||
          (('\u1732' <= yyC) && (yyC <= '\u1734')) ||
          (('\u1752' <= yyC) && (yyC <= '\u1753')) ||
          (('\u1772' <= yyC) && (yyC <= '\u1773')) ||
          (('\u17b4' <= yyC) && (yyC <= '\u17d3')) ||
          ('\u17dd' == yyC) ||
          (('\u17e0' <= yyC) && (yyC <= '\u17e9')) ||
          (('\u180b' <= yyC) && (yyC <= '\u180d')) ||
          (('\u1810' <= yyC) && (yyC <= '\u1819')) ||
          ('\u18a9' == yyC) ||
          (('\u1920' <= yyC) && (yyC <= '\u192b')) ||
          (('\u1930' <= yyC) && (yyC <= '\u193b')) ||
          (('\u1946' <= yyC) && (yyC <= '\u194f')) ||
          (('\u19b0' <= yyC) && (yyC <= '\u19c0')) ||
          (('\u19c8' <= yyC) && (yyC <= '\u19c9')) ||
          (('\u19d0' <= yyC) && (yyC <= '\u19d9')) ||
          (('\u1a17' <= yyC) && (yyC <= '\u1a1b')) ||
          (('\u1b00' <= yyC) && (yyC <= '\u1b04')) ||
          (('\u1b34' <= yyC) && (yyC <= '\u1b44')) ||
          (('\u1b50' <= yyC) && (yyC <= '\u1b59')) ||
          (('\u1b6b' <= yyC) && (yyC <= '\u1b73')) ||
          (('\u1dc0' <= yyC) && (yyC <= '\u1dca')) ||
          (('\u1dfe' <= yyC) && (yyC <= '\u1dff')) ||
          (('\u200b' <= yyC) && (yyC <= '\u200f')) ||
          (('\u202a' <= yyC) && (yyC <= '\u202e')) ||
          (('\u203f' <= yyC) && (yyC <= '\u2040')) ||
          ('\u2054' == yyC) ||
          (('\u2060' <= yyC) && (yyC <= '\u2063')) ||
          (('\u206a' <= yyC) && (yyC <= '\u206f')) ||
          (('\u20d0' <= yyC) && (yyC <= '\u20dc')) ||
          ('\u20e1' == yyC) ||
          (('\u20e5' <= yyC) && (yyC <= '\u20ef')) ||
          (('\u302a' <= yyC) && (yyC <= '\u302f')) ||
          (('\u3099' <= yyC) && (yyC <= '\u309a')) ||
          ('\ua802' == yyC) ||
          ('\ua806' == yyC) ||
          ('\ua80b' == yyC) ||
          (('\ua823' <= yyC) && (yyC <= '\ua827')) ||
          ('\ufb1e' == yyC) ||
          (('\ufe00' <= yyC) && (yyC <= '\ufe0f')) ||
          (('\ufe20' <= yyC) && (yyC <= '\ufe23')) ||
          (('\ufe33' <= yyC) && (yyC <= '\ufe34')) ||
          (('\ufe4d' <= yyC) && (yyC <= '\ufe4f')) ||
          ('\ufeff' == yyC) ||
          (('\uff10' <= yyC) && (yyC <= '\uff19')) ||
          ('\uff3f' == yyC) ||
          (('\ufff9' <= yyC) && (yyC <= '\ufffb'))) {

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '\udca0':
            case '\udca1':
            case '\udca2':
            case '\udca3':
            case '\udca4':
            case '\udca5':
            case '\udca6':
            case '\udca7':
            case '\udca8':
            case '\udca9':
              {
                yyValue = difference(yyStart, yyIndex);

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '\ude01':
            case '\ude02':
            case '\ude03':
            case '\ude05':
            case '\ude06':
            case '\ude0c':
            case '\ude0d':
            case '\ude0e':
            case '\ude0f':
            case '\ude38':
            case '\ude39':
            case '\ude3a':
            case '\ude3f':
              {
                yyValue = difference(yyStart, yyIndex);

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '\ud834':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udd65' <= yyC) && (yyC <= '\udd69')) ||
                (('\udd6d' <= yyC) && (yyC <= '\udd82')) ||
                (('\udd85' <= yyC) && (yyC <= '\udd8b')) ||
                (('\uddaa' <= yyC) && (yyC <= '\uddad')) ||
                (('\ude42' <= yyC) && (yyC <= '\ude44'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udfce' <= yyC) && (yyC <= '\udfff')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\udb40':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc01' == yyC) ||
                (('\udc20' <= yyC) && (yyC <= '\udc7f')) ||
                (('\udd00' <= yyC) && (yyC <= '\uddef'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("idrest expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.IdText.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdText(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      if (FortressUtil.validId(a1)) {

        yyValue = a1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("id text expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.Id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pId(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fId) yyColumn.chunk26.fId = pId$1(yyStart);
    return yyColumn.chunk26.fId;
  }

  /** Actually parse Identifier.Id. */
  private Result pId$1(final int yyStart) throws IOException {
    Result     yyResult;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = new Id(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.BindId.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBindId(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fBindId) 
      yyColumn.chunk26.fBindId = pBindId$1(yyStart);
    return yyColumn.chunk26.fBindId;
  }

  /** Actually parse Identifier.BindId. */
  private Result pBindId$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;
      String a1 = "_";

      yyValue = new Id(createSpan(yyStart,yyCount), a1);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("bind id expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.BindIdList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBindIdList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Id>   yyRepValue1;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pBindId(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Id v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Id>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Id> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.BindIdOrBindIdTuple.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBindIdOrBindIdTuple(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fBindIdOrBindIdTuple) 
      yyColumn.chunk26.fBindIdOrBindIdTuple = pBindIdOrBindIdTuple$1(yyStart);
    return yyColumn.chunk26.fBindIdOrBindIdTuple;
  }

  /** Actually parse Identifier.BindIdOrBindIdTuple. */
  private Result pBindIdOrBindIdTuple$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBindId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcomma(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pBindIdList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Id> a2s = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyValue = FortressUtil.mkList(a1, a2s);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.SimpleName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleName(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fSimpleName) 
      yyColumn.chunk26.fSimpleName = pSimpleName$1(yyStart);
    return yyColumn.chunk26.fSimpleName;
  }

  /** Actually parse Identifier.SimpleName. */
  private Result pSimpleName$1(final int yyStart) throws IOException {
    Result     yyResult;
    SimpleName yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pOp(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pEncloserPair(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.APIName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAPIName(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk26) yyColumn.chunk26 = new Chunk26();
    if (null == yyColumn.chunk26.fAPIName) 
      yyColumn.chunk26.fAPIName = pAPIName$1(yyStart);
    return yyColumn.chunk26.fAPIName;
  }

  /** Actually parse Identifier.APIName. */
  private Result pAPIName$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    APIName    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyPredResult = pw(yyChoice1);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyPredResult = pellipses(yyPredResult.index);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyValue = NodeFactory.makeAPIName(createSpan(yyStart,yyCount), a1);

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }
      }

      // Nested alternative 2.

      yyResult = p$$Shared60(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Id> a2s = yyResult.semanticValue();

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyPredResult = pw(yyChoice2);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyPredResult = pellipses(yyPredResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyValue = NodeFactory.makeAPIName(createSpan(yyStart,yyCount),
            IterUtil.compose(a1, a2s.list()));

            return new SemanticValue(yyValue, yyChoice2, yyError);
          }
        }

        // Nested alternative 2.

        yyValue = NodeFactory.makeAPIName(createSpan(yyStart,yyCount),
        IterUtil.compose(a1, a2s.list()));

        return new SemanticValue(yyValue, yyChoice2, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.$$Shared60.
   * This nonterminal represents the duplicate productions 
   * com.sun.fortress.parser.Fortress.APIName$$Star1 
   * and com.sun.fortress.parser.Fortress.QualifiedName$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared60(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk27) yyColumn.chunk27 = new Chunk27();
    if (null == yyColumn.chunk27.f$$Shared60) 
      yyColumn.chunk27.f$$Shared60 = p$$Shared60$1(yyStart);
    return yyColumn.chunk27.f$$Shared60;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.$$Shared60. */
  private Result p$$Shared60$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pdot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id v$el$1 = yyResult.semanticValue();

        yyResult = p$$Shared60(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Id> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Id>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.QualifiedName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualifiedName(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk27) yyColumn.chunk27 = new Chunk27();
    if (null == yyColumn.chunk27.fQualifiedName) 
      yyColumn.chunk27.fQualifiedName = pQualifiedName$1(yyStart);
    return yyColumn.chunk27.fQualifiedName;
  }

  /** Actually parse Identifier.QualifiedName. */
  private Result pQualifiedName$1(final int yyStart) throws IOException {
    Result          yyResult;
    Result          yyPredResult;
    QualifiedIdName yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyPredResult = pw(yyChoice1);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyPredResult = pellipses(yyPredResult.index);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyValue = NodeFactory.makeQualifiedIdName(createSpan(yyStart,yyCount), a1);

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }
      }

      // Nested alternative 2.

      yyResult = p$$Shared60(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Id> a2s = yyResult.semanticValue();

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyPredResult = pw(yyChoice2);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyPredResult = pellipses(yyPredResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyValue = NodeFactory.makeQualifiedIdName(createSpan(yyStart,yyCount),
            a1, a2s.list());

            return new SemanticValue(yyValue, yyChoice2, yyError);
          }
        }

        // Nested alternative 2.

        yyValue = NodeFactory.makeQualifiedIdName(createSpan(yyStart,yyCount),
        a1, a2s.list());

        return new SemanticValue(yyValue, yyChoice2, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.Encloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEncloser(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk27) yyColumn.chunk27 = new Chunk27();
    if (null == yyColumn.chunk27.fEncloser) 
      yyColumn.chunk27.fEncloser = pEncloser$1(yyStart);
    return yyColumn.chunk27.fEncloser;
  }

  /** Actually parse Symbol.Encloser. */
  private Result pEncloser$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pencloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpEnclosing(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.LeftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLeftEncloser(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk27) yyColumn.chunk27 = new Chunk27();
    if (null == yyColumn.chunk27.fLeftEncloser) 
      yyColumn.chunk27.fLeftEncloser = pLeftEncloser$1(yyStart);
    return yyColumn.chunk27.fLeftEncloser;
  }

  /** Actually parse Symbol.LeftEncloser. */
  private Result pLeftEncloser$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pleftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpEnclosing(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.RightEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRightEncloser(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk27) yyColumn.chunk27 = new Chunk27();
    if (null == yyColumn.chunk27.fRightEncloser) 
      yyColumn.chunk27.fRightEncloser = pRightEncloser$1(yyStart);
    return yyColumn.chunk27.fRightEncloser;
  }

  /** Actually parse Symbol.RightEncloser. */
  private Result pRightEncloser$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = prightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpEnclosing(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.ExponentOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponentOp(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk27) yyColumn.chunk27 = new Chunk27();
    if (null == yyColumn.chunk27.fExponentOp) 
      yyColumn.chunk27.fExponentOp = pExponentOp$1(yyStart);
    return yyColumn.chunk27.fExponentOp;
  }

  /** Actually parse Symbol.ExponentOp. */
  private Result pExponentOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexponentOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpPostfix(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.EncloserPair.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEncloserPair(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk27) yyColumn.chunk27 = new Chunk27();
    if (null == yyColumn.chunk27.fEncloserPair) 
      yyColumn.chunk27.fEncloserPair = pEncloserPair$1(yyStart);
    return yyColumn.chunk27.fEncloserPair;
  }

  /** Actually parse Symbol.EncloserPair. */
  private Result pEncloserPair$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Enclosing  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEncloserPair$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pDOT(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }
      }

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pEncloserPair$$Choice2(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          if (PrecedenceMap.ONLY.matchedBrackets(a1.getText(), a2.getText()))
          yyValue = new Enclosing(createSpan(yyStart,yyCount), a1, a2);
          else
          yyValue = error(a2, "Mismatched Enclosers.");

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.EncloserPair$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEncloserPair$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.EncloserPair$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEncloserPair$$Choice2(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.bar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol$bar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyPredIndex;
    Result     yyPredResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyPredIndex = yyStart + 1;

      yyPredResult = pwr(yyPredIndex);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyPredResult = pNoNewlineExpr$GeneratorClauseList(yyPredResult.index);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyPredResult = pclosingComprehension(yyPredResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyC = character(yyStart);
            if ('|' == yyC) {
              yyIndex = yyStart + 1;

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("bar expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closingComprehension.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosingComprehension(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '}':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case '|':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('>' == yyC) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }
    }

    // Alternative 2.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pArrayComprehensionClause(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (']' == yyC) {
        yyIndex = yyResult.index + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("\"]\" expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("closing comprehension expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.sd.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psd(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyC = character(yyOption1);
    if (-1 != yyC) {
      yyIndex = yyOption1 + 1;

      switch (yyC) {
      case '*':
      case '.':
        {
          yyOption1  = yyIndex;
        }

      default:
        /* No match. */
      }
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyOption1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.bars.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbars(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk27) yyColumn.chunk27 = new Chunk27();
    if (null == yyColumn.chunk27.fbars) 
      yyColumn.chunk27.fbars = pbars$1(yyStart);
    return yyColumn.chunk27.fbars;
  }

  /** Actually parse Symbol.bars. */
  private Result pbars$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pbars$$Star1(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bars expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.bars$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbars$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk27) yyColumn.chunk27 = new Chunk27();
    if (null == yyColumn.chunk27.fbars$$Star1) 
      yyColumn.chunk27.fbars$$Star1 = pbars$$Star1$1(yyStart);
    return yyColumn.chunk27.fbars$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.bars$$Star1. */
  private Result pbars$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psd(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('|' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pbars$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\"|\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.slashes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pslashes(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk27) yyColumn.chunk27 = new Chunk27();
    if (null == yyColumn.chunk27.fslashes) 
      yyColumn.chunk27.fslashes = pslashes$1(yyStart);
    return yyColumn.chunk27.fslashes;
  }

  /** Actually parse Symbol.slashes. */
  private Result pslashes$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '/':
        {
          yyResult = pslashes$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      case '\\':
        {
          yyResult = pslashes$$Star2(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("slashes expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.slashes$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pslashes$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk28) yyColumn.chunk28 = new Chunk28();
    if (null == yyColumn.chunk28.fslashes$$Star1) 
      yyColumn.chunk28.fslashes$$Star1 = pslashes$$Star1$1(yyStart);
    return yyColumn.chunk28.fslashes$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.slashes$$Star1. */
  private Result pslashes$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psd(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('/' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pslashes$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\"/\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.slashes$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pslashes$$Star2(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk28) yyColumn.chunk28 = new Chunk28();
    if (null == yyColumn.chunk28.fslashes$$Star2) 
      yyColumn.chunk28.fslashes$$Star2 = pslashes$$Star2$1(yyStart);
    return yyColumn.chunk28.fslashes$$Star2;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.slashes$$Star2. */
  private Result pslashes$$Star2$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psd(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('\\' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pslashes$$Star2(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\"\\\\\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.lesses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plesses(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        yyResult = psd(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if ('<' == yyC) {
            yyIndex = yyResult.index + 1;

            yyRepetition1 = yyIndex;
            continue;
          } else {
            yyError = yyError.select("\"<\" expected", yyBase);
          }
        }
        break;
      }

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("lesses expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.greaters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgreaters(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk28) yyColumn.chunk28 = new Chunk28();
    if (null == yyColumn.chunk28.fgreaters) 
      yyColumn.chunk28.fgreaters = pgreaters$1(yyStart);
    return yyColumn.chunk28.fgreaters;
  }

  /** Actually parse Symbol.greaters. */
  private Result pgreaters$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pgreaters$$Star1(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("greaters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.greaters$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgreaters$$Star1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk28) yyColumn.chunk28 = new Chunk28();
    if (null == yyColumn.chunk28.fgreaters$$Star1) 
      yyColumn.chunk28.fgreaters$$Star1 = pgreaters$$Star1$1(yyStart);
    return yyColumn.chunk28.fgreaters$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.greaters$$Star1. */
  private Result pgreaters$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psd(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('>' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pgreaters$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\">\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.encloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pencloser(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk28) yyColumn.chunk28 = new Chunk28();
    if (null == yyColumn.chunk28.fencloser) 
      yyColumn.chunk28.fencloser = pencloser$1(yyStart);
    return yyColumn.chunk28.fencloser;
  }

  /** Actually parse Symbol.encloser. */
  private Result pencloser$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pSymbol$bar(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pbars(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyPredMatched = false;

        yyPredResult = pencloser$$Choice1(yyResult.index);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("encloser expected", yyStart);
        }
      }
    } else {
      yyError = yyError.select("encloser expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.encloser$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pencloser$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
      case '.':
      case '/':
      case '>':
      case '\\':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '-':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('>' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("encloser expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.leftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pleftEncloser(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk28) yyColumn.chunk28 = new Chunk28();
    if (null == yyColumn.chunk28.fleftEncloser) 
      yyColumn.chunk28.fleftEncloser = pleftEncloser$1(yyStart);
    return yyColumn.chunk28.fleftEncloser;
  }

  /** Actually parse Symbol.leftEncloser. */
  private Result pleftEncloser$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pleftEncloserMulti(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (PrecedenceMap.ONLY.isLeft(yyValue)) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (c != '|' && PrecedenceMap.ONLY.isLeft(""+c)) {

        yyValue = ""+c;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("left encloser expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.leftEncloserMulti.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pleftEncloserMulti(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '(':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyRepetition1 = yyChoice1;
          yyRepeated1   = false;
          while (true) {

            yyBase = yyRepetition1;
            yyC    = character(yyBase);
            if ('/' == yyC) {
              yyIndex = yyRepetition1 + 1;

              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            } else {
              yyError = yyError.select("\"/\" expected", yyBase);
            }
            break;
          }

          if (yyRepeated1) {

            yyValue = difference(yyStart, yyRepetition1);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          }

          // Nested alternative 2.

          yyRepetition1 = yyChoice1;
          yyRepeated1   = false;
          while (true) {

            yyBase = yyRepetition1;
            yyC    = character(yyBase);
            if ('\\' == yyC) {
              yyIndex = yyRepetition1 + 1;

              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            } else {
              yyError = yyError.select("\"\\\\\" expected", yyBase);
            }
            break;
          }

          if (yyRepeated1) {

            yyValue = difference(yyStart, yyRepetition1);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          }
        }
        break;

      case '[':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('/' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('\\' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('/' == yyC) {

                      final int yyChoice2 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice2);
                      if (-1 != yyC) {
                        yyIndex = yyChoice2 + 1;
                        if ('\\' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('/' == yyC) {

                              yyValue = "[/\\/\\/";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }

                      // Nested alternative 2.

                      yyValue = "[/\\/";

                      return new SemanticValue(yyValue, yyChoice2, yyError);
                    }
                  }
                }
              }
            }
          }

          // Nested alternative 2.

          yyResult = psd(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pslashes(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = difference(yyStart, yyResult.index);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      case '{':
        {
          yyResult = psd(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pslashes(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = difference(yyStart, yyResult.index);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyResult = plesses(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psd(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pslashes(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pbars(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = pbars(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psd(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pslashes(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '{':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('*' == yyC) {

              yyValue = "{*";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '[':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('*' == yyC) {

              yyValue = "[*";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '(':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '(':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('>' == yyC) {

                    yyValue = "((>";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case '<':
              {
                yyValue = "(<";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("left encloser multi expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.rightEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightEncloser(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk28) yyColumn.chunk28 = new Chunk28();
    if (null == yyColumn.chunk28.frightEncloser) 
      yyColumn.chunk28.frightEncloser = prightEncloser$1(yyStart);
    return yyColumn.chunk28.frightEncloser;
  }

  /** Actually parse Symbol.rightEncloser. */
  private Result prightEncloser$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = prightEncloserMulti(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (PrecedenceMap.ONLY.isRight(yyValue)) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (c != '|' && PrecedenceMap.ONLY.isRight(""+c)) {

        yyValue = ""+c;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("right encloser expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.rightEncloserMulti.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightEncloserMulti(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk28) yyColumn.chunk28 = new Chunk28();
    if (null == yyColumn.chunk28.frightEncloserMulti) 
      yyColumn.chunk28.frightEncloserMulti = prightEncloserMulti$1(yyStart);
    return yyColumn.chunk28.frightEncloserMulti;
  }

  /** Actually parse Symbol.rightEncloserMulti. */
  private Result prightEncloserMulti$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = prightEncloserMulti$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (')' == yyC) {
        yyIndex = yyResult.index + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("\")\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = prightEncloserMulti$$Plus2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (')' == yyC) {
        yyIndex = yyResult.index + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("\")\" expected", yyBase);
      }
    }

    // Alternative 3.

    yyResult = pslashes(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psd(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pgreaters(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pbars(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case ']':
          case '}':
            {
              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }

          default:
            /* No match. */
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pbars(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psd(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pgreaters(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case ']':
              {
                yyValue = "*]";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '}':
              {
                yyValue = "*}";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case ']':
        {
          yyValue = "]";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = "}";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '>':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (')' == yyC) {

              yyValue = ">)";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '<':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (')' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if (')' == yyC) {

                  yyValue = "<))";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case '/':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\\' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('/' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;

                    switch (yyC) {
                    case '\\':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('/' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if (']' == yyC) {

                                yyValue = "/\\/\\/]";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }
                            }
                          }
                        }
                      }
                      break;

                    case ']':
                      {
                        yyValue = "/\\/]";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }

                    default:
                      /* No match. */
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("right encloser multi expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.rightEncloserMulti$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightEncloserMulti$$Plus1(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk28) yyColumn.chunk28 = new Chunk28();
    if (null == yyColumn.chunk28.frightEncloserMulti$$Plus1) 
      yyColumn.chunk28.frightEncloserMulti$$Plus1 = prightEncloserMulti$$Plus1$1(yyStart);
    return yyColumn.chunk28.frightEncloserMulti$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.rightEncloserMulti$$Plus1. */
  private Result prightEncloserMulti$$Plus1$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('/' == yyC) {

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyResult = prightEncloserMulti$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("right encloser multi expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.rightEncloserMulti$$Plus2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightEncloserMulti$$Plus2(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk28) yyColumn.chunk28 = new Chunk28();
    if (null == yyColumn.chunk28.frightEncloserMulti$$Plus2) 
      yyColumn.chunk28.frightEncloserMulti$$Plus2 = prightEncloserMulti$$Plus2$1(yyStart);
    return yyColumn.chunk28.frightEncloserMulti$$Plus2;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.rightEncloserMulti$$Plus2. */
  private Result prightEncloserMulti$$Plus2$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('\\' == yyC) {

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyResult = prightEncloserMulti$$Plus2(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("right encloser multi expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.exponentOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexponentOp(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('^' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('T' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "^T";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('^' == yyC) {
      yyIndex = yyStart + 1;
      String a1 = "^";

      yyResult = pop(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = a1+a2;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("exponent op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.OpName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOpName(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk29) yyColumn.chunk29 = new Chunk29();
    if (null == yyColumn.chunk29.fOpName) 
      yyColumn.chunk29.fOpName = pOpName$1(yyStart);
    return yyColumn.chunk29.fOpName;
  }

  /** Actually parse Symbol.OpName. */
  private Result pOpName$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String opn = yyResult.semanticValue();

      if (FortressUtil.validOp(opn)) {

        yyValue = opn;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("op name expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.Op.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOp(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk29) yyColumn.chunk29 = new Chunk29();
    if (null == yyColumn.chunk29.fOp) yyColumn.chunk29.fOp = pOp$1(yyStart);
    return yyColumn.chunk29.fOp;
  }

  /** Actually parse Symbol.Op. */
  private Result pOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOpUnknown(createSpan(yyStart, yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal com.sun.fortress.parser.Fortress.Op$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOp$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcondOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyPredMatched = false;

      yyPredResult = pequalsOp(yyResult.index);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("op expected", yyStart);
      }
    }

    // Alternative 3.

    yyResult = pcompOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.compOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcompOp(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk29) yyColumn.chunk29 = new Chunk29();
    if (null == yyColumn.chunk29.fcompOp) 
      yyColumn.chunk29.fcompOp = pcompOp$1(yyStart);
    return yyColumn.chunk29.fcompOp;
  }

  /** Actually parse Symbol.compOp. */
  private Result pcompOp$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '=':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '=':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('=' == yyC) {

                    yyValue = "===";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case '/':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('=' == yyC) {

                    yyValue = "=/=";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case '<':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = "<=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '>':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = ">=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("comp op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.condOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcondOp(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;
      String a1 = ":";

      yyResult = pop(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyResult = pSymbol$colon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a3 = yyResult.semanticValue();

          yyValue = a1+a2+a3;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pSymbol$colon(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = a1+a2;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("cond op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.multiOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmultiOp(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk29) yyColumn.chunk29 = new Chunk29();
    if (null == yyColumn.chunk29.fmultiOp) 
      yyColumn.chunk29.fmultiOp = pmultiOp$1(yyStart);
    return yyColumn.chunk29.fmultiOp;
  }

  /** Actually parse Symbol.multiOp. */
  private Result pmultiOp$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('-' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('>' == yyC) {
            yyIndex = yyIndex + 1;
            yyValue = "-/->";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('/' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('-' == yyC) {
            yyIndex = yyIndex + 1;
            yyValue = "<-/-";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "-->";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "==>";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 5.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = ">>>";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 6.

    yyResult = pmapstoOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('<' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('<' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "<<<";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 8.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "<->";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 9.

    yyResult = pleftarrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "<=>";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 11.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "->";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 12.

    yyResult = pdoublerightarrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 13.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = ">>";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 14.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('<' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "<<";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 15.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "**";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 16.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('!' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "!!";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 17.

    yyPredMatched = false;

    yyPredResult = prightEncloserMulti(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      final int yyChoice1 = yyStart;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if ('/' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyC = character(yyIndex);
        if ('/' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('/' == yyC) {
            yyIndex = yyIndex + 1;
            yyValue = "///";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('/' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyC = character(yyIndex);
        if ('/' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "//";

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"//\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"//\" expected", yyBase);
      }
    } else {
      yyError = yyError.select("multi op expected", yyStart);
    }

    // Done.
    yyError = yyError.select("multi op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.singleOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psingleOp(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk29) yyColumn.chunk29 = new Chunk29();
    if (null == yyColumn.chunk29.fsingleOp) 
      yyColumn.chunk29.fsingleOp = psingleOp$1(yyStart);
    return yyColumn.chunk29.fsingleOp;
  }

  /** Actually parse Symbol.singleOp. */
  private Result psingleOp$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = psingleOp$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char a1 = (char)yyC;

        if (PrecedenceMap.ONLY.isOperator("" + a1)) {

          yyValue = "" + a1;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    } else {
      yyError = yyError.select("single op expected", yyStart);
    }

    // Done.
    yyError = yyError.select("single op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.singleOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psingleOp$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pencloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pleftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = prightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pmultiOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pcompOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("single op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.op.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pop(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk29) yyColumn.chunk29 = new Chunk29();
    if (null == yyColumn.chunk29.fop) yyColumn.chunk29.fop = pop$1(yyStart);
    return yyColumn.chunk29.fop;
  }

  /** Actually parse Symbol.op. */
  private Result pop$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOpName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pmultiOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.CompoundOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCompoundOp(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pequalsOp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = NodeFactory.makeOpInfix(createSpan(yyStart, yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.doublerightarrow.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdoublerightarrow(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "=>";

        yyPredResult = pw(yyIndex);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyPredResult = pBlockElems(yyPredResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyPredResult = pw(yyPredResult.index);
            yyError      = yyPredResult.select(yyError);
            if (yyPredResult.hasValue()) {

              yyPredResult = pmatch(yyPredResult.index);
              yyError      = yyPredResult.select(yyError);
              if (yyPredResult.hasValue()) {

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("doublerightarrow expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.leftarrow.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pleftarrow(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk29) yyColumn.chunk29 = new Chunk29();
    if (null == yyColumn.chunk29.fleftarrow) 
      yyColumn.chunk29.fleftarrow = pleftarrow$1(yyStart);
    return yyColumn.chunk29.fleftarrow;
  }

  /** Actually parse Symbol.leftarrow. */
  private Result pleftarrow$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = "<-";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("leftarrow expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.caret.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcaret(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk29) yyColumn.chunk29 = new Chunk29();
    if (null == yyColumn.chunk29.fcaret) 
      yyColumn.chunk29.fcaret = pcaret$1(yyStart);
    return yyColumn.chunk29.fcaret;
  }

  /** Actually parse Symbol.caret. */
  private Result pcaret$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('^' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = "^";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("caret expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.colonequals.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcolonequals(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk29) yyColumn.chunk29 = new Chunk29();
    if (null == yyColumn.chunk29.fcolonequals) 
      yyColumn.chunk29.fcolonequals = pcolonequals$1(yyStart);
    return yyColumn.chunk29.fcolonequals;
  }

  /** Actually parse Symbol.colonequals. */
  private Result pcolonequals$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = ":=";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("colonequals expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.equals.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pequals(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk29) yyColumn.chunk29 = new Chunk29();
    if (null == yyColumn.chunk29.fequals) 
      yyColumn.chunk29.fequals = pequals$1(yyStart);
    return yyColumn.chunk29.fequals;
  }

  /** Actually parse Symbol.equals. */
  private Result pequals$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "=";

      yyPredMatched = false;

      yyPredResult = pop(yyIndex);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("equals expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("equals expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.equalsOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pequalsOp(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk30) yyColumn.chunk30 = new Chunk30();
    if (null == yyColumn.chunk30.fequalsOp) 
      yyColumn.chunk30.fequalsOp = pequalsOp$1(yyStart);
    return yyColumn.chunk30.fequalsOp;
  }

  /** Actually parse Symbol.equalsOp. */
  private Result pequalsOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("=")) {
      yyValue = "=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("equals op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.semicolon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psemicolon(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk30) yyColumn.chunk30 = new Chunk30();
    if (null == yyColumn.chunk30.fsemicolon) 
      yyColumn.chunk30.fsemicolon = psemicolon$1(yyStart);
    return yyColumn.chunk30.fsemicolon;
  }

  /** Actually parse Symbol.semicolon. */
  private Result psemicolon$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (';' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = ";";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("semicolon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.one.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pone(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk30) yyColumn.chunk30 = new Chunk30();
    if (null == yyColumn.chunk30.fone) 
      yyColumn.chunk30.fone = pone$1(yyStart);
    return yyColumn.chunk30.fone;
  }

  /** Actually parse Symbol.one. */
  private Result pone$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('1' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("one expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.colon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol$colon(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk30) yyColumn.chunk30 = new Chunk30();
    if (null == yyColumn.chunk30.fSymbol$colon) 
      yyColumn.chunk30.fSymbol$colon = pSymbol$colon$1(yyStart);
    return yyColumn.chunk30.fSymbol$colon;
  }

  /** Actually parse Symbol.colon. */
  private Result pSymbol$colon$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = ":";

      yyPredMatched = false;

      yyPredResult = pop(yyIndex);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("colon expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("colon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closecurly.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosecurly(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk30) yyColumn.chunk30 = new Chunk30();
    if (null == yyColumn.chunk30.fclosecurly) 
      yyColumn.chunk30.fclosecurly = pclosecurly$1(yyStart);
    return yyColumn.chunk30.fclosecurly;
  }

  /** Actually parse Symbol.closecurly. */
  private Result pclosecurly$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('}' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = "}";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closecurly expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.opencurly.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popencurly(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk30) yyColumn.chunk30 = new Chunk30();
    if (null == yyColumn.chunk30.fopencurly) 
      yyColumn.chunk30.fopencurly = popencurly$1(yyStart);
    return yyColumn.chunk30.fopencurly;
  }

  /** Actually parse Symbol.opencurly. */
  private Result popencurly$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pleftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("{")) {
      yyValue = "{";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("opencurly expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closesquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosesquare(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk30) yyColumn.chunk30 = new Chunk30();
    if (null == yyColumn.chunk30.fclosesquare) 
      yyColumn.chunk30.fclosesquare = pclosesquare$1(yyStart);
    return yyColumn.chunk30.fclosesquare;
  }

  /** Actually parse Symbol.closesquare. */
  private Result pclosesquare$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (']' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = "]";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closesquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.opensquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popensquare(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk30) yyColumn.chunk30 = new Chunk30();
    if (null == yyColumn.chunk30.fopensquare) 
      yyColumn.chunk30.fopensquare = popensquare$1(yyStart);
    return yyColumn.chunk30.fopensquare;
  }

  /** Actually parse Symbol.opensquare. */
  private Result popensquare$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pleftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("[")) {
      yyValue = "[";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("opensquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.ellipses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pellipses(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk30) yyColumn.chunk30 = new Chunk30();
    if (null == yyColumn.chunk30.fellipses) 
      yyColumn.chunk30.fellipses = pellipses$1(yyStart);
    return yyColumn.chunk30.fellipses;
  }

  /** Actually parse Symbol.ellipses. */
  private Result pellipses$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('.' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('.' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = "...";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("ellipses expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.lessthanequal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plessthanequal(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("<=")) {
      yyValue = "<=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("LE")) {
      yyValue = "LE";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("lessthanequal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.lessthan.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plessthan(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("<")) {
      yyValue = "<";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("LT")) {
      yyValue = "LT";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("lessthan expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.greaterthanequal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgreaterthanequal(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue(">=")) {
      yyValue = ">=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("GE")) {
      yyValue = "GE";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("greaterthanequal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.greaterthan.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgreaterthan(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue(">")) {
      yyValue = ">";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("GT")) {
      yyValue = "GT";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("greaterthan expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.NOT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNOT(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk30) yyColumn.chunk30 = new Chunk30();
    if (null == yyColumn.chunk30.fNOT) 
      yyColumn.chunk30.fNOT = pNOT$1(yyStart);
    return yyColumn.chunk30.fNOT;
  }

  /** Actually parse Symbol.NOT. */
  private Result pNOT$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("NOT")) {
      yyValue = "NOT";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("NOT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.OR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOR(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk31) yyColumn.chunk31 = new Chunk31();
    if (null == yyColumn.chunk31.fOR) yyColumn.chunk31.fOR = pOR$1(yyStart);
    return yyColumn.chunk31.fOR;
  }

  /** Actually parse Symbol.OR. */
  private Result pOR$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("OR")) {
      yyValue = "OR";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("OR expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.AND.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAND(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk31) yyColumn.chunk31 = new Chunk31();
    if (null == yyColumn.chunk31.fAND) 
      yyColumn.chunk31.fAND = pAND$1(yyStart);
    return yyColumn.chunk31.fAND;
  }

  /** Actually parse Symbol.AND. */
  private Result pAND$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("AND")) {
      yyValue = "AND";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("AND expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.IMPLIES.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIMPLIES(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk31) yyColumn.chunk31 = new Chunk31();
    if (null == yyColumn.chunk31.fIMPLIES) 
      yyColumn.chunk31.fIMPLIES = pIMPLIES$1(yyStart);
    return yyColumn.chunk31.fIMPLIES;
  }

  /** Actually parse Symbol.IMPLIES. */
  private Result pIMPLIES$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("->")) {
      yyValue = "->";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("IMPLIES")) {
      yyValue = "IMPLIES";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("IMPLIES expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.DOT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDOT(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk31) yyColumn.chunk31 = new Chunk31();
    if (null == yyColumn.chunk31.fDOT) 
      yyColumn.chunk31.fDOT = pDOT$1(yyStart);
    return yyColumn.chunk31.fDOT;
  }

  /** Actually parse Symbol.DOT. */
  private Result pDOT$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOpName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("DOT")) {
      yyValue = "DOT";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("DOT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.slash.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pslash(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk31) yyColumn.chunk31 = new Chunk31();
    if (null == yyColumn.chunk31.fslash) 
      yyColumn.chunk31.fslash = pslash$1(yyStart);
    return yyColumn.chunk31.fslash;
  }

  /** Actually parse Symbol.slash. */
  private Result pslash$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("/")) {
      yyValue = "/";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("slash expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.rightarrow.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightarrow(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk31) yyColumn.chunk31 = new Chunk31();
    if (null == yyColumn.chunk31.frightarrow) 
      yyColumn.chunk31.frightarrow = prightarrow$1(yyStart);
    return yyColumn.chunk31.frightarrow;
  }

  /** Actually parse Symbol.rightarrow. */
  private Result prightarrow$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = "->";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("rightarrow expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closedoublesquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosedoublesquare(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (']' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("closedoublesquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closeparen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcloseparen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (')' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closeparen expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.cross.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcross(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('B' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('Y' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("cross expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.mapsto.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmapsto(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("mapsto expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.match.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmatch(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("match expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.minus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pminus(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("-")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("minus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.opendoublesquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popendoublesquare(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('\\' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("opendoublesquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.openparen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popenparen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pleftEncloser(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if ('(' == yyC) {
        yyIndex = yyStart + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("openparen expected", yyStart);
    }

    // Done.
    yyError = yyError.select("openparen expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.plus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol$plus(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("+")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("plus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.pound.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ppound(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("#")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("pound expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.comma.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomma(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("comma expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.dot.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdot(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("dot expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.AssignOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignOp(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk31) yyColumn.chunk31 = new Chunk31();
    if (null == yyColumn.chunk31.fAssignOp) 
      yyColumn.chunk31.fAssignOp = pAssignOp$1(yyStart);
    return yyColumn.chunk31.fAssignOp;
  }

  /** Actually parse Symbol.AssignOp. */
  private Result pAssignOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    Option<Op> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcolonequals(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Option.none();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pCompoundOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyValue = Option.some(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.SUM.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSUM(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk31) yyColumn.chunk31 = new Chunk31();
    if (null == yyColumn.chunk31.fSUM) 
      yyColumn.chunk31.fSUM = pSUM$1(yyStart);
    return yyColumn.chunk31.fSUM;
  }

  /** Actually parse Symbol.SUM. */
  private Result pSUM$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('S' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('U' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('M' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = NodeFactory.makeOpBig(createSpan(yyStart,yyCount), "BIG +");

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("SUM expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.PROD.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPROD(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk31) yyColumn.chunk31 = new Chunk31();
    if (null == yyColumn.chunk31.fPROD) 
      yyColumn.chunk31.fPROD = pPROD$1(yyStart);
    return yyColumn.chunk31.fPROD;
  }

  /** Actually parse Symbol.PROD. */
  private Result pPROD$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('P' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('R' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('O' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('D' == yyC) {
            yyIndex = yyIndex + 1;

            yyValue = NodeFactory.makeOpBig(createSpan(yyStart,yyCount),
            "BIG juxtaposition");

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("PROD expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.Accumulator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAccumulator(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk31) yyColumn.chunk31 = new Chunk31();
    if (null == yyColumn.chunk31.fAccumulator) 
      yyColumn.chunk31.fAccumulator = pAccumulator$1(yyStart);
    return yyColumn.chunk31.fAccumulator;
  }

  /** Actually parse Symbol.Accumulator. */
  private Result pAccumulator$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSUM(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pPROD(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pBIG(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a1 = yyResult.semanticValue();

          yyValue = NodeFactory.makeOpBig(createSpan(yyStart,yyCount),
          "BIG " + a1.getText());

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.ArrayComprehensionClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayComprehensionClause(final int yyStart) 
    throws IOException {

    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk32) yyColumn.chunk32 = new Chunk32();
    if (null == yyColumn.chunk32.fArrayComprehensionClause) 
      yyColumn.chunk32.fArrayComprehensionClause = pArrayComprehensionClause$1(yyStart);
    return yyColumn.chunk32.fArrayComprehensionClause;
  }

  /** Actually parse Symbol.ArrayComprehensionClause. */
  private Result pArrayComprehensionClause$1(final int yyStart) 
    throws IOException {

    Result                   yyResult;
    ArrayComprehensionClause yyValue;
    ParseError               yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArrayComprehensionLeft(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      com.sun.fortress.useful.Pair<List<Expr>,Expr> a1 = yyResult.semanticValue();

      yyResult = pwr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSymbol$bar(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pwr(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pNoNewlineExpr$GeneratorClauseList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<GeneratorClause> a2 = yyResult.semanticValue();

              yyValue = new ArrayComprehensionClause(createSpan(yyStart,yyCount),
              a1.getA(), a1.getB(), a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("end of file expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Whitespace.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhitespace(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk32) yyColumn.chunk32 = new Chunk32();
    if (null == yyColumn.chunk32.fWhitespace) 
      yyColumn.chunk32.fWhitespace = pWhitespace$1(yyStart);
    return yyColumn.chunk32.fWhitespace;
  }

  /** Actually parse Spacing.Whitespace. */
  private Result pWhitespace$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing$Space(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\t' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = error(new VoidLiteralExpr(createSpan(yyStart,yyCount)),
      "Tabulation is not allowed in Fortress programs except in comments.");

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyResult = pSpacing$Newline(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("whitespace expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing$Space(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk32) yyColumn.chunk32 = new Chunk32();
    if (null == yyColumn.chunk32.fSpacing$Space) 
      yyColumn.chunk32.fSpacing$Space = pSpacing$Space$1(yyStart);
    return yyColumn.chunk32.fSpacing$Space;
  }

  /** Actually parse Spacing.Space. */
  private Result pSpacing$Space$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (' ' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = " ";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\f' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "\f";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\t' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = error(new VoidLiteralExpr(createSpan(yyStart,yyCount)),
      "Tabulation is not allowed in Fortress programs except in comments.");

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyResult = pNoNewlineComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Newline.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing$Newline(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk32) yyColumn.chunk32 = new Chunk32();
    if (null == yyColumn.chunk32.fSpacing$Newline) 
      yyColumn.chunk32.fSpacing$Newline = pSpacing$Newline$1(yyStart);
    return yyColumn.chunk32.fSpacing$Newline;
  }

  /** Actually parse Spacing.Newline. */
  private Result pSpacing$Newline$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('\n' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "\r\n";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "\r";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\n' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "\n";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyResult = pComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("newline expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Comment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComment(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk32) yyColumn.chunk32 = new Chunk32();
    if (null == yyColumn.chunk32.fComment) 
      yyColumn.chunk32.fComment = pComment$1(yyStart);
    return yyColumn.chunk32.fComment;
  }

  /** Actually parse Spacing.Comment. */
  private Result pComment$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;
        String a1 = "(*";

        yyResult = pCommentContents(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a2 = yyResult.semanticValue();

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if ('*' == yyC) {
            yyIndex = yyResult.index + 1;

            yyC = character(yyIndex);
            if (')' == yyC) {
              yyIndex = yyIndex + 1;
              String a3 = "*)";

              yyValue = a1 + a2 + a3;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"*)\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"*)\" expected", yyBase);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.CommentContents.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommentContents(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    String       yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pCommentContent(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for a1s.
      Pair<String> a1s = yyRepValue1.reverse();

      yyValue = "";
      for (Object s : a1s.list()) {
        yyValue += s;
      }

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for a1s.
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.CommentContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommentContent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if (')' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = ""+c;

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("comment content expected", yyStart);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (c != '*') {

        yyValue = ""+c;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("comment content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.NoNewlineComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineComment(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (!(yyValue.contains("\r\n") || yyValue.contains("\r")
          || yyValue.contains("\n"))) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("no newline comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.w.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pw(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pWhitespace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.wr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyResult = pWhitespace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        continue;
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.s.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ps(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pSpacing$Space(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.sr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing$sr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyResult = pSpacing$Space(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        continue;
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.nl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pnl(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pSpacing$Newline(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.br.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbr(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pSpacing$Newline(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if (';' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyResult = pw(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\";\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.RectSeparator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRectSeparator(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk32) yyColumn.chunk32 = new Chunk32();
    if (null == yyColumn.chunk32.fRectSeparator) 
      yyColumn.chunk32.fRectSeparator = pRectSeparator$1(yyStart);
    return yyColumn.chunk32.fRectSeparator;
  }

  /** Actually parse Spacing.RectSeparator. */
  private Result pRectSeparator$1(final int yyStart) throws IOException {
    Result     yyResult;
    Integer    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRectSeparator$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<String> a1s = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = a1s.size() + 1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSpacing$sr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = 1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pnl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = 2;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.Fortress.RectSeparator$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRectSeparator$$Plus1(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk32) yyColumn.chunk32 = new Chunk32();
    if (null == yyColumn.chunk32.fRectSeparator$$Plus1) 
      yyColumn.chunk32.fRectSeparator$$Plus1 = pRectSeparator$$Plus1$1(yyStart);
    return yyColumn.chunk32.fRectSeparator$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.Fortress.RectSeparator$$Plus1. */
  private Result pRectSeparator$$Plus1$1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psemicolon(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pRectSeparator$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<String> v$2 = yyResult.semanticValue();

          yyValue = new Pair<String>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = new Pair<String>(v$el$1);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.per.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pper(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk32) yyColumn.chunk32 = new Chunk32();
    if (null == yyColumn.chunk32.fper) 
      yyColumn.chunk32.fper = pper$1(yyStart);
    return yyColumn.chunk32.fper;
  }

  /** Actually parse Keyword.per. */
  private Result pper$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = "per";

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("per expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("per expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.FORALL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFORALL(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('F' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('O' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('R' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('A' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('L' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('L' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("FORALL expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("FORALL expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.absorbs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pabsorbs(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('b' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('b' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("absorbs expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("absorbs expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.also.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result palso(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("also expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("also expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.api.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result papi(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('p' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("api expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("api expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.as.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pas(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('s' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("as expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("as expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.asif.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pasif(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('s' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('f' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("asif expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("asif expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.at.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pat(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('t' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("at expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("at expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.bool.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbool(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('b' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("bool expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("bool expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.case.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcase(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("case expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("case expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.catch.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcatch(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('c' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('h' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("catch expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("catch expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.coerce.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcoerce(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("coerce expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("coerce expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.coerces.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcoerces(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("coerces expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("coerces expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.component.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomponent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('p' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('o' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('t' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("component expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("component expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.comprises.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomprises(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('p' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('s' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("comprises expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("comprises expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.default.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdefault(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('f' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('u' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('l' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('t' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("default expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("default expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.dim.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdim(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("dim expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("dim expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.do.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pKeyword$do(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("do expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("do expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.elif.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pelif(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('f' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("elif expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("elif expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.else.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pelse(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("else expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("else expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.ensures.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pensures(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("ensures expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("ensures expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.except.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexcept(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('c' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('p' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("except expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("except expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.excludes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexcludes(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('c' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('u' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('s' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("excludes expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("excludes expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.exit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("exit expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("exit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.export.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexport(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("export expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("export expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.extends.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pextends(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("extends expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("extends expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.finally.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfinally(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('l' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('l' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('y' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("finally expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("finally expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.fn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfn(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("fn expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("fn expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.for.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfor(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("for expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("for expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.forbid.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pforbid(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('b' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("forbid expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("forbid expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.if.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pif(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('f' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("if expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("if expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.import.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pimport(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('m' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("import expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("import expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.in.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pin(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("in expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("in expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.int.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pint(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("int expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("int expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.invariant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pinvariant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('v' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('a' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('t' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("invariant expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("invariant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.label.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plabel(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('l' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('b' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('l' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("label expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("label expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.most.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmost(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('m' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("most expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("most expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.nat.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pnat(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('n' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("nat expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("nat expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.object.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pobject(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('b' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('j' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("object expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("object expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.of.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pof(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('f' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("of expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("of expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.opr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popr(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('p' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("opr expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("opr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.or.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result por(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("or expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("or expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.property.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pproperty(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('p' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('t' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('y' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("property expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("property expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.provided.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pprovided(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('v' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('d' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("provided expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("provided expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.requires.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prequires(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('q' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('s' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("requires expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("requires expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.spawn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pspawn(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('p' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('w' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("spawn expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("spawn expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.syntax.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psyntax(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('x' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("syntax expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("syntax expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.then.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pthen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('n' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("then expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("then expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.throw.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pthrow(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('w' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("throw expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("throw expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.throws.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pthrows(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('w' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("throws expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("throws expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.trait.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptrait(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("trait expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("trait expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.try.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptry(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('y' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("try expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("try expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.tryatomic.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptryatomic(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('y' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('o' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('m' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('i' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('c' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("tryatomic expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("tryatomic expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptype(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("type expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.typecase.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptypecase(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("typecase expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("typecase expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.where.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwhere(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("where expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("where expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.while.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwhile(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("while expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("while expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.with.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwith(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('h' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("with expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("with expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.BIG.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBIG(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk32) yyColumn.chunk32 = new Chunk32();
    if (null == yyColumn.chunk32.fBIG) 
      yyColumn.chunk32.fBIG = pBIG$1(yyStart);
    return yyColumn.chunk32.fBIG;
  }

  /** Actually parse Keyword.BIG. */
  private Result pBIG$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('B' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('I' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('G' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = "BIG";

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("BIG expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("BIG expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.SI_unit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSI_unit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('S' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('I' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('_' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('t' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = "SI_unit";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("s i_unit expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("s i_unit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.abstract.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pabstract(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk32) yyColumn.chunk32 = new Chunk32();
    if (null == yyColumn.chunk32.fabstract) 
      yyColumn.chunk32.fabstract = pabstract$1(yyStart);
    return yyColumn.chunk32.fabstract;
  }

  /** Actually parse Keyword.abstract. */
  private Result pabstract$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('b' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('c' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('t' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = "abstract";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("abstract expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("abstract expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.atomic.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result patomic(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk33) yyColumn.chunk33 = new Chunk33();
    if (null == yyColumn.chunk33.fatomic) 
      yyColumn.chunk33.fatomic = patomic$1(yyStart);
    return yyColumn.chunk33.fatomic;
  }

  /** Actually parse Keyword.atomic. */
  private Result patomic$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('t' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('c' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "atomic";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("atomic expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("atomic expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.end.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pend(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk33) yyColumn.chunk33 = new Chunk33();
    if (null == yyColumn.chunk33.fend) 
      yyColumn.chunk33.fend = pend$1(yyStart);
    return yyColumn.chunk33.fend;
  }

  /** Actually parse Keyword.end. */
  private Result pend$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('d' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("end expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("end expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.getter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgetter(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('g' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "getter";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("getter expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("getter expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.grammar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgrammar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('g' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('m' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('r' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("grammar expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("grammar expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.hidden.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result phidden(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk33) yyColumn.chunk33 = new Chunk33();
    if (null == yyColumn.chunk33.fhidden) 
      yyColumn.chunk33.fhidden = phidden$1(yyStart);
    return yyColumn.chunk33.fhidden;
  }

  /** Actually parse Keyword.hidden. */
  private Result phidden$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('h' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('d' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('d' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("hidden expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("hidden expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.io.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pio(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("io expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("io expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.native.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pnative(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk33) yyColumn.chunk33 = new Chunk33();
    if (null == yyColumn.chunk33.fnative) 
      yyColumn.chunk33.fnative = pnative$1(yyStart);
    return yyColumn.chunk33.fnative;
  }

  /** Actually parse Keyword.native. */
  private Result pnative$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('n' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('v' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "native";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("native expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("native expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.override.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result poverride(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk33) yyColumn.chunk33 = new Chunk33();
    if (null == yyColumn.chunk33.foverride) 
      yyColumn.chunk33.foverride = poverride$1(yyStart);
    return yyColumn.chunk33.foverride;
  }

  /** Actually parse Keyword.override. */
  private Result poverride$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('v' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('d' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("override expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("override expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.private.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pprivate(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk33) yyColumn.chunk33 = new Chunk33();
    if (null == yyColumn.chunk33.fprivate) 
      yyColumn.chunk33.fprivate = pprivate$1(yyStart);
    return yyColumn.chunk33.fprivate;
  }

  /** Actually parse Keyword.private. */
  private Result pprivate$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('v' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = "private";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("private expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("private expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.self.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pself(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk33) yyColumn.chunk33 = new Chunk33();
    if (null == yyColumn.chunk33.fself) 
      yyColumn.chunk33.fself = pself$1(yyStart);
    return yyColumn.chunk33.fself;
  }

  /** Actually parse Keyword.self. */
  private Result pself$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('f' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = "self";

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("self expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("self expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.settable.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psettable(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk33) yyColumn.chunk33 = new Chunk33();
    if (null == yyColumn.chunk33.fsettable) 
      yyColumn.chunk33.fsettable = psettable$1(yyStart);
    return yyColumn.chunk33.fsettable;
  }

  /** Actually parse Keyword.settable. */
  private Result psettable$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('b' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('l' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("settable expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("settable expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.setter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psetter(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "setter";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("setter expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("setter expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.test.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptest(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk33) yyColumn.chunk33 = new Chunk33();
    if (null == yyColumn.chunk33.ftest) 
      yyColumn.chunk33.ftest = ptest$1(yyStart);
    return yyColumn.chunk33.ftest;
  }

  /** Actually parse Keyword.test. */
  private Result ptest$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = "test";

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("test expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("test expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.transient.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptransient(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk33) yyColumn.chunk33 = new Chunk33();
    if (null == yyColumn.chunk33.ftransient) 
      yyColumn.chunk33.ftransient = ptransient$1(yyStart);
    return yyColumn.chunk33.ftransient;
  }

  /** Actually parse Keyword.transient. */
  private Result ptransient$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('n' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('s' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('t' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("transient expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("transient expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.unit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result punit(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk34) yyColumn.chunk34 = new Chunk34();
    if (null == yyColumn.chunk34.funit) 
      yyColumn.chunk34.funit = punit$1(yyStart);
    return yyColumn.chunk34.funit;
  }

  /** Actually parse Keyword.unit. */
  private Result punit$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('u' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = "unit";

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("unit expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("unit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.value.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pvalue(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("value expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("value expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.var.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pvar(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk34) yyColumn.chunk34 = new Chunk34();
    if (null == yyColumn.chunk34.fvar) 
      yyColumn.chunk34.fvar = pvar$1(yyStart);
    return yyColumn.chunk34.fvar;
  }

  /** Actually parse Keyword.var. */
  private Result pvar$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = "var";

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("var expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("var expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.widens.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwidens(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk34) yyColumn.chunk34 = new Chunk34();
    if (null == yyColumn.chunk34.fwidens) 
      yyColumn.chunk34.fwidens = pwidens$1(yyStart);
    return yyColumn.chunk34.fwidens;
  }

  /** Actually parse Keyword.widens. */
  private Result pwidens$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('d' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "widens";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("widens expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("widens expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.wrapped.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwrapped(final int yyStart) throws IOException {
    FortressColumn yyColumn = (FortressColumn)column(yyStart);
    if (null == yyColumn.chunk34) yyColumn.chunk34 = new Chunk34();
    if (null == yyColumn.chunk34.fwrapped) 
      yyColumn.chunk34.fwrapped = pwrapped$1(yyStart);
    return yyColumn.chunk34.fwrapped;
  }

  /** Actually parse Keyword.wrapped. */
  private Result pwrapped$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('p' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('p' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('d' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("wrapped expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("wrapped expected", yyStart);
    return yyError;
  }

  // =========================================================================

  Span createSpan(int start, int end) {
    Column s = column(start);
    Column e = column(end-1);
    SourceLocRats slStart = new SourceLocRats(s.file, s.line, s.column-1);
    SourceLocRats slEnd   = new SourceLocRats(e.file, e.line, e.column-1);
    return new Span(slStart, slEnd);
  }
  static {
    add(FORTRESS_SYNTAX_SPECIAL_SYMBOLS, new String[] {
      "AND",    "BACKSPACE",    "FORM_FEED",    "do",    "NEWLINE",
      "NOT",    "RETURN",    "TAB",    "SPACE"
    });
    
    add(FORTRESS_SYNTAX_SPECIAL_CHARS, new String[] {
      "#",    ":",    "`",    "\\+",    "\\?",    "\\*",    "\\[",    "\\]", "\\|"
    });
  }
  static {
    add(FORTRESS_KEYWORDS, new String[] {
      "FORALL",
      
      "goto",         "idiom",        "public",       "pure",
      "reciprocal",   "static",
      
      "BIG",          "SI_unit",      "absorbs",      "abstract",
      "also",         "api",          "as",           "asif",
      "at",           "atomic",       "bool",         "case",
      "catch",        "coerce",       "coerces",      "component",
      "comprises",    "default",      "dim",          "do",
      "elif",         "else",         "end",          "ensures",
      "except",       "excludes",     "exit",         "export",
      "extends",      "finally",      "fn",           "for",
      "forbid",       "getter",       "grammar",      "hidden",
      "if",           "import",       "in",           "int",
      "invariant",    "io",           "label",        "most",
      "nat",          "native",       "object",       "of",
      "opr",          "or",           "override",     "private",
      "property",     "provided",     "requires",
      "self",         "settable",     "setter",       "spawn",
      "syntax",       "test",         "then",         "throw",
      "throws",       "trait",        "transient",    "try",
      "tryatomic",    "type",         "typecase",     "unit",
      "value",        "var",          "where",        "while",
      "widens",       "with",         "wrapped"
    });
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
