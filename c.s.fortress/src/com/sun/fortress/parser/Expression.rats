/*******************************************************************************
    Copyright 2008 Sun Microsystems, Inc.,
    4150 Network Circle, Santa Clara, California 95054, U.S.A.
    All rights reserved.

    U.S. Government Rights - Commercial software.
    Government users are subject to the Sun Microsystems, Inc. standard
    license agreement and applicable provisions of the FAR and its supplements.

    Use is subject to license terms.

    This distribution may include materials developed by third parties.

    Sun, Sun Microsystems, the Sun logo and Java are trademarks or registered
    trademarks of Sun Microsystems, Inc. in the U.S. and other countries.
 ******************************************************************************/

/*
 * Definition of Fortress expressions.
 */
module com.sun.fortress.parser.Expression(Param, NoNewlineHeader,
                                          MayNewlineHeader, Type, DelimitedExpr,
                                          Literal, Identifier, Keyword, Symbol,
                                          Spacing);

import Param;
import NoNewlineHeader;
import MayNewlineHeader;
import Type;
import DelimitedExpr;
import Literal;
import Identifier;
import Keyword;
import Symbol;
import Spacing;

/* Expr ::=
     AssignExpr
   | OpExpr
   | DelimitedExpr
   | FlowExpr
   | fn w ValParam (w IsType)? (w Throws)? w => w Expr
   | Expr w as w Type
   | Expr w asif w Type
 */
Expr Expr =
     seed:ExprFront list:ExprTail* { yyValue = (Expr)apply(list, seed); };
Expr ExprFront =
     AssignExpr
   / OpExpr
   / DelimitedExpr
   / <Flow> FlowExpr
   / <Fn> fn w a1:ValParam a2:(w IsType)? a3:(w Throws)? w match w a4:Expr
     { Option<Type> ty_opt = Option.wrap(a2);
       Option<List<TraitType>> tys = Option.wrap(a3);
       yyValue = ExprFactory.makeFnExpr(createSpan(yyStart,yyCount), a1, ty_opt,
                                        tys, a4);
     };

constant transient Action<Expr> ExprTail =
     <As> As
   / <Asif> AsIf
   ;

constant inline Action<Expr> As =
     w as w a1:Type
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               return new AsExpr(createSpan(yyStart,yyCount), false, (Expr)base,
                                 a1);
           }};
     };

constant inline Action<Expr> AsIf =
     w asif w a1:Type
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               return new AsIfExpr(createSpan(yyStart,yyCount), false,
                                   (Expr)base, a1);
           }};
     };

/* AssignExpr ::= AssignLefts w AssignOp w Expr */
Expr AssignExpr = a1:AssignLefts w a2:AssignOp w a3:Expr
    { yyValue = new Assignment(createSpan(yyStart,yyCount), false, a1, a2, a3);};

/* AssignLefts ::=
     ( w AssignLeft (w , w AssignLeft)* w )
   | AssignLeft
 */
List<LHS> AssignLefts =
     openparen w a1:AssignLeft a2s:(w comma w AssignLeft)* w closeparen
     { yyValue = FortressUtil.mkList(a1, a2s.list()); }
   / a1:AssignLeft
     { yyValue = FortressUtil.mkList(a1); };

/* AssignLeft ::=
     SubscriptExpr
   | FieldSelection
   | QualifiedName
   SubscriptExpr ::= Primay LeftEncloser (w ExprList)? w RightEncloser
   FieldSelection ::= Primary . Id
 */
LHS AssignLeft =
     seed:PrimaryFront list:AssignLeftTail+
     { Expr left = (Expr)apply(list, seed);
       if (left instanceof LHS) yyValue = (LHS)left;
       else yyValue = null;
     }
   / a1:QualifiedName
     { yyValue = new VarRef(createSpan(yyStart,yyCount), false, a1); };

constant transient Action<Expr> AssignLeftTail =
     SubscriptAssign
   / FieldSelectionAssign
   ;

constant inline Action<Expr> SubscriptAssign =
     a1:LeftEncloser a2:(w ExprList)? w a3:RightEncloser
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
             Span span = createSpan(yyStart,yyCount);
             List<Expr> es;
             if (a2 == null) es = FortressUtil.emptyExprs();
             else            es = a2;
             Enclosing op = new Enclosing(FortressUtil.spanTwo(a1,a3),a1,a3);
             return ExprFactory.makeSubscriptExpr(span,base,es,Option.some(op));
            }};
     };

constant inline Action<Expr> FieldSelectionAssign =
    dot a1:Id
    { yyValue = new Action<Expr>() {
          public Expr run(Expr base) {
              return new FieldRef(createSpan(yyStart,yyCount), false, base, a1);
          }};
    };

/* OpExpr ::=
     OpExprNoEnc
   | OpExprLeftEncloser
   | Encloser
 */
Expr OpExpr =
     a1:OpExprNoEnc
     { yyValue = Resolver.resolveOps(a1); }
   / a1:OpExprLeftEncloser
     { yyValue = Resolver.resolveOps(a1); }
   / a1:Encloser
     { PrecedenceOpExpr e =
           new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
       yyValue = Resolver.resolveOps(PureList.make(e));
     };

/* OpExprNoEnc ::=
     OpExprPrimary
   | OpExprPrefix
   | Op
 */
PureList<PrecedenceOpExpr> OpExprNoEnc =
     OpExprPrimary
   / OpExprPrefix
   / a1:Op
     { PrecedenceOpExpr e = new RealExpr(ASTUtil.nofix(createSpan(yyStart,yyCount), a1));
       yyValue = PureList.make(e);
     };

/* TightInfixRight ::=
     Encloser OpExprPrimary
   | Encloser OpExprPrefix
   | Encloser wr OpExprPrimary
   | Encloser wr LooseInfix
   | Encloser wr LeftLooseInfix
   | Encloser
 */
PureList<PrecedenceOpExpr> TightInfixRight =
     a1:Encloser a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1)); }
   / a1:Encloser a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1)); }
   / <Primary>   a1:Encloser wr a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new Right(a1)); }
   / <Loose>     a1:Encloser wr a2:LooseInfix
     { yyValue = a2.cons((PrecedenceOpExpr)new Right(a1)); }
   / <LeftLoose> a1:Encloser wr a2:LeftLooseInfix
     { yyValue = a2.cons((PrecedenceOpExpr)new Right(a1)); }
   / a1:Encloser
     { yyValue = PureList.make((PrecedenceOpExpr)new Right(a1)); };

/* LeftLooseInfix ::=
     OpExprLeftEncloser
   | Encloser wr OpExprPrimary
   | Encloser wr OpExprPrefix
   | Encloser wr OpExprLeftEncloser
 */
PureList<PrecedenceOpExpr> LeftLooseInfix =
     OpExprLeftEncloser
   / <Primary> a1:Encloser wr a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); }
   / <Prefix>  a1:Encloser wr a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); }
   / <Left>    a1:Encloser wr a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); };

/* OpExprLeftEncloser ::= Encloser OpExprNoEnc */
PureList<PrecedenceOpExpr> OpExprLeftEncloser =
     a1:Encloser a2:OpExprNoEnc
     { yyValue = a2.cons(new Left(a1)); };

/* OpExprPrimary ::=
     Primary TightInfixPostfix
   | Primary TightInfixRight
   | Primary wr OpExprPrimary
   | Primary wr LooseInfix
   | Primary wr LeftLooseInfix
   | Primary
 */
PureList<PrecedenceOpExpr> OpExprPrimary =
     a1:Primary a2:TightInfixPostfix
     { yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1))); }
   / a1:Primary a2:TightInfixRight
     { yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1))); }
   / <Primary>   a1:Primary wr a2:OpExprPrimary
     { yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1))); }
   / <Loose>     a1:Primary wr a2:LooseInfix
     { yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1))); }
   / <LeftLoose> a1:Primary wr a2:LeftLooseInfix
     { yyValue = a2.cons(new RealExpr(FortressUtil.buildPrimary(a1))); }
   / a1:Primary
     { yyValue =
           PureList.make((PrecedenceOpExpr)new RealExpr(FortressUtil.buildPrimary(a1))); };

/* OpExprPrefix ::=
     Op OpExprPrimary
   | Op OpExprPrefix
   | Op OpExprLeftEncloser
   | Op wr OpExprPrimary
   | Op wr OpExprPrefix
   | Op wr OpExprLeftEncloser
 */
PureList<PrecedenceOpExpr> OpExprPrefix =
     a1:Op a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1)); }
   / a1:Op a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1)); }
   / a1:Op a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new TightPrefix(a1)); }
   / <Primary> a1:Op wr a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1)); }
   / <Prefix>  a1:Op wr a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1)); }
   / <Left>    a1:Op wr a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new LoosePrefix(a1)); };

/* TightInfixPostfix ::=
     Op OpExprPrimary
   | Op OpExprPrefix
   | Op OpExprLeftEncloser
   | Op wr OpExprPrimary
   | Op wr OpExprPrefix
   | Op wr OpExprLeftEncloser
   | Op
 */
PureList<PrecedenceOpExpr> TightInfixPostfix =
     a1:Op a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1)); }
   / a1:Op a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1)); }
   / a1:Op a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new TightInfix(a1)); }
   / <Primary> a1:Op wr a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1)); }
   / <Prefix>  a1:Op wr a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1)); }
   / <Left>    a1:Op wr a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new Postfix(a1)); }
   / a1:Op
     { yyValue = PureList.make((PrecedenceOpExpr)new Postfix(a1)); };

/* LooseInfix ::=
     Op wr OpExprPrimary
   | Op wr OpExprPrefix
   | Op wr OpExprLeftEncloser
 */
PureList<PrecedenceOpExpr> LooseInfix =
     a1:Op wr a2:OpExprPrimary
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); }
   / a1:Op wr a2:OpExprPrefix
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); }
   / <Left> a1:Op wr a2:OpExprLeftEncloser
     { yyValue = a2.cons((PrecedenceOpExpr)new LooseInfix(a1)); };

/* Primary ::=
     LeftAssociatedPrimary
   | MathPrimary
 */
constant PureList<Expr> Primary =
     a1:(LeftAssociatedPrimary / MathPrimary)
     { yyValue = PureList.make(a1); };

/* LeftAssociatedPrimary ::=
     DottedIdChain StaticArgs? Subscripting* ParenthesisDelimited* Selector*
   | PrimaryFront Subscripting* ParenthesisDelimited* Selector+
 */
constant Expr LeftAssociatedPrimary =
     a1:DottedIdChain a2:StaticArgs a3:ParenthesisDelimited
     a4s:ParenthesisDelimitedLeft* a5s:Selector*
     { Id last = IterUtil.last(a1);
       Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
       Span span = FortressUtil.spanTwo(receiver,a3);
       Expr e1 = new MethodInvocation(span, receiver, last, a2, a3);
       Expr e2 = (Expr)apply(a4s, e1);
       yyValue = (Expr)apply(a5s, e2);
     }
   / a1:DottedIdChain a2s:SubscriptingLeft+ a3s:ParenthesisDelimitedLeft*
     a4s:Selector*
     { Id last = IterUtil.last(a1);
       Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
       Span span = FortressUtil.spanTwo(receiver,last);
       Expr e1 = new FieldRef(span, receiver, last);
       Expr e2 = (Expr)apply(a2s, e1);
       Expr e3 = (Expr)apply(a3s, e2);
       yyValue = (Expr)apply(a4s, e3);
     }
   / a1:DottedIdChain a2:ParenthesisDelimited a3s:ParenthesisDelimitedLeft+
     a4s:Selector*
     { Id last = IterUtil.last(a1);
       Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
       Span span = FortressUtil.spanTwo(receiver,a2);
       Expr e1 = new MethodInvocation(span, receiver, last, a2);
       Expr e2 = (Expr)apply(a3s, e1);
       yyValue = (Expr)apply(a4s, e2);
     }
   / a1:DottedIdChain a2s:ParenthesisDelimitedLeft* a3s:Selector*
     { Id last = IterUtil.last(a1);
       Expr receiver = ExprFactory.makeReceiver(IterUtil.skipLast(a1));
       Span span = FortressUtil.spanTwo(receiver,last);
       Expr e1 = new FieldRef(span, receiver, last);
       Expr e2 = (Expr)apply(a2s, e1);
       yyValue = (Expr)apply(a3s, e2);
     }
   / a1:PrimaryFront a2s:SubscriptingLeft* a3s:ParenthesisDelimitedLeft*
     a4s:Selector+
     { Expr e1 = (Expr)apply(a2s, a1);
       Expr e2 = (Expr)apply(a3s, e1);
       yyValue = (Expr)apply(a4s, e2);
     };

/* QualifiedName is not yet implemented in the interpreter. */
/* DottedIdChain ::= Id(. w Id)+ */
List<Id> DottedIdChain = a1:Id a2s:(dot w Id)+
    { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* MathPrimary ::= PrimaryFront MathItem* */
constant Expr MathPrimary =
    a1:PrimaryFront a2s:MathItem*
    { Span span = createSpan(yyStart,yyCount);
      List<MathItem> mis = a2s.list();
      if (mis.size() == 0) {
          yyValue = a1;
      } else if (mis.size() == 1) {
          yyValue = ExprFactory.simplifyMathPrimary(span, a1, mis.get(0));
      } else { // mis.size() > 1
          yyValue = new MathPrimary(span, a1, mis);
      }
    };

/* PrimaryFront ::=
     ArrayExpr
   | MapExpr
   | Comprehension
   | LeftEncloser (w ExprList)? w RightEncloser
   | ParenthesisDelimited
   | VarOrFnRef
   | LiteralExpr
   | self
 */
Expr PrimaryFront =
     ArrayExpr
   / MapExpr
   / Comprehension
   / a1:LeftEncloser a2:(w ExprList)? w a3:RightEncloser
     { if (a2 == null) a2 = FortressUtil.emptyExprs();
       yyValue = ASTUtil.enclosing(FortressUtil.spanTwo(a1, a3), a1, a2, a3);
     }
   / ParenthesisDelimited
   / VarOrFnRef
   / LiteralExpr
   / a1:self
     { yyValue = ExprFactory.makeVarRef(createSpan(yyStart,yyCount), a1); }
   ;

/* ArrayExpr is defined in Literal.rats */

/* VarOrFnRef ::= Id StaticArgs? */
Expr VarOrFnRef = a1:Id a2:StaticArgs?
     { QualifiedIdName name = NodeFactory.makeQualifiedIdName(a1.getSpan(), a1);
       if (a2 == null)
            yyValue = new VarRef(createSpan(yyStart,yyCount),false,name);
       else yyValue = ExprFactory.makeFnRef(createSpan(yyStart,yyCount),name,a2);
     };

/* Subscripting ::=
     [ (w ExprList)? w ]
   | { (w ExprList)? w }
   | LeftEncloser (w ExprList)? w RightEncloser
 */
constant inline Action<Expr> SubscriptingLeft =
     a1:(opensquare / opencurly) a2:(w ExprList)? w a3:(closesquare / closecurly)
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               if (PrecedenceMap.ONLY.matchedBrackets(a1, a3)) {
                   Span span = createSpan(yyStart,yyCount);
                   Span spanOpen = createSpan(yyStart, yyStart+1);
                   Span spanClose = createSpan(yyCount-1,1);
                   return FortressUtil.makeSubscripting(span,spanOpen,spanClose,
                                                        a1, a3, base, a2);
               } else return error("Mismatched subscripting operator: " + a1 +
                                   " and " + a3);
           }};
     }
   / a1:LeftEncloser a2:(w ExprList)? w a3:RightEncloser
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               Span span = createSpan(yyStart,yyCount);
               return FortressUtil.makeSubscripting(span, base, a1, a3, a2);
           }};
     };

/* ParenthesisDelimited ::=
     Parenthesized
   | ArgExpr
   | ( w )
 */
constant inline Action<Expr> ParenthesisDelimitedLeft =
    a1:ParenthesisDelimited
    { yyValue = new Action<Expr>() {
          public Expr run(Expr base) {
              List<Expr> exprs = FortressUtil.mkList(base, a1);
              return new TightJuxt(FortressUtil.spanTwo(base, a1), false, exprs);
          }};
    };

Expr ParenthesisDelimited =
     Parenthesized
   / ArgExpr
   / openparen w closeparen
     { yyValue = ExprFactory.makeVoidLiteralExpr(createSpan(yyStart,yyCount)); };

/* Selector ::=
     MethodInvocation ParenthesisDelimited*
   | FieldSelection Subscripting* ParenthesisDelimited*
   MethodInvocation ::= . w Id StaticArgs? ParenthesisDelimited
   FieldSelection ::= . w Id
 */
constant transient Action<Expr> Selector =
     MethodInvocationSelector
   / FieldSelectionSelector
   ;

constant inline Action<Expr> MethodInvocationSelector = /* REVERSE ORDER */
     dot w a1:Id a2:StaticArgs? a3:ParenthesisDelimited
     a4s:ParenthesisDelimitedLeft*
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               List<StaticArg> sargs;
               if (a2 == null) sargs = Collections.<StaticArg>emptyList();
               else            sargs = a2;
               Expr mtdInv = new MethodInvocation(FortressUtil.spanTwo(base, a3),
                                                  false, base, a1, sargs, a3);
               return (Expr)apply(a4s, mtdInv);
           }};
     };

constant inline Action<Expr> FieldSelectionSelector =
     dot w a1:Id a2s:SubscriptingLeft* a3s:ParenthesisDelimitedLeft*
     { yyValue = new Action<Expr>() {
           public Expr run(Expr base) {
               Expr fldSel = new FieldRef(createSpan(yyStart,yyCount), false,
                                          base, a1);
               return (Expr)apply(a3s, (Expr)apply(a2s, fldSel));
           }};
     };

/* MathItem ::=
     Subscripting
   | Exponentiation
   | ParenthesisDelimited
   | VarOrFnRef
   | LiteralExpr
   | self
 */
MathItem MathItem =
     Subscripting
   / Exponentiation
   / a1:ParenthesisDelimited
     { yyValue = new ParenthesisDelimitedMI(a1.getSpan(), a1); }
   / a1:VarOrFnRef
     { yyValue = new NonParenthesisDelimitedMI(a1.getSpan(), a1); }
   / a1:LiteralExpr
     { yyValue = new NonParenthesisDelimitedMI(a1.getSpan(), a1); }
   / a1:self
     { Span span = createSpan(yyStart,yyCount);
       Expr expr = ExprFactory.makeVarRef(span, a1);
       yyValue = new NonParenthesisDelimitedMI(span, expr);
     };

/* Subscripting ::=
     [ (w ExprList)? w ]
   | { (w ExprList)? w }
   | LeftEncloser (w ExprList)? w RightEncloser
 */
SubscriptingMI Subscripting =
     a1:(opensquare / opencurly) a2:(w ExprList)? w a3:(closesquare / closecurly)
     { if (PrecedenceMap.ONLY.matchedBrackets(a1, a3)) {
         Span span = createSpan(yyStart,yyCount);
         Span spanOpen = createSpan(yyStart, yyStart+1);
         Span spanClose = createSpan(yyCount-1,1);
         Op open  = NodeFactory.makeOpEnclosing(spanOpen, a1);
         Op close = NodeFactory.makeOpEnclosing(spanClose, a3);
         Enclosing op = new Enclosing(FortressUtil.spanTwo(open,close),
                                      open,close);
         yyValue = new SubscriptingMI(span, op, a2);
        } else return error("Mismatched subscripting operator: " + a1 + " and "
                            + a3);
     }
   / a1:LeftEncloser a2:(w ExprList)? w a3:RightEncloser
     { Span span = createSpan(yyStart,yyCount);
       Enclosing op = new Enclosing(FortressUtil.spanTwo(a1,a3),a1,a3);
       yyValue = new SubscriptingMI(span, op, a2);
     };

/* Exponentiation ::=
     ^ Exponent
   | ExponentOp
 */
ExponentiationMI Exponentiation =
     a1:caret a2:Exponent
     { Span span = createSpan(yyStart,yyCount);
       yyValue = new ExponentiationMI(span, NodeFactory.makeOpInfix(span, a1),
                                      Option.wrap(a2));
     }
   / a1:ExponentOp
     { yyValue = new ExponentiationMI(a1.getSpan(), a1, Option.<Expr>none()); };

/* Exponent ::=
     Id
   | ParenthesisDelimited
   | LiteralExpr
   | self
 */
Expr Exponent =
     a1:Id { yyValue = ExprFactory.makeVarRef(a1); }
   / ParenthesisDelimited
   / LiteralExpr
   / a1:self
     { yyValue = ExprFactory.makeVarRef(createSpan(yyStart,yyCount), a1); };

/* FlowExpr ::=
     exit (w Id)? (w with w Expr)?
   | Accumulator StaticArgs? (w [ w GeneratorClauseList w ])? w Expr
   | atomic w AtomicBack
   | tryatomic w AtomicBack
   | spawn w Expr
   | throw w Expr
 */
Expr FlowExpr =
     exit a1:(w Id)? a2:(w with w Expr)?
     { Option<Id> name = (a1 == null) ? Option.<Id>none() : Option.some(a1);
       Option<Expr> expr = Option.wrap(a2);
       yyValue = new Exit(createSpan(yyStart,yyCount), false, name, expr);
     }
   / a1:Accumulator a2:StaticArgs?
     a3:(w void:opensquare w GeneratorClauseList w void:closesquare)? w a4:Expr
     { if (a3 == null) a3 = Collections.<GeneratorClause>emptyList();
       if (a2 == null) a2 = Collections.<StaticArg>emptyList();
       yyValue = new Accumulator(createSpan(yyStart,yyCount), a2, a1, a3, a4);
     }
   / atomic w a1:AtomicBack
     { yyValue = new AtomicExpr(createSpan(yyStart,yyCount), false, a1); }
   / tryatomic w a1:AtomicBack
     { yyValue = new TryAtomicExpr(createSpan(yyStart,yyCount), false, a1); }
   / spawn w a1:Expr
     { yyValue = new Spawn(createSpan(yyStart,yyCount), false, a1); }
   / throw w a1:Expr
     { yyValue = new Throw(createSpan(yyStart,yyCount), false, a1); };

/* AtomicBack ::=
     AssignExpr
   | OpExpr
   | DelimitedExpr
 */
Expr AtomicBack =
     AssignExpr
   / OpExpr
   / DelimitedExpr ;

/* GeneratorClauseList ::= GeneratorBinding (w , w GeneratorClause)* */
List<GeneratorClause> GeneratorClauseList =
     a1:GeneratorBinding a2s:(w comma w GeneratorClause)*
     { yyValue = FortressUtil.mkList(a1, a2s.list()); };

/* GeneratorBinding ::= BindIdOrBindIdTuple w <- w Expr */
GeneratorClause GeneratorBinding =
     a1:BindIdOrBindIdTuple w leftarrow w a2:Expr
     { yyValue = ExprFactory.makeGeneratorClause(createSpan(yyStart,yyCount),
                                                 a1,a2);
     };

/* GeneratorClause ::=
     GeneratorBinding
   | Expr
 */
GeneratorClause GeneratorClause =
     GeneratorBinding
   / a1:Expr
     { yyValue = new GeneratorClause(createSpan(yyStart,yyCount),
                               Collections.<Id>emptyList(), a1);
     };
