// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.13.2,
// (C) 2004-2007 Robert Grimm,
// on Tuesday, March 11, 2008 at 11:25:28 PM.
// Edit at your own risk.
// ===========================================================================

package com.sun.fortress.parser.preparser;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import com.sun.fortress.interpreter.evaluator.ProgramError;
import com.sun.fortress.parser_util.precedence_opexpr.PrecedenceOpExpr;
import com.sun.fortress.parser_util.precedence_opexpr.Left;
import com.sun.fortress.parser_util.precedence_opexpr.Right;
import com.sun.fortress.parser_util.precedence_opexpr.RealExpr;
import com.sun.fortress.parser_util.precedence_opexpr.TightInfix;
import com.sun.fortress.parser_util.precedence_opexpr.LooseInfix;
import com.sun.fortress.parser_util.precedence_opexpr.Prefix;
import com.sun.fortress.parser_util.precedence_opexpr.Postfix;
import com.sun.fortress.parser_util.precedence_resolver.*;
import com.sun.fortress.nodes.*;
import com.sun.fortress.nodes_util.*;
import com.sun.fortress.parser_util.*;
import com.sun.fortress.useful.PureList;
import com.sun.fortress.useful.Empty;
import com.sun.fortress.useful.Cons;
import edu.rice.cs.plt.tuple.Option;
import edu.rice.cs.plt.iter.IterUtil;
import xtc.util.Action;
import java.util.Collections;
import java.util.ArrayList;
import java.util.List;

import static com.sun.fortress.interpreter.evaluator.ProgramError.errorMsg;
import static com.sun.fortress.interpreter.evaluator.ProgramError.error;
import static com.sun.fortress.interpreter.evaluator.InterpreterBug.bug;

/**
 * Packrat parser for grammar <code>com.sun.fortress.parser.preparser.PreFortress</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.13.2, (C) 2004-2007 Robert Grimm.
 */
public final class PreFortress extends ParserBase {

  /** The FORTRESS_KEYWORDS set. */
  public static final Set<String> FORTRESS_KEYWORDS = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fImports;
    Result fImports$$Star1;
    Result fImport;
    Result fAliasedSimpleName;
    Result fPreFortress$EncloserPair;
    Result fAliasedAPIName;
    Result fSpace;
    Result fNewline;
    Result fComment;
    Result fid;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fid$$Star1;
    Result fidrest;
    Result fId;
    Result fSimpleName;
    Result fAPIName;
    Result fAPIName$$Star1;
    Result fEncloser;
    Result fLeftEncloser;
    Result fRightEncloser;
    Result fbars;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fbars$$Star1;
    Result fslashes;
    Result fslashes$$Star1;
    Result fslashes$$Star2;
    Result fgreaters;
    Result fgreaters$$Star1;
    Result fencloser;
    Result fleftEncloser;
    Result frightEncloser;
    Result frightEncloserMulti;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result frightEncloserMulti$$Plus1;
    Result frightEncloserMulti$$Plus2;
    Result fOp;
    Result fcompOp;
    Result fmultiOp;
    Result fsingleOp;
    Result fop;
    Result fsemicolon;
    Result fcolon;
    Result fellipses;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class PreFortressColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public PreFortress(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public PreFortress(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new PreFortressColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.preparser.PreFortress.File.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pFile(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    List<Import>    yyOpValue1;
    CompilationUnit yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pCompilationUnit(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pFile$$Choice1(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Import> v$el$2 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$2;
    }
    { // Start scope for a1.
      List<Import> a1 = yyOpValue1;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        if (a1 == null) a1 = Collections.<Import>emptyList();
        Span span = createSpan(yyStart,yyCount);
        String file = span.begin.getFileName();
        APIName name = NodeFactory.makeAPIName(span, file, "\\.");
        List<Export> a3 = Collections.<Export>emptyList();
        List<Decl> a4 = Collections.<Decl>emptyList();
        yyValue = new Component(span, name, a1, a3, a4);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.File$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pFile$$Choice1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    List<Import> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pImports(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyResult = psemicolon(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.CompilationUnit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCompilationUnit(final int yyStart) throws IOException {
    Result          yyResult;
    CompilationUnit yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComponent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.Component.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComponent(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    int          yyRepetition1;
    int          yyOption1;
    List<Import> yyOpValue1;
    Component    yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcomponent(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAPIName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          APIName a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pComponent$$Choice1(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<Import> v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for a2.
            List<Import> a2 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              while (true) {

                yyC = character(yyRepetition1);
                if (-1 != yyC) {
                  yyIndex = yyRepetition1 + 1;

                  yyRepetition1 = yyIndex;
                  continue;
                }
                break;
              }

              if (a2 == null) a2 = Collections.<Import>emptyList();
              List<Export> a3 = Collections.<Export>emptyList();
              List<Decl> a4 = Collections.<Decl>emptyList();
              yyValue = new Component(createSpan(yyStart,yyCount), a1, a2, a3, a4);

              return new SemanticValue(yyValue, yyRepetition1, yyError);
            }
          } // End scope for a2.
        }
      }
    }

    // Done.
    yyError = yyError.select("component expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.Component$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComponent$$Choice1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    List<Import> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pImports(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyResult = psemicolon(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.preparser.PreFortress.Imports.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImports(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fImports) 
      yyColumn.chunk1.fImports = pImports$1(yyStart);
    return yyColumn.chunk1.fImports;
  }

  /** Actually parse com.sun.fortress.parser.preparser.PreFortress.Imports. */
  private Result pImports$1(final int yyStart) throws IOException {
    Result       yyResult;
    List<Import> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pImport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Import> a1 = yyResult.semanticValue();

      yyResult = pImports$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<List<Import>> a2s = yyResult.semanticValue();

        for (List<Import> i : a2s.list()) {
          for (Import j : i) {
            a1.add(j);
          }
        }
        yyValue = a1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.Imports$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImports$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fImports$$Star1) 
      yyColumn.chunk1.fImports$$Star1 = pImports$$Star1$1(yyStart);
    return yyColumn.chunk1.fImports$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.preparser.PreFortress.Imports$$Star1. */
  private Result pImports$$Star1$1(final int yyStart) throws IOException {
    Result             yyResult;
    Pair<List<Import>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pImport(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<Import> v$el$1 = yyResult.semanticValue();

        yyResult = pImports$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<List<Import>> v$2 = yyResult.semanticValue();

          yyValue = new Pair<List<Import>>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal com.sun.fortress.parser.preparser.PreFortress.Import.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImport(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fImport) 
      yyColumn.chunk1.fImport = pImport$1(yyStart);
    return yyColumn.chunk1.fImport;
  }

  /** Actually parse com.sun.fortress.parser.preparser.PreFortress.Import. */
  private Result pImport$1(final int yyStart) throws IOException {
    Result       yyResult;
    List<Import> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pimport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pImportedNames(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = papi(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pAliasedAPINames(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<AliasedAPIName> a1 = yyResult.semanticValue();

              Import imp = new ImportApi(createSpan(yyStart, yyCount), a1);
              yyValue = FortressUtil.mkList(imp);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.ImportedNames.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImportedNames(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    Object       yyOpValue1;
    List<Import> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAPIName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      APIName a1 = yyResult.semanticValue();

      yyResult = pdot(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = popencurly(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              final int yyChoice1 = yyResult.index;

              // Nested alternative 1.

              yyResult = pellipses(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pclosecurly(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption1  = yyResult.index;
                    yyOpValue1 = null;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pexcept(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pw(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pSimpleNames(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            List<SimpleName> v$el$1 = yyResult.semanticValue();

                            yyOption1  = yyResult.index;
                            yyOpValue1 = v$el$1;
                          }
                        }
                      }
                    }
                    { // Start scope for a2.
                      List<SimpleName> a2 = cast(yyOpValue1);

                      if (a2 == null) a2 = Collections.<SimpleName>emptyList();
                      yyValue = FortressUtil.mkList((Import)new ImportStar(
                      createSpan(yyStart,yyCount),a1,a2));

                      return new SemanticValue(yyValue, yyOption1, yyError);
                    } // End scope for a2.
                  }
                }
              }

              // Nested alternative 2.

              yyResult = pAliasedSimpleNameList(yyChoice1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<AliasedSimpleName> a2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcomma(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pellipses(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        String v$el$2 = yyResult.semanticValue();

                        yyOption1  = yyResult.index;
                        yyOpValue1 = v$el$2;
                      }
                    }
                  }
                }
                { // Start scope for a3.
                  String a3 = cast(yyOpValue1);

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pclosecurly(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      Span span = createSpan(yyStart,yyCount);
                      List<Import> imports = FortressUtil.mkList((Import)new ImportNames(span,
                      a1,a2));
                      if (a3 != null)
                      imports.add((Import)new ImportStar(span, a1,
                      Collections.<SimpleName>emptyList()));
                      yyValue = imports;

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                } // End scope for a3.
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pQualifiedName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QualifiedIdName a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pas(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id v$el$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
          }
        }
      }
      { // Start scope for a2.
        Id a2 = cast(yyOpValue1);

        AliasedSimpleName an;
        APIName api = Option.unwrap(a1.getApi());
        SimpleName name = a1.getName();
        if (a2 == null)
        an = NodeFactory.makeAliasedSimpleName(name.getSpan(), name);
        else
        an = NodeFactory.makeAliasedSimpleName(FortressUtil.spanTwo(name,a2),
        name, a2);
        yyValue = FortressUtil.mkList((Import)new ImportNames(
        createSpan(yyStart,yyCount),
        api, FortressUtil.mkList(an)));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.SimpleNames.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleNames(final int yyStart) throws IOException {
    Result           yyResult;
    List<SimpleName> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimpleName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SimpleName a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSimpleNameList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.SimpleNameList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleNameList(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyRepetition1;
    Pair<SimpleName> yyRepValue1;
    List<SimpleName> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimpleName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SimpleName a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pSimpleName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                SimpleName v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<SimpleName>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<SimpleName> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.AliasedSimpleName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedSimpleName(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAliasedSimpleName) 
      yyColumn.chunk1.fAliasedSimpleName = pAliasedSimpleName$1(yyStart);
    return yyColumn.chunk1.fAliasedSimpleName;
  }

  /** Actually parse com.sun.fortress.parser.preparser.PreFortress.AliasedSimpleName. */
  private Result pAliasedSimpleName$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    Object            yyOpValue1;
    AliasedSimpleName yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pas(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        Id a2 = cast(yyOpValue1);

        if (a2 == null)
        yyValue = NodeFactory.makeAliasedSimpleName(createSpan(yyStart,yyCount), a1);
        else
        yyValue = NodeFactory.makeAliasedSimpleName(createSpan(yyStart,yyCount), a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pOp(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pas(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pOp(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Op v$el$2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
              }
            }
          }
          { // Start scope for a2.
            Op a2 = cast(yyOpValue1);

            if (a2 == null)
            yyValue = NodeFactory.makeAliasedSimpleName(createSpan(yyStart,yyCount),
            a1);
            else
            yyValue = NodeFactory.makeAliasedSimpleName(createSpan(yyStart,yyCount),
            a1,
            a2);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a2.
        }

        // Nested alternative 2.

        yyResult = pPreFortress$EncloserPair(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Enclosing a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pas(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pPreFortress$EncloserPair(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Enclosing v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
            }
          }
          { // Start scope for a2.
            Enclosing a2 = cast(yyOpValue1);

            Span span = createSpan(yyStart,yyCount);
            if (a2 == null)
            yyValue = NodeFactory.makeAliasedSimpleName(span, a1);
            else
            yyValue = NodeFactory.makeAliasedSimpleName(span, a1, a2);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.EncloserPair.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPreFortress$EncloserPair(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fPreFortress$EncloserPair) 
      yyColumn.chunk1.fPreFortress$EncloserPair = pPreFortress$EncloserPair$1(yyStart);
    return yyColumn.chunk1.fPreFortress$EncloserPair;
  }

  /** Actually parse com.sun.fortress.parser.preparser.PreFortress.EncloserPair. */
  private Result pPreFortress$EncloserPair$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Enclosing  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPreFortress$EncloserPair$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pPreFortress$EncloserPair$$Choice2(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          if (PrecedenceMap.ONLY.matchedBrackets(a1.getText(), a2.getText()))
          yyValue = new Enclosing(createSpan(yyStart,yyCount), a1, a2);
          else
          yyValue = error(a2, "Mismatched Enclosers.");

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.EncloserPair$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPreFortress$EncloserPair$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreFortress.EncloserPair$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPreFortress$EncloserPair$$Choice2(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.AliasedSimpleNameList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedSimpleNameList(final int yyStart) 
    throws IOException {

    Result                  yyResult;
    int                     yyRepetition1;
    Pair<AliasedSimpleName> yyRepValue1;
    List<AliasedSimpleName> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAliasedSimpleName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AliasedSimpleName a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pAliasedSimpleName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                AliasedSimpleName v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = 
                  new Pair<AliasedSimpleName>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<AliasedSimpleName> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.AliasedAPINames.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedAPINames(final int yyStart) throws IOException {
    Result               yyResult;
    List<AliasedAPIName> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAliasedAPIName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AliasedAPIName a1 = yyResult.semanticValue();

      yyValue = FortressUtil.mkList(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAliasedAPINameList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosecurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.AliasedAPIName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedAPIName(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAliasedAPIName) 
      yyColumn.chunk1.fAliasedAPIName = pAliasedAPIName$1(yyStart);
    return yyColumn.chunk1.fAliasedAPIName;
  }

  /** Actually parse com.sun.fortress.parser.preparser.PreFortress.AliasedAPIName. */
  private Result pAliasedAPIName$1(final int yyStart) throws IOException {
    Result         yyResult;
    int            yyOption1;
    Id             yyOpValue1;
    AliasedAPIName yyValue;
    ParseError     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAPIName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      APIName a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pas(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        Id a2 = yyOpValue1;

        if (a2 == null)
        yyValue = new AliasedAPIName(createSpan(yyStart,yyCount), a1,
        Option.<Id>none());
        else
        yyValue = new AliasedAPIName(createSpan(yyStart,yyCount), a1,
        Option.some(a2));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.AliasedAPINameList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedAPINameList(final int yyStart) throws IOException {
    Result               yyResult;
    int                  yyRepetition1;
    Pair<AliasedAPIName> yyRepValue1;
    List<AliasedAPIName> yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAliasedAPIName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      AliasedAPIName a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pAliasedAPIName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                AliasedAPIName v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<AliasedAPIName>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<AliasedAPIName> a2s = yyRepValue1.reverse();

        yyValue = FortressUtil.mkList(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Whitespace.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhitespace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpace(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\t' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = error(new VoidLiteralExpr(createSpan(yyStart,yyCount)),
      "Tabulation is not allowed in Fortress programs except in comments.");

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyResult = pNewline(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("whitespace expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpace(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSpace) 
      yyColumn.chunk1.fSpace = pSpace$1(yyStart);
    return yyColumn.chunk1.fSpace;
  }

  /** Actually parse Spacing.Space. */
  private Result pSpace$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (' ' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = " ";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\f' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "\f";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\t' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = error(new VoidLiteralExpr(createSpan(yyStart,yyCount)),
      "Tabulation is not allowed in Fortress programs except in comments.");

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyResult = pNoNewlineComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Newline.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNewline(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fNewline) 
      yyColumn.chunk1.fNewline = pNewline$1(yyStart);
    return yyColumn.chunk1.fNewline;
  }

  /** Actually parse Spacing.Newline. */
  private Result pNewline$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('\n' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "\r\n";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "\r";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\n' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "\n";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyResult = pNewlineComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("newline expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Comment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pComment(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fComment) 
      yyColumn.chunk1.fComment = pComment$1(yyStart);
    return yyColumn.chunk1.fComment;
  }

  /** Actually parse Spacing.Comment. */
  private Result pComment$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;
        String a1 = "(*";

        yyResult = pCommentContents(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a2 = yyResult.semanticValue();

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if ('*' == yyC) {
            yyIndex = yyResult.index + 1;

            yyC = character(yyIndex);
            if (')' == yyC) {
              yyIndex = yyIndex + 1;
              String a3 = "*)";

              yyValue = a1 + a2 + a3;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"*)\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"*)\" expected", yyBase);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.CommentContents.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommentContents(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    String       yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pCommentContent(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for a1s.
      Pair<String> a1s = yyRepValue1.reverse();

      yyValue = "";
      for (Object s : a1s.list()) {
        yyValue += s;
      }

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for a1s.
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.CommentContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommentContent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if (')' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = ""+c;

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("comment content expected", yyStart);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (c != '*') {

        yyValue = ""+c;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("comment content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.NewlineComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNewlineComment(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.NoNewlineComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoNewlineComment(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (!(yyValue.contains("\r\n") || yyValue.contains("\r")
          || yyValue.contains("\n"))) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("no newline comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.w.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pw(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pWhitespace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.s.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ps(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pSpace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.br.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbr(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pNewline(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if (';' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyResult = pw(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\";\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pid(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fid) yyColumn.chunk1.fid = pid$1(yyStart);
    return yyColumn.chunk1.fid;
  }

  /** Actually parse Identifier.id. */
  private Result pid$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pidstart(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String s1 = yyResult.semanticValue();

      yyResult = pid$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> s2 = yyResult.semanticValue();

        String s = s1;
        for (String ss : s2.list()) {
          s += ss;
        }
        if (!FORTRESS_KEYWORDS.contains(s))
        yyValue = difference(yyStart, yyResult.index);
        else {        // Error production
          return yyError.select(s + " is a keyword!", yyError.index + 10);
        }

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.id$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pid$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fid$$Star1) 
      yyColumn.chunk2.fid$$Star1 = pid$$Star1$1(yyStart);
    return yyColumn.chunk2.fid$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.preparser.PreFortress.id$$Star1. */
  private Result pid$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pidrest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pid$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> v$2 = yyResult.semanticValue();

        yyValue = new Pair<String>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.idstart.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidstart(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z')) ||
          ('\u00aa' == yyC) ||
          ('\u00b5' == yyC) ||
          ('\u00ba' == yyC) ||
          (('\u00c0' <= yyC) && (yyC <= '\u00d6')) ||
          (('\u00d8' <= yyC) && (yyC <= '\u00f6')) ||
          (('\u00f8' <= yyC) && (yyC <= '\u02c1')) ||
          (('\u02c6' <= yyC) && (yyC <= '\u02d1')) ||
          (('\u02e0' <= yyC) && (yyC <= '\u02e4')) ||
          ('\u02ee' == yyC) ||
          (('\u037a' <= yyC) && (yyC <= '\u037d')) ||
          ('\u0386' == yyC) ||
          (('\u0388' <= yyC) && (yyC <= '\u038a')) ||
          ('\u038c' == yyC) ||
          (('\u038e' <= yyC) && (yyC <= '\u03a1')) ||
          (('\u03a3' <= yyC) && (yyC <= '\u03ce')) ||
          (('\u03d0' <= yyC) && (yyC <= '\u03f5')) ||
          (('\u03f7' <= yyC) && (yyC <= '\u0481')) ||
          (('\u048a' <= yyC) && (yyC <= '\u0513')) ||
          (('\u0531' <= yyC) && (yyC <= '\u0556')) ||
          ('\u0559' == yyC) ||
          (('\u0561' <= yyC) && (yyC <= '\u0587')) ||
          (('\u05d0' <= yyC) && (yyC <= '\u05ea')) ||
          (('\u05f0' <= yyC) && (yyC <= '\u05f2')) ||
          (('\u0621' <= yyC) && (yyC <= '\u063a')) ||
          (('\u0640' <= yyC) && (yyC <= '\u064a')) ||
          (('\u066e' <= yyC) && (yyC <= '\u066f')) ||
          (('\u0671' <= yyC) && (yyC <= '\u06d3')) ||
          ('\u06d5' == yyC) ||
          (('\u06e5' <= yyC) && (yyC <= '\u06e6')) ||
          (('\u06ee' <= yyC) && (yyC <= '\u06ef')) ||
          (('\u06fa' <= yyC) && (yyC <= '\u06fc')) ||
          ('\u06ff' == yyC) ||
          ('\u0710' == yyC) ||
          (('\u0712' <= yyC) && (yyC <= '\u072f')) ||
          (('\u074d' <= yyC) && (yyC <= '\u076d')) ||
          (('\u0780' <= yyC) && (yyC <= '\u07a5')) ||
          ('\u07b1' == yyC) ||
          (('\u07ca' <= yyC) && (yyC <= '\u07ea')) ||
          (('\u07f4' <= yyC) && (yyC <= '\u07f5')) ||
          ('\u07fa' == yyC) ||
          (('\u0904' <= yyC) && (yyC <= '\u0939')) ||
          ('\u093d' == yyC) ||
          ('\u0950' == yyC) ||
          (('\u0958' <= yyC) && (yyC <= '\u0961')) ||
          (('\u097b' <= yyC) && (yyC <= '\u097f')) ||
          (('\u0985' <= yyC) && (yyC <= '\u098c')) ||
          (('\u098f' <= yyC) && (yyC <= '\u0990')) ||
          (('\u0993' <= yyC) && (yyC <= '\u09a8')) ||
          (('\u09aa' <= yyC) && (yyC <= '\u09b0')) ||
          ('\u09b2' == yyC) ||
          (('\u09b6' <= yyC) && (yyC <= '\u09b9')) ||
          ('\u09bd' == yyC) ||
          ('\u09ce' == yyC) ||
          (('\u09dc' <= yyC) && (yyC <= '\u09dd')) ||
          (('\u09df' <= yyC) && (yyC <= '\u09e1')) ||
          (('\u09f0' <= yyC) && (yyC <= '\u09f1')) ||
          (('\u0a05' <= yyC) && (yyC <= '\u0a0a')) ||
          (('\u0a0f' <= yyC) && (yyC <= '\u0a10')) ||
          (('\u0a13' <= yyC) && (yyC <= '\u0a28')) ||
          (('\u0a2a' <= yyC) && (yyC <= '\u0a30')) ||
          (('\u0a32' <= yyC) && (yyC <= '\u0a33')) ||
          (('\u0a35' <= yyC) && (yyC <= '\u0a36')) ||
          (('\u0a38' <= yyC) && (yyC <= '\u0a39')) ||
          (('\u0a59' <= yyC) && (yyC <= '\u0a5c')) ||
          ('\u0a5e' == yyC) ||
          (('\u0a72' <= yyC) && (yyC <= '\u0a74')) ||
          (('\u0a85' <= yyC) && (yyC <= '\u0a8d')) ||
          (('\u0a8f' <= yyC) && (yyC <= '\u0a91')) ||
          (('\u0a93' <= yyC) && (yyC <= '\u0aa8')) ||
          (('\u0aaa' <= yyC) && (yyC <= '\u0ab0')) ||
          (('\u0ab2' <= yyC) && (yyC <= '\u0ab3')) ||
          (('\u0ab5' <= yyC) && (yyC <= '\u0ab9')) ||
          ('\u0abd' == yyC) ||
          ('\u0ad0' == yyC) ||
          (('\u0ae0' <= yyC) && (yyC <= '\u0ae1')) ||
          (('\u0b05' <= yyC) && (yyC <= '\u0b0c')) ||
          (('\u0b0f' <= yyC) && (yyC <= '\u0b10')) ||
          (('\u0b13' <= yyC) && (yyC <= '\u0b28')) ||
          (('\u0b2a' <= yyC) && (yyC <= '\u0b30')) ||
          (('\u0b32' <= yyC) && (yyC <= '\u0b33')) ||
          (('\u0b35' <= yyC) && (yyC <= '\u0b39')) ||
          ('\u0b3d' == yyC) ||
          (('\u0b5c' <= yyC) && (yyC <= '\u0b5d')) ||
          (('\u0b5f' <= yyC) && (yyC <= '\u0b61')) ||
          ('\u0b71' == yyC) ||
          ('\u0b83' == yyC) ||
          (('\u0b85' <= yyC) && (yyC <= '\u0b8a')) ||
          (('\u0b8e' <= yyC) && (yyC <= '\u0b90')) ||
          (('\u0b92' <= yyC) && (yyC <= '\u0b95')) ||
          (('\u0b99' <= yyC) && (yyC <= '\u0b9a')) ||
          ('\u0b9c' == yyC) ||
          (('\u0b9e' <= yyC) && (yyC <= '\u0b9f')) ||
          (('\u0ba3' <= yyC) && (yyC <= '\u0ba4')) ||
          (('\u0ba8' <= yyC) && (yyC <= '\u0baa')) ||
          (('\u0bae' <= yyC) && (yyC <= '\u0bb9')) ||
          (('\u0c05' <= yyC) && (yyC <= '\u0c0c')) ||
          (('\u0c0e' <= yyC) && (yyC <= '\u0c10')) ||
          (('\u0c12' <= yyC) && (yyC <= '\u0c28')) ||
          (('\u0c2a' <= yyC) && (yyC <= '\u0c33')) ||
          (('\u0c35' <= yyC) && (yyC <= '\u0c39')) ||
          (('\u0c60' <= yyC) && (yyC <= '\u0c61')) ||
          (('\u0c85' <= yyC) && (yyC <= '\u0c8c')) ||
          (('\u0c8e' <= yyC) && (yyC <= '\u0c90')) ||
          (('\u0c92' <= yyC) && (yyC <= '\u0ca8')) ||
          (('\u0caa' <= yyC) && (yyC <= '\u0cb3')) ||
          (('\u0cb5' <= yyC) && (yyC <= '\u0cb9')) ||
          ('\u0cbd' == yyC) ||
          ('\u0cde' == yyC) ||
          (('\u0ce0' <= yyC) && (yyC <= '\u0ce1')) ||
          (('\u0d05' <= yyC) && (yyC <= '\u0d0c')) ||
          (('\u0d0e' <= yyC) && (yyC <= '\u0d10')) ||
          (('\u0d12' <= yyC) && (yyC <= '\u0d28')) ||
          (('\u0d2a' <= yyC) && (yyC <= '\u0d39')) ||
          (('\u0d60' <= yyC) && (yyC <= '\u0d61')) ||
          (('\u0d85' <= yyC) && (yyC <= '\u0d96')) ||
          (('\u0d9a' <= yyC) && (yyC <= '\u0db1')) ||
          (('\u0db3' <= yyC) && (yyC <= '\u0dbb')) ||
          ('\u0dbd' == yyC) ||
          (('\u0dc0' <= yyC) && (yyC <= '\u0dc6')) ||
          (('\u0e01' <= yyC) && (yyC <= '\u0e30')) ||
          (('\u0e32' <= yyC) && (yyC <= '\u0e33')) ||
          (('\u0e40' <= yyC) && (yyC <= '\u0e46')) ||
          (('\u0e81' <= yyC) && (yyC <= '\u0e82')) ||
          ('\u0e84' == yyC) ||
          (('\u0e87' <= yyC) && (yyC <= '\u0e88')) ||
          ('\u0e8a' == yyC) ||
          ('\u0e8d' == yyC) ||
          (('\u0e94' <= yyC) && (yyC <= '\u0e97')) ||
          (('\u0e99' <= yyC) && (yyC <= '\u0e9f')) ||
          (('\u0ea1' <= yyC) && (yyC <= '\u0ea3')) ||
          ('\u0ea5' == yyC) ||
          ('\u0ea7' == yyC) ||
          (('\u0eaa' <= yyC) && (yyC <= '\u0eab')) ||
          (('\u0ead' <= yyC) && (yyC <= '\u0eb0')) ||
          (('\u0eb2' <= yyC) && (yyC <= '\u0eb3')) ||
          ('\u0ebd' == yyC) ||
          (('\u0ec0' <= yyC) && (yyC <= '\u0ec4')) ||
          ('\u0ec6' == yyC) ||
          (('\u0edc' <= yyC) && (yyC <= '\u0edd')) ||
          ('\u0f00' == yyC) ||
          (('\u0f40' <= yyC) && (yyC <= '\u0f47')) ||
          (('\u0f49' <= yyC) && (yyC <= '\u0f6a')) ||
          (('\u0f88' <= yyC) && (yyC <= '\u0f8b')) ||
          (('\u1000' <= yyC) && (yyC <= '\u1021')) ||
          (('\u1023' <= yyC) && (yyC <= '\u1027')) ||
          (('\u1029' <= yyC) && (yyC <= '\u102a')) ||
          (('\u1050' <= yyC) && (yyC <= '\u1055')) ||
          (('\u10a0' <= yyC) && (yyC <= '\u10c5')) ||
          (('\u10d0' <= yyC) && (yyC <= '\u10fa')) ||
          ('\u10fc' == yyC) ||
          (('\u1100' <= yyC) && (yyC <= '\u1159')) ||
          (('\u115f' <= yyC) && (yyC <= '\u11a2')) ||
          (('\u11a8' <= yyC) && (yyC <= '\u11f9')) ||
          (('\u1200' <= yyC) && (yyC <= '\u1248')) ||
          (('\u124a' <= yyC) && (yyC <= '\u124d')) ||
          (('\u1250' <= yyC) && (yyC <= '\u1256')) ||
          ('\u1258' == yyC) ||
          (('\u125a' <= yyC) && (yyC <= '\u125d')) ||
          (('\u1260' <= yyC) && (yyC <= '\u1288')) ||
          (('\u128a' <= yyC) && (yyC <= '\u128d')) ||
          (('\u1290' <= yyC) && (yyC <= '\u12b0')) ||
          (('\u12b2' <= yyC) && (yyC <= '\u12b5')) ||
          (('\u12b8' <= yyC) && (yyC <= '\u12be')) ||
          ('\u12c0' == yyC) ||
          (('\u12c2' <= yyC) && (yyC <= '\u12c5')) ||
          (('\u12c8' <= yyC) && (yyC <= '\u12d6')) ||
          (('\u12d8' <= yyC) && (yyC <= '\u1310')) ||
          (('\u1312' <= yyC) && (yyC <= '\u1315')) ||
          (('\u1318' <= yyC) && (yyC <= '\u135a')) ||
          (('\u1380' <= yyC) && (yyC <= '\u138f')) ||
          (('\u13a0' <= yyC) && (yyC <= '\u13f4')) ||
          (('\u1401' <= yyC) && (yyC <= '\u166c')) ||
          (('\u166f' <= yyC) && (yyC <= '\u1676')) ||
          (('\u1681' <= yyC) && (yyC <= '\u169a')) ||
          (('\u16a0' <= yyC) && (yyC <= '\u16ea')) ||
          (('\u16ee' <= yyC) && (yyC <= '\u16f0')) ||
          (('\u1700' <= yyC) && (yyC <= '\u170c')) ||
          (('\u170e' <= yyC) && (yyC <= '\u1711')) ||
          (('\u1720' <= yyC) && (yyC <= '\u1731')) ||
          (('\u1740' <= yyC) && (yyC <= '\u1751')) ||
          (('\u1760' <= yyC) && (yyC <= '\u176c')) ||
          (('\u176e' <= yyC) && (yyC <= '\u1770')) ||
          (('\u1780' <= yyC) && (yyC <= '\u17b3')) ||
          ('\u17d7' == yyC) ||
          ('\u17dc' == yyC) ||
          (('\u1820' <= yyC) && (yyC <= '\u1877')) ||
          (('\u1880' <= yyC) && (yyC <= '\u18a8')) ||
          (('\u1900' <= yyC) && (yyC <= '\u191c')) ||
          (('\u1950' <= yyC) && (yyC <= '\u196d')) ||
          (('\u1970' <= yyC) && (yyC <= '\u1974')) ||
          (('\u1980' <= yyC) && (yyC <= '\u19a9')) ||
          (('\u19c1' <= yyC) && (yyC <= '\u19c7')) ||
          (('\u1a00' <= yyC) && (yyC <= '\u1a16')) ||
          (('\u1b05' <= yyC) && (yyC <= '\u1b33')) ||
          (('\u1b45' <= yyC) && (yyC <= '\u1b4b')) ||
          (('\u1d00' <= yyC) && (yyC <= '\u1dbf')) ||
          (('\u1e00' <= yyC) && (yyC <= '\u1e9b')) ||
          (('\u1ea0' <= yyC) && (yyC <= '\u1ef9')) ||
          (('\u1f00' <= yyC) && (yyC <= '\u1f15')) ||
          (('\u1f18' <= yyC) && (yyC <= '\u1f1d')) ||
          (('\u1f20' <= yyC) && (yyC <= '\u1f45')) ||
          (('\u1f48' <= yyC) && (yyC <= '\u1f4d')) ||
          (('\u1f50' <= yyC) && (yyC <= '\u1f57')) ||
          ('\u1f59' == yyC) ||
          ('\u1f5b' == yyC) ||
          ('\u1f5d' == yyC) ||
          (('\u1f5f' <= yyC) && (yyC <= '\u1f7d')) ||
          (('\u1f80' <= yyC) && (yyC <= '\u1fb4')) ||
          (('\u1fb6' <= yyC) && (yyC <= '\u1fbc')) ||
          ('\u1fbe' == yyC) ||
          (('\u1fc2' <= yyC) && (yyC <= '\u1fc4')) ||
          (('\u1fc6' <= yyC) && (yyC <= '\u1fcc')) ||
          (('\u1fd0' <= yyC) && (yyC <= '\u1fd3')) ||
          (('\u1fd6' <= yyC) && (yyC <= '\u1fdb')) ||
          (('\u1fe0' <= yyC) && (yyC <= '\u1fec')) ||
          (('\u1ff2' <= yyC) && (yyC <= '\u1ff4')) ||
          (('\u1ff6' <= yyC) && (yyC <= '\u1ffc')) ||
          ('\u2071' == yyC) ||
          ('\u207f' == yyC) ||
          (('\u2090' <= yyC) && (yyC <= '\u2094')) ||
          ('\u2102' == yyC) ||
          ('\u2107' == yyC) ||
          (('\u210a' <= yyC) && (yyC <= '\u2113')) ||
          ('\u2115' == yyC) ||
          (('\u2119' <= yyC) && (yyC <= '\u211d')) ||
          ('\u2124' == yyC) ||
          ('\u2126' == yyC) ||
          ('\u2128' == yyC) ||
          (('\u212a' <= yyC) && (yyC <= '\u212d')) ||
          (('\u212f' <= yyC) && (yyC <= '\u2139')) ||
          (('\u213c' <= yyC) && (yyC <= '\u213f')) ||
          (('\u2145' <= yyC) && (yyC <= '\u2149')) ||
          ('\u214e' == yyC) ||
          (('\u2160' <= yyC) && (yyC <= '\u2184')) ||
          (('\u2c00' <= yyC) && (yyC <= '\u2c2e')) ||
          (('\u2c30' <= yyC) && (yyC <= '\u2c5e')) ||
          (('\u2c60' <= yyC) && (yyC <= '\u2c6c')) ||
          (('\u2c74' <= yyC) && (yyC <= '\u2c77')) ||
          (('\u2c80' <= yyC) && (yyC <= '\u2ce4')) ||
          (('\u2d00' <= yyC) && (yyC <= '\u2d25')) ||
          (('\u2d30' <= yyC) && (yyC <= '\u2d65')) ||
          ('\u2d6f' == yyC) ||
          (('\u2d80' <= yyC) && (yyC <= '\u2d96')) ||
          (('\u2da0' <= yyC) && (yyC <= '\u2da6')) ||
          (('\u2da8' <= yyC) && (yyC <= '\u2dae')) ||
          (('\u2db0' <= yyC) && (yyC <= '\u2db6')) ||
          (('\u2db8' <= yyC) && (yyC <= '\u2dbe')) ||
          (('\u2dc0' <= yyC) && (yyC <= '\u2dc6')) ||
          (('\u2dc8' <= yyC) && (yyC <= '\u2dce')) ||
          (('\u2dd0' <= yyC) && (yyC <= '\u2dd6')) ||
          (('\u2dd8' <= yyC) && (yyC <= '\u2dde')) ||
          (('\u3005' <= yyC) && (yyC <= '\u3007')) ||
          (('\u3021' <= yyC) && (yyC <= '\u3029')) ||
          (('\u3031' <= yyC) && (yyC <= '\u3035')) ||
          (('\u3038' <= yyC) && (yyC <= '\u303c')) ||
          (('\u3041' <= yyC) && (yyC <= '\u3096')) ||
          (('\u309d' <= yyC) && (yyC <= '\u309f')) ||
          (('\u30a1' <= yyC) && (yyC <= '\u30fa')) ||
          (('\u30fc' <= yyC) && (yyC <= '\u30ff')) ||
          (('\u3105' <= yyC) && (yyC <= '\u312c')) ||
          (('\u3131' <= yyC) && (yyC <= '\u318e')) ||
          (('\u31a0' <= yyC) && (yyC <= '\u31b7')) ||
          (('\u31f0' <= yyC) && (yyC <= '\u31ff')) ||
          ('\u3400' == yyC) ||
          ('\u4db5' == yyC) ||
          ('\u4e00' == yyC) ||
          ('\u9fbb' == yyC) ||
          (('\ua000' <= yyC) && (yyC <= '\ua48c')) ||
          (('\ua717' <= yyC) && (yyC <= '\ua71a')) ||
          (('\ua800' <= yyC) && (yyC <= '\ua801')) ||
          (('\ua803' <= yyC) && (yyC <= '\ua805')) ||
          (('\ua807' <= yyC) && (yyC <= '\ua80a')) ||
          (('\ua80c' <= yyC) && (yyC <= '\ua822')) ||
          (('\ua840' <= yyC) && (yyC <= '\ua873')) ||
          ('\uac00' == yyC) ||
          ('\ud7a3' == yyC) ||
          (('\uf900' <= yyC) && (yyC <= '\ufa2d')) ||
          (('\ufa30' <= yyC) && (yyC <= '\ufa6a')) ||
          (('\ufa70' <= yyC) && (yyC <= '\ufad9')) ||
          (('\ufb00' <= yyC) && (yyC <= '\ufb06')) ||
          (('\ufb13' <= yyC) && (yyC <= '\ufb17')) ||
          ('\ufb1d' == yyC) ||
          (('\ufb1f' <= yyC) && (yyC <= '\ufb28')) ||
          (('\ufb2a' <= yyC) && (yyC <= '\ufb36')) ||
          (('\ufb38' <= yyC) && (yyC <= '\ufb3c')) ||
          ('\ufb3e' == yyC) ||
          (('\ufb40' <= yyC) && (yyC <= '\ufb41')) ||
          (('\ufb43' <= yyC) && (yyC <= '\ufb44')) ||
          (('\ufb46' <= yyC) && (yyC <= '\ufbb1')) ||
          (('\ufbd3' <= yyC) && (yyC <= '\ufd3d')) ||
          (('\ufd50' <= yyC) && (yyC <= '\ufd8f')) ||
          (('\ufd92' <= yyC) && (yyC <= '\ufdc7')) ||
          (('\ufdf0' <= yyC) && (yyC <= '\ufdfb')) ||
          (('\ufe70' <= yyC) && (yyC <= '\ufe74')) ||
          (('\ufe76' <= yyC) && (yyC <= '\ufefc')) ||
          (('\uff21' <= yyC) && (yyC <= '\uff3a')) ||
          (('\uff41' <= yyC) && (yyC <= '\uff5a')) ||
          (('\uff66' <= yyC) && (yyC <= '\uffbe')) ||
          (('\uffc2' <= yyC) && (yyC <= '\uffc7')) ||
          (('\uffca' <= yyC) && (yyC <= '\uffcf')) ||
          (('\uffd2' <= yyC) && (yyC <= '\uffd7')) ||
          (('\uffda' <= yyC) && (yyC <= '\uffdc'))) {

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud800':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc0b')) ||
                (('\udc0d' <= yyC) && (yyC <= '\udc26')) ||
                (('\udc28' <= yyC) && (yyC <= '\udc3a')) ||
                (('\udc3c' <= yyC) && (yyC <= '\udc3d')) ||
                (('\udc3f' <= yyC) && (yyC <= '\udc4d')) ||
                (('\udc50' <= yyC) && (yyC <= '\udc5d')) ||
                (('\udc80' <= yyC) && (yyC <= '\udcfa')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd74')) ||
                (('\udf00' <= yyC) && (yyC <= '\udf1e')) ||
                (('\udf30' <= yyC) && (yyC <= '\udf4a')) ||
                (('\udf80' <= yyC) && (yyC <= '\udf9d')) ||
                (('\udfa0' <= yyC) && (yyC <= '\udfc3')) ||
                (('\udfc8' <= yyC) && (yyC <= '\udfcf')) ||
                (('\udfd1' <= yyC) && (yyC <= '\udfd5'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc9d')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc05')) ||
                ('\udc08' == yyC) ||
                (('\udc0a' <= yyC) && (yyC <= '\udc35')) ||
                (('\udc37' <= yyC) && (yyC <= '\udc38')) ||
                ('\udc3c' == yyC) ||
                ('\udc3f' == yyC) ||
                (('\udd00' <= yyC) && (yyC <= '\udd15')) ||
                ('\ude00' == yyC) ||
                (('\ude10' <= yyC) && (yyC <= '\ude13')) ||
                (('\ude15' <= yyC) && (yyC <= '\ude17')) ||
                (('\ude19' <= yyC) && (yyC <= '\ude33'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud808':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udf6e')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud809':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc62')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc54')) ||
                (('\udc56' <= yyC) && (yyC <= '\udc9c')) ||
                (('\udc9e' <= yyC) && (yyC <= '\udc9f')) ||
                ('\udca2' == yyC) ||
                (('\udca5' <= yyC) && (yyC <= '\udca6')) ||
                (('\udca9' <= yyC) && (yyC <= '\udcac')) ||
                (('\udcae' <= yyC) && (yyC <= '\udcb9')) ||
                ('\udcbb' == yyC) ||
                (('\udcbd' <= yyC) && (yyC <= '\udcc3')) ||
                (('\udcc5' <= yyC) && (yyC <= '\udd05')) ||
                (('\udd07' <= yyC) && (yyC <= '\udd0a')) ||
                (('\udd0d' <= yyC) && (yyC <= '\udd14')) ||
                (('\udd16' <= yyC) && (yyC <= '\udd1c')) ||
                (('\udd1e' <= yyC) && (yyC <= '\udd39')) ||
                (('\udd3b' <= yyC) && (yyC <= '\udd3e')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd44')) ||
                ('\udd46' == yyC) ||
                (('\udd4a' <= yyC) && (yyC <= '\udd50')) ||
                (('\udd52' <= yyC) && (yyC <= '\udea5')) ||
                (('\udea8' <= yyC) && (yyC <= '\udec0')) ||
                (('\udec2' <= yyC) && (yyC <= '\udeda')) ||
                (('\udedc' <= yyC) && (yyC <= '\udefa')) ||
                (('\udefc' <= yyC) && (yyC <= '\udf14')) ||
                (('\udf16' <= yyC) && (yyC <= '\udf34')) ||
                (('\udf36' <= yyC) && (yyC <= '\udf4e')) ||
                (('\udf50' <= yyC) && (yyC <= '\udf6e')) ||
                (('\udf70' <= yyC) && (yyC <= '\udf88')) ||
                (('\udf8a' <= yyC) && (yyC <= '\udfa8')) ||
                (('\udfaa' <= yyC) && (yyC <= '\udfc2')) ||
                (('\udfc4' <= yyC) && (yyC <= '\udfcb'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud840':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\udc00' == yyC) {

              yyValue = "\ud840\udc00";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud869':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\uded6' == yyC) {

              yyValue = "\ud869\uded6";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud87e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\ude1d')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '_':
        {
          yyValue = "_";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("idstart expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.idrest.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidrest(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fidrest) 
      yyColumn.chunk2.fidrest = pidrest$1(yyStart);
    return yyColumn.chunk2.fidrest;
  }

  /** Actually parse Identifier.idrest. */
  private Result pidrest$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z')) ||
          ('\u00aa' == yyC) ||
          ('\u00b5' == yyC) ||
          ('\u00ba' == yyC) ||
          (('\u00c0' <= yyC) && (yyC <= '\u00d6')) ||
          (('\u00d8' <= yyC) && (yyC <= '\u00f6')) ||
          (('\u00f8' <= yyC) && (yyC <= '\u02c1')) ||
          (('\u02c6' <= yyC) && (yyC <= '\u02d1')) ||
          (('\u02e0' <= yyC) && (yyC <= '\u02e4')) ||
          ('\u02ee' == yyC) ||
          (('\u037a' <= yyC) && (yyC <= '\u037d')) ||
          ('\u0386' == yyC) ||
          (('\u0388' <= yyC) && (yyC <= '\u038a')) ||
          ('\u038c' == yyC) ||
          (('\u038e' <= yyC) && (yyC <= '\u03a1')) ||
          (('\u03a3' <= yyC) && (yyC <= '\u03ce')) ||
          (('\u03d0' <= yyC) && (yyC <= '\u03f5')) ||
          (('\u03f7' <= yyC) && (yyC <= '\u0481')) ||
          (('\u048a' <= yyC) && (yyC <= '\u0513')) ||
          (('\u0531' <= yyC) && (yyC <= '\u0556')) ||
          ('\u0559' == yyC) ||
          (('\u0561' <= yyC) && (yyC <= '\u0587')) ||
          (('\u05d0' <= yyC) && (yyC <= '\u05ea')) ||
          (('\u05f0' <= yyC) && (yyC <= '\u05f2')) ||
          (('\u0621' <= yyC) && (yyC <= '\u063a')) ||
          (('\u0640' <= yyC) && (yyC <= '\u064a')) ||
          (('\u066e' <= yyC) && (yyC <= '\u066f')) ||
          (('\u0671' <= yyC) && (yyC <= '\u06d3')) ||
          ('\u06d5' == yyC) ||
          (('\u06e5' <= yyC) && (yyC <= '\u06e6')) ||
          (('\u06ee' <= yyC) && (yyC <= '\u06ef')) ||
          (('\u06fa' <= yyC) && (yyC <= '\u06fc')) ||
          ('\u06ff' == yyC) ||
          ('\u0710' == yyC) ||
          (('\u0712' <= yyC) && (yyC <= '\u072f')) ||
          (('\u074d' <= yyC) && (yyC <= '\u076d')) ||
          (('\u0780' <= yyC) && (yyC <= '\u07a5')) ||
          ('\u07b1' == yyC) ||
          (('\u07ca' <= yyC) && (yyC <= '\u07ea')) ||
          (('\u07f4' <= yyC) && (yyC <= '\u07f5')) ||
          ('\u07fa' == yyC) ||
          (('\u0904' <= yyC) && (yyC <= '\u0939')) ||
          ('\u093d' == yyC) ||
          ('\u0950' == yyC) ||
          (('\u0958' <= yyC) && (yyC <= '\u0961')) ||
          (('\u097b' <= yyC) && (yyC <= '\u097f')) ||
          (('\u0985' <= yyC) && (yyC <= '\u098c')) ||
          (('\u098f' <= yyC) && (yyC <= '\u0990')) ||
          (('\u0993' <= yyC) && (yyC <= '\u09a8')) ||
          (('\u09aa' <= yyC) && (yyC <= '\u09b0')) ||
          ('\u09b2' == yyC) ||
          (('\u09b6' <= yyC) && (yyC <= '\u09b9')) ||
          ('\u09bd' == yyC) ||
          ('\u09ce' == yyC) ||
          (('\u09dc' <= yyC) && (yyC <= '\u09dd')) ||
          (('\u09df' <= yyC) && (yyC <= '\u09e1')) ||
          (('\u09f0' <= yyC) && (yyC <= '\u09f1')) ||
          (('\u0a05' <= yyC) && (yyC <= '\u0a0a')) ||
          (('\u0a0f' <= yyC) && (yyC <= '\u0a10')) ||
          (('\u0a13' <= yyC) && (yyC <= '\u0a28')) ||
          (('\u0a2a' <= yyC) && (yyC <= '\u0a30')) ||
          (('\u0a32' <= yyC) && (yyC <= '\u0a33')) ||
          (('\u0a35' <= yyC) && (yyC <= '\u0a36')) ||
          (('\u0a38' <= yyC) && (yyC <= '\u0a39')) ||
          (('\u0a59' <= yyC) && (yyC <= '\u0a5c')) ||
          ('\u0a5e' == yyC) ||
          (('\u0a72' <= yyC) && (yyC <= '\u0a74')) ||
          (('\u0a85' <= yyC) && (yyC <= '\u0a8d')) ||
          (('\u0a8f' <= yyC) && (yyC <= '\u0a91')) ||
          (('\u0a93' <= yyC) && (yyC <= '\u0aa8')) ||
          (('\u0aaa' <= yyC) && (yyC <= '\u0ab0')) ||
          (('\u0ab2' <= yyC) && (yyC <= '\u0ab3')) ||
          (('\u0ab5' <= yyC) && (yyC <= '\u0ab9')) ||
          ('\u0abd' == yyC) ||
          ('\u0ad0' == yyC) ||
          (('\u0ae0' <= yyC) && (yyC <= '\u0ae1')) ||
          (('\u0b05' <= yyC) && (yyC <= '\u0b0c')) ||
          (('\u0b0f' <= yyC) && (yyC <= '\u0b10')) ||
          (('\u0b13' <= yyC) && (yyC <= '\u0b28')) ||
          (('\u0b2a' <= yyC) && (yyC <= '\u0b30')) ||
          (('\u0b32' <= yyC) && (yyC <= '\u0b33')) ||
          (('\u0b35' <= yyC) && (yyC <= '\u0b39')) ||
          ('\u0b3d' == yyC) ||
          (('\u0b5c' <= yyC) && (yyC <= '\u0b5d')) ||
          (('\u0b5f' <= yyC) && (yyC <= '\u0b61')) ||
          ('\u0b71' == yyC) ||
          ('\u0b83' == yyC) ||
          (('\u0b85' <= yyC) && (yyC <= '\u0b8a')) ||
          (('\u0b8e' <= yyC) && (yyC <= '\u0b90')) ||
          (('\u0b92' <= yyC) && (yyC <= '\u0b95')) ||
          (('\u0b99' <= yyC) && (yyC <= '\u0b9a')) ||
          ('\u0b9c' == yyC) ||
          (('\u0b9e' <= yyC) && (yyC <= '\u0b9f')) ||
          (('\u0ba3' <= yyC) && (yyC <= '\u0ba4')) ||
          (('\u0ba8' <= yyC) && (yyC <= '\u0baa')) ||
          (('\u0bae' <= yyC) && (yyC <= '\u0bb9')) ||
          (('\u0c05' <= yyC) && (yyC <= '\u0c0c')) ||
          (('\u0c0e' <= yyC) && (yyC <= '\u0c10')) ||
          (('\u0c12' <= yyC) && (yyC <= '\u0c28')) ||
          (('\u0c2a' <= yyC) && (yyC <= '\u0c33')) ||
          (('\u0c35' <= yyC) && (yyC <= '\u0c39')) ||
          (('\u0c60' <= yyC) && (yyC <= '\u0c61')) ||
          (('\u0c85' <= yyC) && (yyC <= '\u0c8c')) ||
          (('\u0c8e' <= yyC) && (yyC <= '\u0c90')) ||
          (('\u0c92' <= yyC) && (yyC <= '\u0ca8')) ||
          (('\u0caa' <= yyC) && (yyC <= '\u0cb3')) ||
          (('\u0cb5' <= yyC) && (yyC <= '\u0cb9')) ||
          ('\u0cbd' == yyC) ||
          ('\u0cde' == yyC) ||
          (('\u0ce0' <= yyC) && (yyC <= '\u0ce1')) ||
          (('\u0d05' <= yyC) && (yyC <= '\u0d0c')) ||
          (('\u0d0e' <= yyC) && (yyC <= '\u0d10')) ||
          (('\u0d12' <= yyC) && (yyC <= '\u0d28')) ||
          (('\u0d2a' <= yyC) && (yyC <= '\u0d39')) ||
          (('\u0d60' <= yyC) && (yyC <= '\u0d61')) ||
          (('\u0d85' <= yyC) && (yyC <= '\u0d96')) ||
          (('\u0d9a' <= yyC) && (yyC <= '\u0db1')) ||
          (('\u0db3' <= yyC) && (yyC <= '\u0dbb')) ||
          ('\u0dbd' == yyC) ||
          (('\u0dc0' <= yyC) && (yyC <= '\u0dc6')) ||
          (('\u0e01' <= yyC) && (yyC <= '\u0e30')) ||
          (('\u0e32' <= yyC) && (yyC <= '\u0e33')) ||
          (('\u0e40' <= yyC) && (yyC <= '\u0e46')) ||
          (('\u0e81' <= yyC) && (yyC <= '\u0e82')) ||
          ('\u0e84' == yyC) ||
          (('\u0e87' <= yyC) && (yyC <= '\u0e88')) ||
          ('\u0e8a' == yyC) ||
          ('\u0e8d' == yyC) ||
          (('\u0e94' <= yyC) && (yyC <= '\u0e97')) ||
          (('\u0e99' <= yyC) && (yyC <= '\u0e9f')) ||
          (('\u0ea1' <= yyC) && (yyC <= '\u0ea3')) ||
          ('\u0ea5' == yyC) ||
          ('\u0ea7' == yyC) ||
          (('\u0eaa' <= yyC) && (yyC <= '\u0eab')) ||
          (('\u0ead' <= yyC) && (yyC <= '\u0eb0')) ||
          (('\u0eb2' <= yyC) && (yyC <= '\u0eb3')) ||
          ('\u0ebd' == yyC) ||
          (('\u0ec0' <= yyC) && (yyC <= '\u0ec4')) ||
          ('\u0ec6' == yyC) ||
          (('\u0edc' <= yyC) && (yyC <= '\u0edd')) ||
          ('\u0f00' == yyC) ||
          (('\u0f40' <= yyC) && (yyC <= '\u0f47')) ||
          (('\u0f49' <= yyC) && (yyC <= '\u0f6a')) ||
          (('\u0f88' <= yyC) && (yyC <= '\u0f8b')) ||
          (('\u1000' <= yyC) && (yyC <= '\u1021')) ||
          (('\u1023' <= yyC) && (yyC <= '\u1027')) ||
          (('\u1029' <= yyC) && (yyC <= '\u102a')) ||
          (('\u1050' <= yyC) && (yyC <= '\u1055')) ||
          (('\u10a0' <= yyC) && (yyC <= '\u10c5')) ||
          (('\u10d0' <= yyC) && (yyC <= '\u10fa')) ||
          ('\u10fc' == yyC) ||
          (('\u1100' <= yyC) && (yyC <= '\u1159')) ||
          (('\u115f' <= yyC) && (yyC <= '\u11a2')) ||
          (('\u11a8' <= yyC) && (yyC <= '\u11f9')) ||
          (('\u1200' <= yyC) && (yyC <= '\u1248')) ||
          (('\u124a' <= yyC) && (yyC <= '\u124d')) ||
          (('\u1250' <= yyC) && (yyC <= '\u1256')) ||
          ('\u1258' == yyC) ||
          (('\u125a' <= yyC) && (yyC <= '\u125d')) ||
          (('\u1260' <= yyC) && (yyC <= '\u1288')) ||
          (('\u128a' <= yyC) && (yyC <= '\u128d')) ||
          (('\u1290' <= yyC) && (yyC <= '\u12b0')) ||
          (('\u12b2' <= yyC) && (yyC <= '\u12b5')) ||
          (('\u12b8' <= yyC) && (yyC <= '\u12be')) ||
          ('\u12c0' == yyC) ||
          (('\u12c2' <= yyC) && (yyC <= '\u12c5')) ||
          (('\u12c8' <= yyC) && (yyC <= '\u12d6')) ||
          (('\u12d8' <= yyC) && (yyC <= '\u1310')) ||
          (('\u1312' <= yyC) && (yyC <= '\u1315')) ||
          (('\u1318' <= yyC) && (yyC <= '\u135a')) ||
          (('\u1380' <= yyC) && (yyC <= '\u138f')) ||
          (('\u13a0' <= yyC) && (yyC <= '\u13f4')) ||
          (('\u1401' <= yyC) && (yyC <= '\u166c')) ||
          (('\u166f' <= yyC) && (yyC <= '\u1676')) ||
          (('\u1681' <= yyC) && (yyC <= '\u169a')) ||
          (('\u16a0' <= yyC) && (yyC <= '\u16ea')) ||
          (('\u16ee' <= yyC) && (yyC <= '\u16f0')) ||
          (('\u1700' <= yyC) && (yyC <= '\u170c')) ||
          (('\u170e' <= yyC) && (yyC <= '\u1711')) ||
          (('\u1720' <= yyC) && (yyC <= '\u1731')) ||
          (('\u1740' <= yyC) && (yyC <= '\u1751')) ||
          (('\u1760' <= yyC) && (yyC <= '\u176c')) ||
          (('\u176e' <= yyC) && (yyC <= '\u1770')) ||
          (('\u1780' <= yyC) && (yyC <= '\u17b3')) ||
          ('\u17d7' == yyC) ||
          ('\u17dc' == yyC) ||
          (('\u1820' <= yyC) && (yyC <= '\u1877')) ||
          (('\u1880' <= yyC) && (yyC <= '\u18a8')) ||
          (('\u1900' <= yyC) && (yyC <= '\u191c')) ||
          (('\u1950' <= yyC) && (yyC <= '\u196d')) ||
          (('\u1970' <= yyC) && (yyC <= '\u1974')) ||
          (('\u1980' <= yyC) && (yyC <= '\u19a9')) ||
          (('\u19c1' <= yyC) && (yyC <= '\u19c7')) ||
          (('\u1a00' <= yyC) && (yyC <= '\u1a16')) ||
          (('\u1b05' <= yyC) && (yyC <= '\u1b33')) ||
          (('\u1b45' <= yyC) && (yyC <= '\u1b4b')) ||
          (('\u1d00' <= yyC) && (yyC <= '\u1dbf')) ||
          (('\u1e00' <= yyC) && (yyC <= '\u1e9b')) ||
          (('\u1ea0' <= yyC) && (yyC <= '\u1ef9')) ||
          (('\u1f00' <= yyC) && (yyC <= '\u1f15')) ||
          (('\u1f18' <= yyC) && (yyC <= '\u1f1d')) ||
          (('\u1f20' <= yyC) && (yyC <= '\u1f45')) ||
          (('\u1f48' <= yyC) && (yyC <= '\u1f4d')) ||
          (('\u1f50' <= yyC) && (yyC <= '\u1f57')) ||
          ('\u1f59' == yyC) ||
          ('\u1f5b' == yyC) ||
          ('\u1f5d' == yyC) ||
          (('\u1f5f' <= yyC) && (yyC <= '\u1f7d')) ||
          (('\u1f80' <= yyC) && (yyC <= '\u1fb4')) ||
          (('\u1fb6' <= yyC) && (yyC <= '\u1fbc')) ||
          ('\u1fbe' == yyC) ||
          (('\u1fc2' <= yyC) && (yyC <= '\u1fc4')) ||
          (('\u1fc6' <= yyC) && (yyC <= '\u1fcc')) ||
          (('\u1fd0' <= yyC) && (yyC <= '\u1fd3')) ||
          (('\u1fd6' <= yyC) && (yyC <= '\u1fdb')) ||
          (('\u1fe0' <= yyC) && (yyC <= '\u1fec')) ||
          (('\u1ff2' <= yyC) && (yyC <= '\u1ff4')) ||
          (('\u1ff6' <= yyC) && (yyC <= '\u1ffc')) ||
          ('\u2071' == yyC) ||
          ('\u207f' == yyC) ||
          (('\u2090' <= yyC) && (yyC <= '\u2094')) ||
          ('\u2102' == yyC) ||
          ('\u2107' == yyC) ||
          (('\u210a' <= yyC) && (yyC <= '\u2113')) ||
          ('\u2115' == yyC) ||
          (('\u2119' <= yyC) && (yyC <= '\u211d')) ||
          ('\u2124' == yyC) ||
          ('\u2126' == yyC) ||
          ('\u2128' == yyC) ||
          (('\u212a' <= yyC) && (yyC <= '\u212d')) ||
          (('\u212f' <= yyC) && (yyC <= '\u2139')) ||
          (('\u213c' <= yyC) && (yyC <= '\u213f')) ||
          (('\u2145' <= yyC) && (yyC <= '\u2149')) ||
          ('\u214e' == yyC) ||
          (('\u2160' <= yyC) && (yyC <= '\u2184')) ||
          (('\u2c00' <= yyC) && (yyC <= '\u2c2e')) ||
          (('\u2c30' <= yyC) && (yyC <= '\u2c5e')) ||
          (('\u2c60' <= yyC) && (yyC <= '\u2c6c')) ||
          (('\u2c74' <= yyC) && (yyC <= '\u2c77')) ||
          (('\u2c80' <= yyC) && (yyC <= '\u2ce4')) ||
          (('\u2d00' <= yyC) && (yyC <= '\u2d25')) ||
          (('\u2d30' <= yyC) && (yyC <= '\u2d65')) ||
          ('\u2d6f' == yyC) ||
          (('\u2d80' <= yyC) && (yyC <= '\u2d96')) ||
          (('\u2da0' <= yyC) && (yyC <= '\u2da6')) ||
          (('\u2da8' <= yyC) && (yyC <= '\u2dae')) ||
          (('\u2db0' <= yyC) && (yyC <= '\u2db6')) ||
          (('\u2db8' <= yyC) && (yyC <= '\u2dbe')) ||
          (('\u2dc0' <= yyC) && (yyC <= '\u2dc6')) ||
          (('\u2dc8' <= yyC) && (yyC <= '\u2dce')) ||
          (('\u2dd0' <= yyC) && (yyC <= '\u2dd6')) ||
          (('\u2dd8' <= yyC) && (yyC <= '\u2dde')) ||
          (('\u3005' <= yyC) && (yyC <= '\u3007')) ||
          (('\u3021' <= yyC) && (yyC <= '\u3029')) ||
          (('\u3031' <= yyC) && (yyC <= '\u3035')) ||
          (('\u3038' <= yyC) && (yyC <= '\u303c')) ||
          (('\u3041' <= yyC) && (yyC <= '\u3096')) ||
          (('\u309d' <= yyC) && (yyC <= '\u309f')) ||
          (('\u30a1' <= yyC) && (yyC <= '\u30fa')) ||
          (('\u30fc' <= yyC) && (yyC <= '\u30ff')) ||
          (('\u3105' <= yyC) && (yyC <= '\u312c')) ||
          (('\u3131' <= yyC) && (yyC <= '\u318e')) ||
          (('\u31a0' <= yyC) && (yyC <= '\u31b7')) ||
          (('\u31f0' <= yyC) && (yyC <= '\u31ff')) ||
          ('\u3400' == yyC) ||
          ('\u4db5' == yyC) ||
          ('\u4e00' == yyC) ||
          ('\u9fbb' == yyC) ||
          (('\ua000' <= yyC) && (yyC <= '\ua48c')) ||
          (('\ua717' <= yyC) && (yyC <= '\ua71a')) ||
          (('\ua800' <= yyC) && (yyC <= '\ua801')) ||
          (('\ua803' <= yyC) && (yyC <= '\ua805')) ||
          (('\ua807' <= yyC) && (yyC <= '\ua80a')) ||
          (('\ua80c' <= yyC) && (yyC <= '\ua822')) ||
          (('\ua840' <= yyC) && (yyC <= '\ua873')) ||
          ('\uac00' == yyC) ||
          ('\ud7a3' == yyC) ||
          (('\uf900' <= yyC) && (yyC <= '\ufa2d')) ||
          (('\ufa30' <= yyC) && (yyC <= '\ufa6a')) ||
          (('\ufa70' <= yyC) && (yyC <= '\ufad9')) ||
          (('\ufb00' <= yyC) && (yyC <= '\ufb06')) ||
          (('\ufb13' <= yyC) && (yyC <= '\ufb17')) ||
          ('\ufb1d' == yyC) ||
          (('\ufb1f' <= yyC) && (yyC <= '\ufb28')) ||
          (('\ufb2a' <= yyC) && (yyC <= '\ufb36')) ||
          (('\ufb38' <= yyC) && (yyC <= '\ufb3c')) ||
          ('\ufb3e' == yyC) ||
          (('\ufb40' <= yyC) && (yyC <= '\ufb41')) ||
          (('\ufb43' <= yyC) && (yyC <= '\ufb44')) ||
          (('\ufb46' <= yyC) && (yyC <= '\ufbb1')) ||
          (('\ufbd3' <= yyC) && (yyC <= '\ufd3d')) ||
          (('\ufd50' <= yyC) && (yyC <= '\ufd8f')) ||
          (('\ufd92' <= yyC) && (yyC <= '\ufdc7')) ||
          (('\ufdf0' <= yyC) && (yyC <= '\ufdfb')) ||
          (('\ufe70' <= yyC) && (yyC <= '\ufe74')) ||
          (('\ufe76' <= yyC) && (yyC <= '\ufefc')) ||
          (('\uff21' <= yyC) && (yyC <= '\uff3a')) ||
          (('\uff41' <= yyC) && (yyC <= '\uff5a')) ||
          (('\uff66' <= yyC) && (yyC <= '\uffbe')) ||
          (('\uffc2' <= yyC) && (yyC <= '\uffc7')) ||
          (('\uffca' <= yyC) && (yyC <= '\uffcf')) ||
          (('\uffd2' <= yyC) && (yyC <= '\uffd7')) ||
          (('\uffda' <= yyC) && (yyC <= '\uffdc'))) {

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud800':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc0b')) ||
                (('\udc0d' <= yyC) && (yyC <= '\udc26')) ||
                (('\udc28' <= yyC) && (yyC <= '\udc3a')) ||
                (('\udc3c' <= yyC) && (yyC <= '\udc3d')) ||
                (('\udc3f' <= yyC) && (yyC <= '\udc4d')) ||
                (('\udc50' <= yyC) && (yyC <= '\udc5d')) ||
                (('\udc80' <= yyC) && (yyC <= '\udcfa')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd74')) ||
                (('\udf00' <= yyC) && (yyC <= '\udf1e')) ||
                (('\udf30' <= yyC) && (yyC <= '\udf4a')) ||
                (('\udf80' <= yyC) && (yyC <= '\udf9d')) ||
                (('\udfa0' <= yyC) && (yyC <= '\udfc3')) ||
                (('\udfc8' <= yyC) && (yyC <= '\udfcf')) ||
                (('\udfd1' <= yyC) && (yyC <= '\udfd5'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc9d')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc05')) ||
                ('\udc08' == yyC) ||
                (('\udc0a' <= yyC) && (yyC <= '\udc35')) ||
                (('\udc37' <= yyC) && (yyC <= '\udc38')) ||
                ('\udc3c' == yyC) ||
                ('\udc3f' == yyC) ||
                (('\udd00' <= yyC) && (yyC <= '\udd15')) ||
                ('\ude00' == yyC) ||
                (('\ude10' <= yyC) && (yyC <= '\ude13')) ||
                (('\ude15' <= yyC) && (yyC <= '\ude17')) ||
                (('\ude19' <= yyC) && (yyC <= '\ude33'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud808':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udf6e')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud809':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc62')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc54')) ||
                (('\udc56' <= yyC) && (yyC <= '\udc9c')) ||
                (('\udc9e' <= yyC) && (yyC <= '\udc9f')) ||
                ('\udca2' == yyC) ||
                (('\udca5' <= yyC) && (yyC <= '\udca6')) ||
                (('\udca9' <= yyC) && (yyC <= '\udcac')) ||
                (('\udcae' <= yyC) && (yyC <= '\udcb9')) ||
                ('\udcbb' == yyC) ||
                (('\udcbd' <= yyC) && (yyC <= '\udcc3')) ||
                (('\udcc5' <= yyC) && (yyC <= '\udd05')) ||
                (('\udd07' <= yyC) && (yyC <= '\udd0a')) ||
                (('\udd0d' <= yyC) && (yyC <= '\udd14')) ||
                (('\udd16' <= yyC) && (yyC <= '\udd1c')) ||
                (('\udd1e' <= yyC) && (yyC <= '\udd39')) ||
                (('\udd3b' <= yyC) && (yyC <= '\udd3e')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd44')) ||
                ('\udd46' == yyC) ||
                (('\udd4a' <= yyC) && (yyC <= '\udd50')) ||
                (('\udd52' <= yyC) && (yyC <= '\udea5')) ||
                (('\udea8' <= yyC) && (yyC <= '\udec0')) ||
                (('\udec2' <= yyC) && (yyC <= '\udeda')) ||
                (('\udedc' <= yyC) && (yyC <= '\udefa')) ||
                (('\udefc' <= yyC) && (yyC <= '\udf14')) ||
                (('\udf16' <= yyC) && (yyC <= '\udf34')) ||
                (('\udf36' <= yyC) && (yyC <= '\udf4e')) ||
                (('\udf50' <= yyC) && (yyC <= '\udf6e')) ||
                (('\udf70' <= yyC) && (yyC <= '\udf88')) ||
                (('\udf8a' <= yyC) && (yyC <= '\udfa8')) ||
                (('\udfaa' <= yyC) && (yyC <= '\udfc2')) ||
                (('\udfc4' <= yyC) && (yyC <= '\udfcb'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud840':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\udc00' == yyC) {

              yyValue = "\ud840\udc00";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud869':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\uded6' == yyC) {

              yyValue = "\ud869\uded6";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud87e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\ude1d')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\'':
        {
          yyValue = "\'";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          ('_' == yyC) ||
          ('\u00ad' == yyC) ||
          (('\u0300' <= yyC) && (yyC <= '\u036f')) ||
          (('\u0483' <= yyC) && (yyC <= '\u0486')) ||
          (('\u0591' <= yyC) && (yyC <= '\u05bd')) ||
          ('\u05bf' == yyC) ||
          (('\u05c1' <= yyC) && (yyC <= '\u05c2')) ||
          (('\u05c4' <= yyC) && (yyC <= '\u05c5')) ||
          ('\u05c7' == yyC) ||
          (('\u0600' <= yyC) && (yyC <= '\u0603')) ||
          (('\u0610' <= yyC) && (yyC <= '\u0615')) ||
          (('\u064b' <= yyC) && (yyC <= '\u065e')) ||
          (('\u0660' <= yyC) && (yyC <= '\u0669')) ||
          ('\u0670' == yyC) ||
          (('\u06d6' <= yyC) && (yyC <= '\u06dd')) ||
          (('\u06df' <= yyC) && (yyC <= '\u06e4')) ||
          (('\u06e7' <= yyC) && (yyC <= '\u06e8')) ||
          (('\u06ea' <= yyC) && (yyC <= '\u06ed')) ||
          (('\u06f0' <= yyC) && (yyC <= '\u06f9')) ||
          ('\u070f' == yyC) ||
          ('\u0711' == yyC) ||
          (('\u0730' <= yyC) && (yyC <= '\u074a')) ||
          (('\u07a6' <= yyC) && (yyC <= '\u07b0')) ||
          (('\u07c0' <= yyC) && (yyC <= '\u07c9')) ||
          (('\u07eb' <= yyC) && (yyC <= '\u07f3')) ||
          (('\u0901' <= yyC) && (yyC <= '\u0903')) ||
          ('\u093c' == yyC) ||
          (('\u093e' <= yyC) && (yyC <= '\u094d')) ||
          (('\u0951' <= yyC) && (yyC <= '\u0954')) ||
          (('\u0962' <= yyC) && (yyC <= '\u0963')) ||
          (('\u0966' <= yyC) && (yyC <= '\u096f')) ||
          (('\u0981' <= yyC) && (yyC <= '\u0983')) ||
          ('\u09bc' == yyC) ||
          (('\u09be' <= yyC) && (yyC <= '\u09c4')) ||
          (('\u09c7' <= yyC) && (yyC <= '\u09c8')) ||
          (('\u09cb' <= yyC) && (yyC <= '\u09cd')) ||
          ('\u09d7' == yyC) ||
          (('\u09e2' <= yyC) && (yyC <= '\u09e3')) ||
          (('\u09e6' <= yyC) && (yyC <= '\u09ef')) ||
          (('\u0a01' <= yyC) && (yyC <= '\u0a03')) ||
          ('\u0a3c' == yyC) ||
          (('\u0a3e' <= yyC) && (yyC <= '\u0a42')) ||
          (('\u0a47' <= yyC) && (yyC <= '\u0a48')) ||
          (('\u0a4b' <= yyC) && (yyC <= '\u0a4d')) ||
          (('\u0a66' <= yyC) && (yyC <= '\u0a71')) ||
          (('\u0a81' <= yyC) && (yyC <= '\u0a83')) ||
          ('\u0abc' == yyC) ||
          (('\u0abe' <= yyC) && (yyC <= '\u0ac5')) ||
          (('\u0ac7' <= yyC) && (yyC <= '\u0ac9')) ||
          (('\u0acb' <= yyC) && (yyC <= '\u0acd')) ||
          (('\u0ae2' <= yyC) && (yyC <= '\u0ae3')) ||
          (('\u0ae6' <= yyC) && (yyC <= '\u0aef')) ||
          (('\u0b01' <= yyC) && (yyC <= '\u0b03')) ||
          ('\u0b3c' == yyC) ||
          (('\u0b3e' <= yyC) && (yyC <= '\u0b43')) ||
          (('\u0b47' <= yyC) && (yyC <= '\u0b48')) ||
          (('\u0b4b' <= yyC) && (yyC <= '\u0b4d')) ||
          (('\u0b56' <= yyC) && (yyC <= '\u0b57')) ||
          (('\u0b66' <= yyC) && (yyC <= '\u0b6f')) ||
          ('\u0b82' == yyC) ||
          (('\u0bbe' <= yyC) && (yyC <= '\u0bc2')) ||
          (('\u0bc6' <= yyC) && (yyC <= '\u0bc8')) ||
          (('\u0bca' <= yyC) && (yyC <= '\u0bcd')) ||
          ('\u0bd7' == yyC) ||
          (('\u0be6' <= yyC) && (yyC <= '\u0bef')) ||
          (('\u0c01' <= yyC) && (yyC <= '\u0c03')) ||
          (('\u0c3e' <= yyC) && (yyC <= '\u0c44')) ||
          (('\u0c46' <= yyC) && (yyC <= '\u0c48')) ||
          (('\u0c4a' <= yyC) && (yyC <= '\u0c4d')) ||
          (('\u0c55' <= yyC) && (yyC <= '\u0c56')) ||
          (('\u0c66' <= yyC) && (yyC <= '\u0c6f')) ||
          (('\u0c82' <= yyC) && (yyC <= '\u0c83')) ||
          ('\u0cbc' == yyC) ||
          (('\u0cbe' <= yyC) && (yyC <= '\u0cc4')) ||
          (('\u0cc6' <= yyC) && (yyC <= '\u0cc8')) ||
          (('\u0cca' <= yyC) && (yyC <= '\u0ccd')) ||
          (('\u0cd5' <= yyC) && (yyC <= '\u0cd6')) ||
          (('\u0ce2' <= yyC) && (yyC <= '\u0ce3')) ||
          (('\u0ce6' <= yyC) && (yyC <= '\u0cef')) ||
          (('\u0d02' <= yyC) && (yyC <= '\u0d03')) ||
          (('\u0d3e' <= yyC) && (yyC <= '\u0d43')) ||
          (('\u0d46' <= yyC) && (yyC <= '\u0d48')) ||
          (('\u0d4a' <= yyC) && (yyC <= '\u0d4d')) ||
          ('\u0d57' == yyC) ||
          (('\u0d66' <= yyC) && (yyC <= '\u0d6f')) ||
          (('\u0d82' <= yyC) && (yyC <= '\u0d83')) ||
          ('\u0dca' == yyC) ||
          (('\u0dcf' <= yyC) && (yyC <= '\u0dd4')) ||
          ('\u0dd6' == yyC) ||
          (('\u0dd8' <= yyC) && (yyC <= '\u0ddf')) ||
          (('\u0df2' <= yyC) && (yyC <= '\u0df3')) ||
          ('\u0e31' == yyC) ||
          (('\u0e34' <= yyC) && (yyC <= '\u0e3a')) ||
          (('\u0e47' <= yyC) && (yyC <= '\u0e4e')) ||
          (('\u0e50' <= yyC) && (yyC <= '\u0e59')) ||
          ('\u0eb1' == yyC) ||
          (('\u0eb4' <= yyC) && (yyC <= '\u0eb9')) ||
          (('\u0ebb' <= yyC) && (yyC <= '\u0ebc')) ||
          (('\u0ec8' <= yyC) && (yyC <= '\u0ecd')) ||
          (('\u0ed0' <= yyC) && (yyC <= '\u0ed9')) ||
          (('\u0f18' <= yyC) && (yyC <= '\u0f19')) ||
          (('\u0f20' <= yyC) && (yyC <= '\u0f29')) ||
          ('\u0f35' == yyC) ||
          ('\u0f37' == yyC) ||
          ('\u0f39' == yyC) ||
          (('\u0f3e' <= yyC) && (yyC <= '\u0f3f')) ||
          (('\u0f71' <= yyC) && (yyC <= '\u0f84')) ||
          (('\u0f86' <= yyC) && (yyC <= '\u0f87')) ||
          (('\u0f90' <= yyC) && (yyC <= '\u0f97')) ||
          (('\u0f99' <= yyC) && (yyC <= '\u0fbc')) ||
          ('\u0fc6' == yyC) ||
          (('\u102c' <= yyC) && (yyC <= '\u1032')) ||
          (('\u1036' <= yyC) && (yyC <= '\u1039')) ||
          (('\u1040' <= yyC) && (yyC <= '\u1049')) ||
          (('\u1056' <= yyC) && (yyC <= '\u1059')) ||
          ('\u135f' == yyC) ||
          (('\u1712' <= yyC) && (yyC <= '\u1714')) ||
          (('\u1732' <= yyC) && (yyC <= '\u1734')) ||
          (('\u1752' <= yyC) && (yyC <= '\u1753')) ||
          (('\u1772' <= yyC) && (yyC <= '\u1773')) ||
          (('\u17b4' <= yyC) && (yyC <= '\u17d3')) ||
          ('\u17dd' == yyC) ||
          (('\u17e0' <= yyC) && (yyC <= '\u17e9')) ||
          (('\u180b' <= yyC) && (yyC <= '\u180d')) ||
          (('\u1810' <= yyC) && (yyC <= '\u1819')) ||
          ('\u18a9' == yyC) ||
          (('\u1920' <= yyC) && (yyC <= '\u192b')) ||
          (('\u1930' <= yyC) && (yyC <= '\u193b')) ||
          (('\u1946' <= yyC) && (yyC <= '\u194f')) ||
          (('\u19b0' <= yyC) && (yyC <= '\u19c0')) ||
          (('\u19c8' <= yyC) && (yyC <= '\u19c9')) ||
          (('\u19d0' <= yyC) && (yyC <= '\u19d9')) ||
          (('\u1a17' <= yyC) && (yyC <= '\u1a1b')) ||
          (('\u1b00' <= yyC) && (yyC <= '\u1b04')) ||
          (('\u1b34' <= yyC) && (yyC <= '\u1b44')) ||
          (('\u1b50' <= yyC) && (yyC <= '\u1b59')) ||
          (('\u1b6b' <= yyC) && (yyC <= '\u1b73')) ||
          (('\u1dc0' <= yyC) && (yyC <= '\u1dca')) ||
          (('\u1dfe' <= yyC) && (yyC <= '\u1dff')) ||
          (('\u200b' <= yyC) && (yyC <= '\u200f')) ||
          (('\u202a' <= yyC) && (yyC <= '\u202e')) ||
          (('\u203f' <= yyC) && (yyC <= '\u2040')) ||
          ('\u2054' == yyC) ||
          (('\u2060' <= yyC) && (yyC <= '\u2063')) ||
          (('\u206a' <= yyC) && (yyC <= '\u206f')) ||
          (('\u20d0' <= yyC) && (yyC <= '\u20dc')) ||
          ('\u20e1' == yyC) ||
          (('\u20e5' <= yyC) && (yyC <= '\u20ef')) ||
          (('\u302a' <= yyC) && (yyC <= '\u302f')) ||
          (('\u3099' <= yyC) && (yyC <= '\u309a')) ||
          ('\ua802' == yyC) ||
          ('\ua806' == yyC) ||
          ('\ua80b' == yyC) ||
          (('\ua823' <= yyC) && (yyC <= '\ua827')) ||
          ('\ufb1e' == yyC) ||
          (('\ufe00' <= yyC) && (yyC <= '\ufe0f')) ||
          (('\ufe20' <= yyC) && (yyC <= '\ufe23')) ||
          (('\ufe33' <= yyC) && (yyC <= '\ufe34')) ||
          (('\ufe4d' <= yyC) && (yyC <= '\ufe4f')) ||
          ('\ufeff' == yyC) ||
          (('\uff10' <= yyC) && (yyC <= '\uff19')) ||
          ('\uff3f' == yyC) ||
          (('\ufff9' <= yyC) && (yyC <= '\ufffb'))) {

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '\udca0':
            case '\udca1':
            case '\udca2':
            case '\udca3':
            case '\udca4':
            case '\udca5':
            case '\udca6':
            case '\udca7':
            case '\udca8':
            case '\udca9':
              {
                yyValue = difference(yyStart, yyIndex);

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '\ude01':
            case '\ude02':
            case '\ude03':
            case '\ude05':
            case '\ude06':
            case '\ude0c':
            case '\ude0d':
            case '\ude0e':
            case '\ude0f':
            case '\ude38':
            case '\ude39':
            case '\ude3a':
            case '\ude3f':
              {
                yyValue = difference(yyStart, yyIndex);

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '\ud834':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udd65' <= yyC) && (yyC <= '\udd69')) ||
                (('\udd6d' <= yyC) && (yyC <= '\udd82')) ||
                (('\udd85' <= yyC) && (yyC <= '\udd8b')) ||
                (('\uddaa' <= yyC) && (yyC <= '\uddad')) ||
                (('\ude42' <= yyC) && (yyC <= '\ude44'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udfce' <= yyC) && (yyC <= '\udfff')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\udb40':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc01' == yyC) ||
                (('\udc20' <= yyC) && (yyC <= '\udc7f')) ||
                (('\udd00' <= yyC) && (yyC <= '\uddef'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("idrest expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.IdText.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdText(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      if (FortressUtil.validId(a1)) {

        yyValue = a1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("id text expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.Id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pId(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fId) yyColumn.chunk2.fId = pId$1(yyStart);
    return yyColumn.chunk2.fId;
  }

  /** Actually parse Identifier.Id. */
  private Result pId$1(final int yyStart) throws IOException {
    Result     yyResult;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = new Id(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.SimpleName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleName(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSimpleName) 
      yyColumn.chunk2.fSimpleName = pSimpleName$1(yyStart);
    return yyColumn.chunk2.fSimpleName;
  }

  /** Actually parse Identifier.SimpleName. */
  private Result pSimpleName$1(final int yyStart) throws IOException {
    Result     yyResult;
    SimpleName yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = popr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pOp(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pPreSymbol$EncloserPair(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.APIName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAPIName(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAPIName) 
      yyColumn.chunk2.fAPIName = pAPIName$1(yyStart);
    return yyColumn.chunk2.fAPIName;
  }

  /** Actually parse Identifier.APIName. */
  private Result pAPIName$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    APIName    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyPredResult = pw(yyChoice1);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyPredResult = pellipses(yyPredResult.index);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyValue = NodeFactory.makeAPIName(createSpan(yyStart,yyCount), a1);

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }
      }

      // Nested alternative 2.

      yyResult = pAPIName$$Star1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Id> a2s = yyResult.semanticValue();

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyPredResult = pw(yyChoice2);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyPredResult = pellipses(yyPredResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyValue = NodeFactory.makeAPIName(createSpan(yyStart,yyCount),
            IterUtil.compose(a1, a2s.list()));

            return new SemanticValue(yyValue, yyChoice2, yyError);
          }
        }

        // Nested alternative 2.

        yyValue = NodeFactory.makeAPIName(createSpan(yyStart,yyCount),
        IterUtil.compose(a1, a2s.list()));

        return new SemanticValue(yyValue, yyChoice2, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.APIName$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAPIName$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAPIName$$Star1) 
      yyColumn.chunk2.fAPIName$$Star1 = pAPIName$$Star1$1(yyStart);
    return yyColumn.chunk2.fAPIName$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.preparser.PreFortress.APIName$$Star1. */
  private Result pAPIName$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pdot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id v$el$1 = yyResult.semanticValue();

        yyResult = pAPIName$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Id> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Id>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.QualifiedName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualifiedName(final int yyStart) throws IOException {
    Result          yyResult;
    Result          yyPredResult;
    int             yyRepetition1;
    Pair<Id>        yyRepValue1;
    QualifiedIdName yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyPredResult = pw(yyChoice1);
      yyError      = yyPredResult.select(yyError);
      if (yyPredResult.hasValue()) {

        yyPredResult = pellipses(yyPredResult.index);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyValue = NodeFactory.makeQualifiedIdName(createSpan(yyStart,yyCount), a1);

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }
      }

      // Nested alternative 2.

      yyRepetition1 = yyChoice1;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pdot(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pId(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Id v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Id>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Id> a2s = yyRepValue1.reverse();

        final int yyChoice2 = yyRepetition1;

        // Nested alternative 1.

        yyPredResult = pw(yyChoice2);
        yyError      = yyPredResult.select(yyError);
        if (yyPredResult.hasValue()) {

          yyPredResult = pellipses(yyPredResult.index);
          yyError      = yyPredResult.select(yyError);
          if (yyPredResult.hasValue()) {

            yyValue = NodeFactory.makeQualifiedIdName(createSpan(yyStart,yyCount),
            a1, a2s.list());

            return new SemanticValue(yyValue, yyChoice2, yyError);
          }
        }

        // Nested alternative 2.

        yyValue = NodeFactory.makeQualifiedIdName(createSpan(yyStart,yyCount),
        a1, a2s.list());

        return new SemanticValue(yyValue, yyChoice2, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.api.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result papi(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('p' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("api expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("api expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.as.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pas(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('s' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("as expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("as expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.component.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomponent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('m' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('p' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('o' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('t' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("component expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("component expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.except.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexcept(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('c' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('p' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("except expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("except expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.import.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pimport(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('m' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("import expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("import expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.opr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popr(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('p' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("opr expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("opr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.Encloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEncloser(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fEncloser) 
      yyColumn.chunk2.fEncloser = pEncloser$1(yyStart);
    return yyColumn.chunk2.fEncloser;
  }

  /** Actually parse PreSymbol.Encloser. */
  private Result pEncloser$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pencloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOp(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.LeftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLeftEncloser(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fLeftEncloser) 
      yyColumn.chunk2.fLeftEncloser = pLeftEncloser$1(yyStart);
    return yyColumn.chunk2.fLeftEncloser;
  }

  /** Actually parse PreSymbol.LeftEncloser. */
  private Result pLeftEncloser$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pleftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOp(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.RightEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRightEncloser(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fRightEncloser) 
      yyColumn.chunk2.fRightEncloser = pRightEncloser$1(yyStart);
    return yyColumn.chunk2.fRightEncloser;
  }

  /** Actually parse PreSymbol.RightEncloser. */
  private Result pRightEncloser$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = prightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOp(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.EncloserPair.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPreSymbol$EncloserPair(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Enclosing  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPreSymbol$EncloserPair$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pPreSymbol$EncloserPair$$Choice2(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          if (PrecedenceMap.ONLY.matchedBrackets(a1.getText(), a2.getText()))
          yyValue = new Enclosing(createSpan(yyStart,yyCount), a1, a2);
          else
          yyValue = error(a2, "Mismatched Enclosers.");

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreSymbol.EncloserPair$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPreSymbol$EncloserPair$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLeftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal PreSymbol.EncloserPair$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPreSymbol$EncloserPair$$Choice2(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.bar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("bar expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.sd.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psd(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyC = character(yyOption1);
    if (-1 != yyC) {
      yyIndex = yyOption1 + 1;

      switch (yyC) {
      case '*':
      case '.':
        {
          yyOption1  = yyIndex;
        }

      default:
        /* No match. */
      }
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyOption1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.bars.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbars(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fbars) 
      yyColumn.chunk2.fbars = pbars$1(yyStart);
    return yyColumn.chunk2.fbars;
  }

  /** Actually parse PreSymbol.bars. */
  private Result pbars$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pbars$$Star1(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bars expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.bars$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbars$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fbars$$Star1) 
      yyColumn.chunk3.fbars$$Star1 = pbars$$Star1$1(yyStart);
    return yyColumn.chunk3.fbars$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.preparser.PreFortress.bars$$Star1. */
  private Result pbars$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psd(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('|' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pbars$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\"|\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.slashes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pslashes(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fslashes) 
      yyColumn.chunk3.fslashes = pslashes$1(yyStart);
    return yyColumn.chunk3.fslashes;
  }

  /** Actually parse PreSymbol.slashes. */
  private Result pslashes$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '/':
        {
          yyResult = pslashes$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      case '\\':
        {
          yyResult = pslashes$$Star2(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("slashes expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.slashes$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pslashes$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fslashes$$Star1) 
      yyColumn.chunk3.fslashes$$Star1 = pslashes$$Star1$1(yyStart);
    return yyColumn.chunk3.fslashes$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.preparser.PreFortress.slashes$$Star1. */
  private Result pslashes$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psd(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('/' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pslashes$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\"/\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.slashes$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pslashes$$Star2(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fslashes$$Star2) 
      yyColumn.chunk3.fslashes$$Star2 = pslashes$$Star2$1(yyStart);
    return yyColumn.chunk3.fslashes$$Star2;
  }

  /** Actually parse com.sun.fortress.parser.preparser.PreFortress.slashes$$Star2. */
  private Result pslashes$$Star2$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psd(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('\\' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pslashes$$Star2(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\"\\\\\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.lesses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plesses(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        yyResult = psd(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if ('<' == yyC) {
            yyIndex = yyResult.index + 1;

            yyRepetition1 = yyIndex;
            continue;
          } else {
            yyError = yyError.select("\"<\" expected", yyBase);
          }
        }
        break;
      }

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("lesses expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.greaters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgreaters(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fgreaters) 
      yyColumn.chunk3.fgreaters = pgreaters$1(yyStart);
    return yyColumn.chunk3.fgreaters;
  }

  /** Actually parse PreSymbol.greaters. */
  private Result pgreaters$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pgreaters$$Star1(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("greaters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.greaters$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgreaters$$Star1(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fgreaters$$Star1) 
      yyColumn.chunk3.fgreaters$$Star1 = pgreaters$$Star1$1(yyStart);
    return yyColumn.chunk3.fgreaters$$Star1;
  }

  /** Actually parse com.sun.fortress.parser.preparser.PreFortress.greaters$$Star1. */
  private Result pgreaters$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psd(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('>' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pgreaters$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\">\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.encloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pencloser(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fencloser) 
      yyColumn.chunk3.fencloser = pencloser$1(yyStart);
    return yyColumn.chunk3.fencloser;
  }

  /** Actually parse PreSymbol.encloser. */
  private Result pencloser$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pbar(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pbars(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyPredMatched = false;

        yyPredResult = pencloser$$Choice1(yyResult.index);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("encloser expected", yyStart);
        }
      }
    } else {
      yyError = yyError.select("encloser expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.encloser$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pencloser$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
      case '.':
      case '/':
      case '>':
      case '\\':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '-':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('>' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("encloser expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.leftEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pleftEncloser(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fleftEncloser) 
      yyColumn.chunk3.fleftEncloser = pleftEncloser$1(yyStart);
    return yyColumn.chunk3.fleftEncloser;
  }

  /** Actually parse PreSymbol.leftEncloser. */
  private Result pleftEncloser$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pleftEncloserMulti(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (PrecedenceMap.ONLY.isLeft(yyValue)) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (c != '|' && PrecedenceMap.ONLY.isLeft(""+c)) {

        yyValue = ""+c;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("left encloser expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.leftEncloserMulti.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pleftEncloserMulti(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '(':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyRepetition1 = yyChoice1;
          yyRepeated1   = false;
          while (true) {

            yyBase = yyRepetition1;
            yyC    = character(yyBase);
            if ('/' == yyC) {
              yyIndex = yyRepetition1 + 1;

              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            } else {
              yyError = yyError.select("\"/\" expected", yyBase);
            }
            break;
          }

          if (yyRepeated1) {

            yyValue = difference(yyStart, yyRepetition1);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          }

          // Nested alternative 2.

          yyRepetition1 = yyChoice1;
          yyRepeated1   = false;
          while (true) {

            yyBase = yyRepetition1;
            yyC    = character(yyBase);
            if ('\\' == yyC) {
              yyIndex = yyRepetition1 + 1;

              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            } else {
              yyError = yyError.select("\"\\\\\" expected", yyBase);
            }
            break;
          }

          if (yyRepeated1) {

            yyValue = difference(yyStart, yyRepetition1);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          }
        }
        break;

      case '[':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('/' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('\\' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('/' == yyC) {

                      final int yyChoice2 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice2);
                      if (-1 != yyC) {
                        yyIndex = yyChoice2 + 1;
                        if ('\\' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('/' == yyC) {

                              yyValue = "[/\\/\\/";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }
                          }
                        }
                      }

                      // Nested alternative 2.

                      yyValue = "[/\\/";

                      return new SemanticValue(yyValue, yyChoice2, yyError);
                    }
                  }
                }
              }
            }
          }

          // Nested alternative 2.

          yyResult = psd(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pslashes(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = difference(yyStart, yyResult.index);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      case '{':
        {
          yyResult = psd(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pslashes(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = difference(yyStart, yyResult.index);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyResult = plesses(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psd(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pslashes(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pbars(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = pbars(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psd(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pslashes(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '{':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('*' == yyC) {

              yyValue = "{*";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '[':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('*' == yyC) {

              yyValue = "[*";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '(':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '(':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('>' == yyC) {

                    yyValue = "((>";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case '<':
              {
                yyValue = "(<";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("left encloser multi expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.rightEncloser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightEncloser(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.frightEncloser) 
      yyColumn.chunk3.frightEncloser = prightEncloser$1(yyStart);
    return yyColumn.chunk3.frightEncloser;
  }

  /** Actually parse PreSymbol.rightEncloser. */
  private Result prightEncloser$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = prightEncloserMulti(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (PrecedenceMap.ONLY.isRight(yyValue)) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char c = (char)yyC;

      if (c != '|' && PrecedenceMap.ONLY.isRight(""+c)) {

        yyValue = ""+c;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("right encloser expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.rightEncloserMulti.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightEncloserMulti(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.frightEncloserMulti) 
      yyColumn.chunk3.frightEncloserMulti = prightEncloserMulti$1(yyStart);
    return yyColumn.chunk3.frightEncloserMulti;
  }

  /** Actually parse PreSymbol.rightEncloserMulti. */
  private Result prightEncloserMulti$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = prightEncloserMulti$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (')' == yyC) {
        yyIndex = yyResult.index + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("\")\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = prightEncloserMulti$$Plus2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (')' == yyC) {
        yyIndex = yyResult.index + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("\")\" expected", yyBase);
      }
    }

    // Alternative 3.

    yyResult = pslashes(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psd(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pgreaters(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pbars(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case ']':
          case '}':
            {
              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }

          default:
            /* No match. */
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pbars(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = psd(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pgreaters(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case ']':
              {
                yyValue = "*]";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '}':
              {
                yyValue = "*}";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case ']':
        {
          yyValue = "]";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = "}";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '>':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (')' == yyC) {

              yyValue = ">)";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '<':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (')' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if (')' == yyC) {

                  yyValue = "<))";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case '/':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('\\' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('/' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;

                    switch (yyC) {
                    case '\\':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('/' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if (']' == yyC) {

                                yyValue = "/\\/\\/]";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              }
                            }
                          }
                        }
                      }
                      break;

                    case ']':
                      {
                        yyValue = "/\\/]";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }

                    default:
                      /* No match. */
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("right encloser multi expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.rightEncloserMulti$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightEncloserMulti$$Plus1(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.frightEncloserMulti$$Plus1) 
      yyColumn.chunk4.frightEncloserMulti$$Plus1 = prightEncloserMulti$$Plus1$1(yyStart);
    return yyColumn.chunk4.frightEncloserMulti$$Plus1;
  }

  /** Actually parse com.sun.fortress.parser.preparser.PreFortress.rightEncloserMulti$$Plus1. */
  private Result prightEncloserMulti$$Plus1$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('/' == yyC) {

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyResult = prightEncloserMulti$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("right encloser multi expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.rightEncloserMulti$$Plus2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result prightEncloserMulti$$Plus2(final int yyStart) 
    throws IOException {

    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.frightEncloserMulti$$Plus2) 
      yyColumn.chunk4.frightEncloserMulti$$Plus2 = prightEncloserMulti$$Plus2$1(yyStart);
    return yyColumn.chunk4.frightEncloserMulti$$Plus2;
  }

  /** Actually parse com.sun.fortress.parser.preparser.PreFortress.rightEncloserMulti$$Plus2. */
  private Result prightEncloserMulti$$Plus2$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('\\' == yyC) {

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyResult = prightEncloserMulti$$Plus2(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("right encloser multi expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.OpName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOpName(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pcross(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pid(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String opn = yyResult.semanticValue();

        if (FortressUtil.validOp(opn)) {

          yyValue = opn;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    } else {
      yyError = yyError.select("op name expected", yyStart);
    }

    // Done.
    yyError = yyError.select("op name expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.Op.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOp(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fOp) yyColumn.chunk4.fOp = pOp$1(yyStart);
    return yyColumn.chunk4.fOp;
  }

  /** Actually parse PreSymbol.Op. */
  private Result pOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.Op$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOp$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcondOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyPredMatched = false;

      yyPredResult = pequalsOp(yyResult.index);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("op expected", yyStart);
      }
    }

    // Alternative 3.

    yyResult = pcompOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.compOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcompOp(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fcompOp) 
      yyColumn.chunk4.fcompOp = pcompOp$1(yyStart);
    return yyColumn.chunk4.fcompOp;
  }

  /** Actually parse PreSymbol.compOp. */
  private Result pcompOp$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '=':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '=':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('=' == yyC) {

                    yyValue = "===";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case '/':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('=' == yyC) {

                    yyValue = "=/=";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case '<':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = "<=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '>':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = ">=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("comp op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.condOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcondOp(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;
      String a1 = ":";

      yyResult = pop(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyResult = pcolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a3 = yyResult.semanticValue();

          yyValue = a1+a2+a3;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pop(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pcolon(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = a1+a2;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("cond op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.multiOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmultiOp(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fmultiOp) 
      yyColumn.chunk4.fmultiOp = pmultiOp$1(yyStart);
    return yyColumn.chunk4.fmultiOp;
  }

  /** Actually parse PreSymbol.multiOp. */
  private Result pmultiOp$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '-':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '/':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('-' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('>' == yyC) {

                        yyValue = "-/->";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }
                    }
                  }
                }
              }
              break;

            case '-':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('>' == yyC) {

                    yyValue = "-->";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case '>':
              {
                yyValue = "->";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '<':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '-':
              {
                final int yyChoice1 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice1);
                if (-1 != yyC) {
                  yyIndex = yyChoice1 + 1;

                  switch (yyC) {
                  case '/':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('-' == yyC) {

                          yyValue = "<-/-";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                    break;

                  case '>':
                    {
                      yyValue = "<->";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyValue = "<-";

                return new SemanticValue(yyValue, yyChoice1, yyError);
              }

            case '<':
              {
                final int yyChoice1 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice1);
                if (-1 != yyC) {
                  yyIndex = yyChoice1 + 1;
                  if ('<' == yyC) {

                    yyValue = "<<<";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }

                // Nested alternative 2.

                yyValue = "<<";

                return new SemanticValue(yyValue, yyChoice1, yyError);
              }

            case '=':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('>' == yyC) {

                    yyValue = "<=>";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case '=':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '=':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('>' == yyC) {

                    yyValue = "==>";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case '>':
              {
                yyValue = "=>";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '>':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('>' == yyC) {

              final int yyChoice1 = yyIndex;

              // Nested alternative 1.

              yyC = character(yyChoice1);
              if (-1 != yyC) {
                yyIndex = yyChoice1 + 1;
                if ('>' == yyC) {

                  yyValue = ">>>";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }

              // Nested alternative 2.

              yyValue = ">>";

              return new SemanticValue(yyValue, yyChoice1, yyError);
            }
          }
        }
        break;

      case '|':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('-' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('>' == yyC) {

                  yyValue = "|->";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case '*':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('*' == yyC) {

              yyValue = "**";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '!':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('!' == yyC) {

              yyValue = "!!";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyPredMatched = false;

    yyPredResult = prightEncloserMulti(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      final int yyChoice1 = yyStart;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;
        if ('/' == yyC) {

          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('/' == yyC) {

              final int yyChoice2 = yyIndex;

              // Nested alternative 1.

              yyC = character(yyChoice2);
              if (-1 != yyC) {
                yyIndex = yyChoice2 + 1;
                if ('/' == yyC) {

                  yyValue = "///";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }

              // Nested alternative 2.

              yyValue = "//";

              return new SemanticValue(yyValue, yyChoice2, yyError);
            }
          }
        }
      }
    } else {
      yyError = yyError.select("multi op expected", yyStart);
    }

    // Done.
    yyError = yyError.select("multi op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.singleOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psingleOp(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fsingleOp) 
      yyColumn.chunk4.fsingleOp = psingleOp$1(yyStart);
    return yyColumn.chunk4.fsingleOp;
  }

  /** Actually parse PreSymbol.singleOp. */
  private Result psingleOp$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = psingleOp$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char a1 = (char)yyC;

        if (PrecedenceMap.ONLY.isOperator("" + a1)) {

          yyValue = "" + a1;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    } else {
      yyError = yyError.select("single op expected", yyStart);
    }

    // Done.
    yyError = yyError.select("single op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * com.sun.fortress.parser.preparser.PreFortress.singleOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psingleOp$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pencloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pleftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = prightEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pmultiOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pcompOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("single op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.op.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pop(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fop) yyColumn.chunk4.fop = pop$1(yyStart);
    return yyColumn.chunk4.fop;
  }

  /** Actually parse PreSymbol.op. */
  private Result pop$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOpName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pmultiOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.equalsOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pequalsOp(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psingleOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("=")) {
      yyValue = "=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("equals op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.semicolon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psemicolon(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fsemicolon) 
      yyColumn.chunk4.fsemicolon = psemicolon$1(yyStart);
    return yyColumn.chunk4.fsemicolon;
  }

  /** Actually parse PreSymbol.semicolon. */
  private Result psemicolon$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (';' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("semicolon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.colon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcolon(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fcolon) 
      yyColumn.chunk4.fcolon = pcolon$1(yyStart);
    return yyColumn.chunk4.fcolon;
  }

  /** Actually parse PreSymbol.colon. */
  private Result pcolon$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = ":";

      yyPredMatched = false;

      yyPredResult = pop(yyIndex);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("colon expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("colon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.ellipses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pellipses(final int yyStart) throws IOException {
    PreFortressColumn yyColumn = (PreFortressColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fellipses) 
      yyColumn.chunk4.fellipses = pellipses$1(yyStart);
    return yyColumn.chunk4.fellipses;
  }

  /** Actually parse PreSymbol.ellipses. */
  private Result pellipses$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('.' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('.' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = "...";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("ellipses expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.closecurly.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosecurly(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('}' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closecurly expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.cross.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcross(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('B' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('Y' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("cross expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.opencurly.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popencurly(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pleftEncloser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("{")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("opencurly expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.comma.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomma(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("comma expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal PreSymbol.dot.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdot(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("dot expected", yyStart);
    return yyError;
  }

  // =========================================================================

  Span createSpan(int start, int end) {
    Column s = column(start);
    Column e = column(end-1);
    SourceLocRats slStart = new SourceLocRats(s.file, s.line, s.column);
    SourceLocRats slEnd   = new SourceLocRats(e.file, e.line, e.column);
    return new Span(slStart, slEnd);
  }
  static {
    add(FORTRESS_KEYWORDS, new String[] {
      "FORALL",
      
      "goto",         "idiom",        "public",       "pure",
      "reciprocal",   "static",
      
      "BIG",          "SI_unit",      "absorbs",      "abstract",
      "also",         "api",          "as",           "asif",
      "at",           "atomic",       "bool",         "case",
      "catch",        "coerce",       "coerces",      "component",
      "comprises",    "default",      "dim",          "do",
      "elif",         "else",         "end",          "ensures",
      "except",       "excludes",     "exit",         "export",
      "extends",      "finally",      "fn",           "for",
      "forbid",       "getter",       "grammar",      "hidden",
      "if",           "import",       "in",           "int",
      "invariant",    "io",           "label",        "most",
      "nat",          "native",       "object",       "of",
      "opr",          "or",           "override",     "private",
      "property",     "provided",     "requires",
      "self",         "settable",     "setter",       "spawn",
      "syntax",       "test",         "then",         "throw",
      "throws",       "trait",        "transient",    "try",
      "tryatomic",    "type",         "typecase",     "unit",
      "value",        "var",          "where",        "while",
      "widens",       "with",         "wrapped"
    });
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
