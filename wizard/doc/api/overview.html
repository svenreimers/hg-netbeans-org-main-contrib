<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
  <head>
    <title>Wizards API</title>
  </head>
  <body>
  
  <h1>Wizards API</h1>
  Wizards enable users to complete multi-step tasks, dividing the UI for that
  into simple steps.  This library replaces NetBeans' Wizards API, incorporating
  lessons learned from that API, and providing a simple interface for 
  creating Wizards with minimum effort.
  
  <h2>Basics</h2>
  A Wizard is basically a factory for panels - each panel lets the user set
  some values, and listeners listen on those components and change the contents
  of a <code>Map</code> belonging to the wizard.  If the combination of settings
  is enough to continue, the Next or Finish button will be enabled.  On finish,
  the wizard will create an object or do something that modifies its external
  environment - it is up to the wizard implementation to determine what that
  means.
  <p>
  Mostly to use this API you'll be extending very simple convenience classes
  that do most of the work. Those classes are:
  <ul>
  <li>{@link org.netbeans.spi.wizard.WizardPanelProvider WizardPanelProvider} - the
    tool for creating simple wizards with a fixed list of steps</li>
  <li>{@link org.netbeans.spi.wizard.WizardBranchController WizardBranchController} -
    the tool for creating Wizards that decide on the fly what the next steps are
  </li>
  <li>{@link org.netbeans.spi.wizard.Wizard Wizard} Most of the time you won't 
    need this - the overall interface for Wizards</li>
  </ul>
  <p>
  
  <h2>Quick Start</h2>
  The Wizards API contains two convenience classes that handle 98% of all 
  use cases for Wizards, and are very simple to use.  A <code>Wizard</code>
  provides a bunch of panels - UI components - each of which can add 
  data to a <code>Map</code>.  At the end of a <code>Wizard</code> the 
  <code>finish (Map settings)</code> method is called, where the wizard
  can create or do what it needs to do.  If the user goes backward, pressing
  the <i>Previous</i> button in a wizard, settings they entered in the 
  &quot;future&quot; are automatically removed (but preserved in case they
  follow the same path again).
  <p>
  Displaying a <code>Wizard</code> once you have one is very simple - call
  <code>WizardDisplayer.show (myWizard)</code>.
  <p>
  <h3>Case 1 - A Simple Wizard with No Branching</h3>
  This is used in the case that all the steps of a wizard are known ahead of
  time.
  The class WizardPanelProvider makes it easy to create a series of panels,
  each of which can add contents to the settings map.  Here is a super-simple
  example, involving two panels, each with a checkbox.  If the first is 
  checked, the Next button is enabled user can move forward.  If the checkbox
  on the second panel is checked and the user can finish the <code>Wizard</code>.
  To display this wizard to a user, you would simply call
  <pre>
  WizardDisplayer.show (new FoodPanelProvider().createWizard());
  </pre>
  Apologies to vegetarians everywhere:
  <pre>
  class FoodPanelProvider extends WizardPanelProvider implements ActionListener {
    private JCheckBox meatBox;
    private JCheckBox steakBox;
    private Map settings;
    private WizardController controller;

    public FoodPanelProvider() {
        super ("Choose Your Dinner", 
            <font color="gray">//below are unique IDs for steps in this Wizard</font>
            new String[] { "vegetarian", "mealChoice" }, 
            <font color="gray">//Should really be localized - human-readable descriptions for the steps</font>
            new String[] { "Food preferences", "Meal Choice" });
    }

    protected JComponent createPanel(WizardController controller, String id, Map settings) {
        this.settings = settings;
        this.controller = controller;
        <font color="gray">//Create a JPanel we'll embed components in</font>
        JPanel result = new JPanel();
        result.setLayout (new FlowLayout());

        if ("vegetarian".equals(id)) { <font color="gray">//We're on the first pane</font>
            meatBox = new JCheckBox("I agree to eat meat");
            meatBox.setSelected (Boolean.TRUE.equals (settings.get("likesMeat")));
            meatBox.addActionListener (this);
            result.add (meatBox);
            controller.setProblem (meatBox.isSelected() ? null : "You must eat meat");
            <font color="gray">//Not the last pane, so the Finish button should never be enabled here</font>
            controller.setCanFinish (false);
        } else if ("mealChoice".equals(id)) {
            steakBox = new JCheckBox ("I will have the steak");
            steakBox.addActionListener (this);
            steakBox.setSelected (Boolean.TRUE.equals (settings.get("eatsSteak")));
            result.add (steakBox);
            controller.setProblem (steakBox.isSelected() ? null : "You must order the steak");
            controller.setCanFinish (steakBox.isSelected());
        } else {
            throw new Error ("Unknown ID " + id);
        }
        return result;
    }

    protected Object finish(Map settings) throws WizardException {
        <font color="gray">//Really you would construct some object or do something with the
        //contents of the map</font>
        return "Food Finished";
    }

    public void actionPerformed (ActionEvent ae) {
        JCheckBox src = (JCheckBox) ae.getSource();
        if (src == meatBox) {
            settings.put ("likesMeat", src.isSelected() ? Boolean.TRUE : Boolean.FALSE);
            controller.setProblem (src.isSelected() ? null : "You must eat meat!");
        } else {
            controller.setCanFinish (src.isSelected());
            settings.put ("eatsSteak", src.isSelected() ? Boolean.TRUE : Boolean.FALSE);
            controller.setProblem (src.isSelected() ? null : "We only serve steak!");
        }
    }
}
  </pre>
  <p>
  <h3>Case 2 - A Wizard With Branches</h3>
  This is used when the set of later steps in a wizard will be totally different
  depending on an earlier choice.  Rather than implement <code>Wizard</code>
  directly, you can implement <code>WizardBranchController</code> and simply 
  call its <code>createWizard()</code> to display it.  A <code>WizardBranchController</code>
  nests sub-wizards inside a parent wizard - it will can create a different sub-wizard
  for later steps depending on the choices in earlier ones.
  <p>
  We'll reuse the vegetarian-friendly class above in this example.  First we have
  an implementation of <code>WizardBranchController</code>.  Its constructor takes
  an argument of <code>WizardPanelProvider</code>.  When that provider runs 
  out of panels, it will look for the next sub-wizard that will provide the
  rest of the steps in the wizard.  Our branch controller will look at the
  contents of the settings map to decide which of two wizards should be the
  continuation of this one.
  <p>
  To actually display this wizard, all you do is call
  <pre>
  WizardDisplayer.show (new BranchControllerImpl().createWizard());
  </pre>
  <p>
  <pre>
    
    private static final String KEY_BRANCH = "colorOrFood";
    private static final String VALUE_FOOD = "food";
    private static final String VALUE_COLOR = "color";
    class BranchControllerImpl extends WizardBranchController {
        
        BranchControllerImpl() {
            super(new Base());
        }
        
        private FoodPanelProvider foodInfo = null;
        private FoodPanelProvider getFoodPanels() {
            if (foodInfo == null) {
                foodInfo = new FoodPanelProvider();
            }
            return foodInfo;
        }
        
        private ColorPanelProvider colorInfo = null;
        private ColorPanelProvider getColorPanels() {
            if (colorInfo == null) {
                colorInfo = new ColorPanelProvider();
            }
            return colorInfo;
        }
        

        protected WizardPanelProvider getPanelProviderForStep (String step, Map settings) {
            String which = (String) settings.get (KEY_BRANCH);
            if (which == null) {
                return null;
            } else if (VALUE_FOOD.equals(which)) {
                return getFoodPanels();
            } else if (VALUE_COLOR.equals(which)) {
                return getColorPanels();
            } else {
                throw new IllegalArgumentException (which);
            }
        }
    }
    
    private static class Base extends WizardPanelProvider implements ActionListener {
        JRadioButton food;
        JRadioButton colors;
        JRadioButton neither;
        Map settings;
        WizardController controller;
        
        public Base () {
            super ("The Look or Eat Wizard", new String[] { "choose" }, new String[] { "Choose to Eat or Look" });
        }
        
        protected JComponent createPanel(WizardController controller, String id, Map settings) {
            this.controller = controller;
            JPanel result = new JPanel();
            result.setLayout (new FlowLayout());
            food = new JRadioButton ("Food");
            colors = new JRadioButton ("Colors");
            neither = new JRadioButton ("Neither");
            result.add (food);
            result.add (colors);
            result.add (neither);
            food.addActionListener(this);
            colors.addActionListener (this);
            neither.addActionListener (this);
            this.settings = settings;
            return result;
        }

        protected Object finish(Map settings) throws WizardException {
            throw new Error ("Finish should never be called for base");
        }
        
        public void actionPerformed (ActionEvent ae) {
            if (ae.getSource() == food) {
                colors.setSelected(false);
                neither.setSelected(false);
                settings.put (KEY_BRANCH, VALUE_FOOD);
                controller.setProblem (null);
            } else if (ae.getSource() == colors) {
                food.setSelected(false);
                neither.setSelected(false);
                settings.put (KEY_BRANCH, VALUE_COLOR);
                controller.setProblem (null);
            } else {
                settings.remove (KEY_BRANCH);
                food.setSelected (false);
                colors.setSelected (false);
                controller.setProblem ("Unacceptable!  You must decide!");
            }
            controller.setCanFinish(ae.getSource() != neither);
        }
    }    
  </pre>
  
  
  <h2>Design Philosophy</h2>
  This library is designed to make it as simple as possible to quickly create
  Wizards.  The following were guiding principles:
  
  <ul>
  <li>A Wizard shall not, under any circumstances, alter its environment
    until the user presses the Finish button</li>
  <li>A Wizard gathers ad-hoc settings from the user.  We will use the 
    simplest reasonable construct for this - a <code>java.util.Map</code>,
    which each pane of a wizard can populate with additional settings;
    each pane can see the settings of past (but not future, if the back
    button has been invoked) panes to decide if the Next or Finish buttons
    should be enabled.
  <li>The order of panes may be ad-hoc in some wizards;  each step of a 
    wizard shall be identified by a unique ID string, which is what will
    be used to tell the wizard what step it's on</li>
  <li>The actual GUI implementation of Wizards must be replaceable, so 
    applications can tune the appearance as they wish</li>
  <li>Most use cases for Wizards are quite simple, so we will do the maximum
   to make it possible to handle common cases with a minimum of code.</li>
  </ul>
  
  A Wizard is a series of steps.  Each step has a String ID.  The user of the
  API provides a factory for panels (UI components) which map to those IDs,
  and provides a localized name and descriptions for the steps.
  
  </body>
</html>
