# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common
# Development and Distribution License("CDDL") (collectively, the
# "License"). You may not use this file except in compliance with the
# License. You can obtain a copy of the License at
# http://www.netbeans.org/cddl-gplv2.html
# or nbbuild/licenses/CDDL-GPL-2-CP. See the License for the
# specific language governing permissions and limitations under the
# License.  When distributing the software, include this License Header
# Notice in each file and include the License file at
# nbbuild/licenses/CDDL-GPL-2-CP.  Sun designates this
# particular file as subject to the "Classpath" exception as provided
# by Sun in the GPL Version 2 section of the License file that
# accompanied this code. If applicable, add the following below the
# License Header, with the fields enclosed by brackets [] replaced by
# your own identifying information:
# "Portions Copyrighted [year] [name of copyright owner]"
#
# Contributor(s):
#
# The Original Software is NetBeans. The Initial Developer of the Original
# Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
# Microsystems, Inc. All Rights Reserved.
#
# If you wish your version of this file to be governed by only the CDDL
# or only the GPL Version 2, indicate your decision by adding
# "[Contributor] elects to include this software in this distribution
# under the [CDDL or GPL Version 2] license." If you do not indicate a
# single choice of license, a recipient has the option to distribute
# your version of this file under either the CDDL, the GPL Version 2 or
# to extend the choice of license to its licensees as provided above.
# However, if you add GPL Version 2 code and therefore, elected the GPL
# Version 2 license, then the option applies only if the new code is
# made subject to such option by the copyright holder.

# Scala.nbs
# @author Caoyuan Deng

#upper = ‘A’ | . . . | ‘Z’ | ‘$’ | ‘_’ and Unicode Lu
#lower = ‘a’ | . . . | ‘z’ and Unicode Ll
#letter = upper | lower and Unicode categories Lo, Lt, Nl
#digit = ‘0’ | . . . | ‘9’
#opchar = “all other characters in\u0020-007F and Unicode categories
#Sm, So except parentheses ([]) and periods”

## XML mode
<DEFAULT>:TOKEN:xml_element_start: ( 
    "<"  ["a"-"z" "A"-"Z" "?" "!"]["a"-"z" "A"-"Z" "0"-"9" "-" "_" ":"]* ):<IN_XML_ELEMENT>
<DEFAULT>:TOKEN:xml_end_element_start: (
    "</" ["a"-"z" "A"-"Z" "?" "!"]["a"-"z" "A"-"Z" "0"-"9" "-" "_" ":"]* ):<IN_XML_ELEMENT>

<IN_XML_ELEMENT> {
    TOKEN:xml_attribute_name: ( ["a"-"z" "A"-"Z"]["a"-"z" "A"-"Z" "0"-"9" "-" "_" ":"]* ):<IN_XML_ATTRIBUTE>
    TOKEN:whitespace: ( [" " "\t" "\n" "\r"]* )
    TOKEN:xml_element_end: ( "?"? ">" ):<DEFAULT>
    TOKEN:xml_end_element_end: ( "/>" ):<DEFAULT>
}

<IN_XML_ATTRIBUTE> {
    TOKEN:eq: ( "=" ):<IN_XML_ATTRIBUTE2>
    TOKEN:whitespace: ( [" " "\t" "\n" "\r"]* )
    TOKEN:xml_element_end: ( "?"? ">" ):<DEFAULT>
    TOKEN:xml_end_element_end: ( "/>" ):<DEFAULT>
    TOKEN:xml_attribute_name: ( [^ " " ">" "=" "\t" "\n" "\r"]+ )
}

<IN_XML_ATTRIBUTE2> {
    TOKEN:xml_attribute_value: ( 
        "\"" [^ "\"" "\n" "\r"]* "\"" |
        "\'" [^ "\'" "\n" "\r"]* "\'"
    ):<IN_XML_ELEMENT>
    TOKEN:xml_scala_expr: ( "{" - "}" ):<IN_XML_ELEMENT>
    TOKEN:whitespace: ( [" " "\t" "\n" "\r"]* )
}

TOKEN:xml_pi: (
    "<?" - "?>"
)
TOKEN:xml_comment: ( "<!--" - "-->" )
<DEFAULT>:TOKEN:cdsect_start: ( "<![CDATA[" ):<IN_CDSEC>
<IN_CDSEC> {
    TOKEN:cddata: ( [^"]"]+ )
    TOKEN:cddata: ( "]" [^">"] )
    TOKEN:cdsect_end: ( "]]>" ):<DEFAULT>
}


<DEFAULT>:TOKEN:comment: ( "/*" ):<IN_COMMENT>
<IN_COMMENT> {
    TOKEN:comment_keyword: (
        "@author" |
        "@deprecated" |
        "@exception" |
        "@param" |
        "@pre" |
        "@return" |
        "@see" |
        "@since" |
        "@throws" |
        "@todo" |
        "@version"
    )
    TOKEN:comment: ( "/*" ):<IN_COMMENT2>
    TOKEN:comment: ( "@" )
    TOKEN:comment: ( [^"@" "*" "/"]+ )
    TOKEN:comment: ( "*" [^"/" "*"]* )
    TOKEN:comment: ( "/" [^"*"]* )
    TOKEN:comment: {
        pattern:( "*/" );
        end_state:"DEFAULT";
#        end_state:"IN_COMMENT2";
    }
}

<IN_COMMENT2> {
    TOKEN:comment_keyword: (
        "@author" |
        "@deprecated" |
        "@exception" |
        "@param" |
        "@pre" |
        "@return" |
        "@see" |
        "@since" |
        "@throws" |
        "@todo" |
        "@version"
    )
    TOKEN:comment: ( "/*" ):<IN_COMMENT>
    TOKEN:comment: ( "@" )
    TOKEN:comment: ( [^"@" "*" "/"]+ )
    TOKEN:comment: ( "*" [^"/" "*"]* )
    TOKEN:comment: ( "/" [^"*"] )
    TOKEN:comment: ( "*/" ):<IN_COMMENT>
}

TOKEN:line_comment: ( "//" [^"\n" "\r"]* )


###### keywords
## abstract case catch class def
## do else extends false final
## finally for forSome if implicit
## import match new null object
## override package private protected requires
## return sealed super this throw
## trait try true type val
## var while with yield
## _ : = => <- <: <% >: # @
TOKEN:abstract: ( "abstract" )
TOKEN:case: ( "case" )
TOKEN:class: ( "class" )
TOKEN:def: ( "def" )
TOKEN:do: ( "do" )
TOKEN:false: ( "false" )
TOKEN:final: ( "final" )
TOKEN:for: ( "for" )
TOKEN:if: ( "if" )
TOKEN:implicit: ( "implicit" )
TOKEN:import: ( "import" )
TOKEN:lazy: ( "lazy" )
TOKEN:new: ( "new" )
TOKEN:null: ( "null" )
TOKEN:object: ( "object" )
TOKEN:override: ( "override" )
TOKEN:package: ( "package" )
TOKEN:private: ( "private" )
TOKEN:protected: ( "protected" )
TOKEN:return: ( "return" )
TOKEN:sealed: ( "sealed" )
TOKEN:super: ( "super" )
TOKEN:this: ( "this" )
TOKEN:throw: ( "throw" )
TOKEN:trait: ( "trait" )
TOKEN:try: ( "try" )
TOKEN:true: ( "true" )
TOKEN:type: ( "type" )
TOKEN:val: ( "val" )
TOKEN:var: ( "var" )
TOKEN:while: ( "while ")
TOKEN:at: ( "@" )

## The tokens that can terminate a statement are: literals, identifiers and the following
## delimiters and reserved words:
##     this null true false return type <xmlstart>
##     _ ) ] }
## A case token can begin a statement only
## That means: all keyword and delimiters except above should consume all followed [" " "\t" "\n" "\r"]*
## they are: 
## catch else extends finally forSome, match, requires, with, yield


## keywords II
## The tokens that can begin a statement are all Scala tokens except the following delimiters
## and reserved words: (<nl> before them should be consumed)
##     catch else extends finally forSome match requires with yield
##     , . ; : _ = => <- <: <% >: # [ ) ] }
## Notice: _ : = => <- <: <% >: # is also keyword
## That means: all keyword and delimiters above should consume all preceded [" " "\t" "\n" "\r"]*
TOKEN:catch: (
    "catch"
)
## Hacking for: [Semi] "else" in if expr, consume ";"
TOKEN:else: (
    "else"
)
TOKEN:extends: (
    "extends"
)
TOKEN:finally: (
    "finally"
)
TOKEN:forSome: (
    "forSome"
)
TOKEN:match: (
    "match"
)
TOKEN:requires: (
    "requires"
)
TOKEN:with: (
    "with"
)
TOKEN:yield: (
    "yield"
)
TOKEN:eq: (
    "="
)
TOKEN:colon: (
    ":"
)
TOKEN:hash: (
    "#"
)
## don't add [" " "\t" "\n" "\r"]* before "_", otherwise the "_" begin varid will not be scanned properly 
TOKEN:under: (
    "_"
)
TOKEN:rarrow: (
    "=>"
)
TOKEN:larrow: (
    "<-"
)
TOKEN:tlower: (
    "<:"
)
TOKEN:tupper: (
    ">:"
)
TOKEN:tview: (
    "<%"
)




## Operators
## add [" " "\t" "\n" "\r"]* before "=" leading operators to avoid conflict with <eq>
TOKEN:op_identifier: (
    ["!" "%" "&" "+" "-" "<" ">" "?" "\\" "^" "`" "|" "~" "*" ]
    ["!" "%" "&" "+" "-" "<" "=" ">" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/" "*"]* 
    |
    ["#" ":" "@"]
    ["!" "%" "&" "+" "-" "=" ">" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/" "*"]+ 
    |
    ["="]
    ["!" "%" "&" "+" "-" "<" "=" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/" "*"]+ 
    ["!" "%" "&" "+" "-" "<" "=" ">" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/" "*"]*
    |
    ["/"]
    ["!" "%" "&" "+" "-" "<" "=" ">" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/"]*
)

## separators
TOKEN:quote: (
    "\'"
)
TOKEN:lparen: (
    "("
)
## It seems safe to consume one <nl> before "{", since in most case, a [<nl>] is preceding of "{"
TOKEN:lbrace: (
    "{"
)
## Separator II
## Here, try to consume all <nl> before following separators, if there are comments 
## before them, the <nl> after comments should also be consumed by this regex
## @NOTICE: we can usally apply (<nl>)* after a separator or keyword in LL(k). But
##          It may not work if apply (<nl>)* before them, so it's better to solve 
##          these <nl> in token definition
TOKEN:rbrace: (
    "}"
)
TOKEN:rparen: (
    ")"
)
TOKEN:lbracket: (
    "["
)
TOKEN:rbracket: (
    "]"
)
TOKEN:semi: (
    ";"
)
TOKEN:dot: (
    "."
)
TOKEN:comma: (
    ","
)


### identifier
# upper = ‘A’ | . . . | ‘Z’ | ‘$’ | ‘_’ and Unicode Lu
# lower = ‘a’ | . . . | ‘z’ and Unicode Ll
# letter = upper | lower and Unicode categories Lo, Lt, Nl
# digit = ‘0’ | . . . | ‘9’
# opchar = “all other characters in\u0020-007F and Unicode categories Sm, So 
#          except parentheses ([]) and periods”
#   [^ "\u0000"-"\u001F" "[" "]" "(" ")" "."]
# op = opchar {opchar}
# idrest = {letter | digit} [‘_’ op]
#   (["a"-"z" "A"-"Z" "$" "_" "0"-"9"])* ("_" ([^ " " "\t" "\n" "\r" "[" "]" "(" ")" "," "." ";" "=" ":" "{" "}"])+)?
# varid: lower idrest
TOKEN:var_identifier: ( 
    ["a"-"z"] 
    ( ["a"-"z" "A"-"Z" "$" "_" "0"-"9"] )* ( "_" ( [^" " "\t" "\n" "\r" "[" "]" "(" ")" "," "." ";" "=" ":" "{" "}"] )+ )?
)
# upperid: upper idrest
TOKEN:upper_identifier: (
    ["_"]
    ( ["a"-"z" "A"-"Z" "$" "_" "0"-"9"])+ ( "_" ( [^" " "\t" "\n" "\r" "[" "]" "(" ")" ","  "." ";" "=" ":" "{" "}"] )+ )? 
    |
    ["A"-"Z" "$"] 
    ( ["a"-"z" "A"-"Z" "$" "_" "0"-"9"])* ( "_" ( [^" " "\t" "\n" "\r" "[" "]" "(" ")" ","  "." ";" "=" ":" "{" "}"] )+ )?
)
## Backquoted id
TOKEN:bquote_identifier: (
    "`" 
    ( 
        [^ "\\" "`" "\n" "\r"] |
        ( "\\" (
            . |
            ( ["0"-"7"] ["0"-"7"] ["0"-"7"] ) |
            ( "x" ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ) |
            ( "u" ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] )
        ) )
    )*
    "`"
)

TOKEN:symbol: (
    "\'"
    (
      ( ["a"-"z" "A"-"Z" "$" "_"] 
        ( ["a"-"z" "A"-"Z" "$" "_" "0"-"9"] )* ( "_" ( [^" " "\t" "\n" "\r" "[" "]" "(" ")" "," "." ";" "=" ":" "{" "}"] )+ )?
      )
      |
      ["!" "%" "&" "+" "-" "<" "=" ">" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/" "*"]+
    ) 
)

### Literal
TOKEN:string: (
    "\"" 
    ( 
        [^ "\\" "\"" "\n" "\r"] |
        ( "\\" (
            . |
            ( ["0"-"7"] ["0"-"7"] ["0"-"7"] ) |
            ( "x" ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ) |
            ( "u" ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] )
        ) )
    )* 
    "\""
)
TOKEN:string: (
    "\"\"\""
    ( ["\""]? ["\""]? [^"\""] |
      ( "\\" 
        ( . |
          ( ["0"-"7"] ["0"-"7"] ["0"-"7"]) |
          ( "x" ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ) |
          ( "u" ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] )
        )
      )
    )*
    "\"\"\""
)

TOKEN:char: (
    "\'" 
    ( [^ "\\" "\'" "\n" "\r"] |
      ( "\\" 
        ( . |
          ( ["0"-"7"] ["0"-"7"] ["0"-"7"] ) |
          ( "x" ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ) |
          ( "u" ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] )
        ) 
      )
    ) 
    "\'"
)

TOKEN:integer: (
    ["0"-"9"] ['l' 'L']? |
    ["1"-"9"] ["0"-"9"]* ['l' 'L']? |
    "0" ["0"-"7"]+ ['l' 'L']? |
    "0" ["x" "X"] ["0"-"9" "a"-"f" "A"-"F"]+ ['l' 'L']? 
)

## Hacking for: ["0"-"9"]+ "." ["0"-"9"]* ( ["e" "E"] ["+" "-"]? ["0"-"9"]+ )? ["f" "F" "d" "D"]? |
## In sepacial case, for example: 9.seconds, should be scanned as integer 9 followed by "."
## So, we write the regex as:
##    ["0"-"9"]+ "." [" " "\t"]+ |
##    ["0"-"9"]+ "." ["0"-"9"]+ ( ["e" "E"] ["+" "-"]? ["0"-"9"]+ )? ["f" "F" "d" "D"]? |
##    ["0"-"9"]+ "." ["e" "E"] ["+" "-"]? ["0"-"9"]+ ["f" "F" "d" "D"]? |
## "." must followed by float content, a "9." is scanned as float only when followed by whitespace
## @TODO "9." followed by <nl>: a float or may be an integer that can be followed by operator? 
TOKEN:float: (
    ["0"-"9"]+ "." [" " "\t"]+ |
    ["0"-"9"]+ "." ["0"-"9"]+ ( ["e" "E"] ["+" "-"]? ["0"-"9"]+ )? ["f" "F" "d" "D"]? |
    ["0"-"9"]+ "." ["e" "E"] ["+" "-"]? ["0"-"9"]+ ["f" "F" "d" "D"]? |
    "." ["0"-"9"]+ ( ["e" "E"] ["+" "-"]? ["0"-"9"]+ )? ["f" "F" "d" "D"]? |
    ["0"-"9"]+ ["e" "E"] ["+" "-"]? ["0"-"9"]+ ["f" "F" "d" "D"]? |
    ["0"-"9"]+ ( ["e" "E"] ["+" "-"]? ["0"-"9"]+ )? ["f" "F" "d" "D"]
)


TOKEN:nl: (
    ["\n" "\r"]+
)

TOKEN:whitespace:( 
    [" " "\t"]+ 
)


########## grammar #############################################################

SKIP:whitespace
SKIP:comment
SKIP:line_comment
SKIP:xml_comment
SKIP:comment_keyword
SKIP:nl

## CompilationUnit
S = TopStats;

Keyword = <abstract>
        | <case>
        | <class>
        | <def>
        | <do>
        | <false>
        | <final>
        | <for>
        | <if>
        | <implicit>
        | <import>
        | <lazy>
        | <new>
        | <null>
        | <object>
        | <override>
        | <package>
        | <private>
        | <protected>
        | <return>
        | <sealed>
        | <super>
        | <this>
        | <throw>
        | <trait>
        | <try>
        | <true>
        | <type>
        | <val>
        | <var>
        | <while>
        | <catch>
        | <else>
        | <extends>
        | <finally>
        | <forSome>
        | <match>
        | <requires>
        | <with>
        | <yield>;

PlainId = <upper_identifier>
        | <var_identifier>
        | <op_identifier>;

NameId = PlainId
       | <bquote_identifier>;

Literal = <integer>
        | <float>
        | <char>
        | <string>
        | <symbol>
        | <true> 
        | <false>
        | <null>;

QualId = NameId (<dot> NameId)*;

Ids = NameId (<comma> NameId)*;

## Hacking for: Path = StableId ["." "this"], since Path is also belongs to SimpleType etc
StableId = PathId (<dot> PathId)*;
PathId = NameId
       | <this>
       | <super> [ClassQualifier] <dot> NameId;
ClassQualifier = <lbracket> NameId <rbracket>;

## Hacking for: SimpleType = StableId ["." "type"] (TypeArgs | "#" NameId)*
##  "." "type" should only be in SimpleType, but since StableId may also belongs to SimpleType,
##  we cannot add any more "." "anything" behind StableId
TypeStableId = TypeId (<dot> TypeId)*;
TypeId = PathId
       | <under>
       | <type>;

Types = Type (<comma> Type)*;
Type = InfixType [<rarrow> Type | ExistentialClause];
## Hacking for:
#     | "(" <rarrow> Type ")" <rarrow> Type;
# @see SimpleType

ExistentialClause = <forSome> <lbrace> ExistentialDcl ([<semi>] ExistentialDcl)* <rbrace>;
ExistentialDcl = <type> NameId [TypeParamClause] [<tupper> Type] [<tlower> Type]
               | <val> Ids <colon> Type
               | ;

InfixType = CompoundType (NameId CompoundType)*;
CompoundType = AnnotType (<with> AnnotType)* [Refinement]
             | Refinement;
## Hacking for Ascription = <colon> (CompoundType | (Annotation)+);
## AnnotType actually should be AnnotType = (Annotation)* SimpleType ["*"]
AnnotType = SimpleType ["*"]
          | (Annotation)+ [SimpleType ["*"]];

SimpleType = TypeStableId (TypeArgs | <hash> NameId)*
           | <lparen> (Types1 | <rarrow> Type) <rparen> (TypeArgs | <hash> NameId)*;
## Hacking for: Type (<comma> Type)* [<comma>];
Types1 = Type1 (<comma> Type1)*;
Type1 = Type
      | ;
TypeArgs = <lbracket> Types <rbracket>;

Refinement = <lbrace> [RefineStat ([<semi>] RefineStat)*] <rbrace>;
RefineStat = DclDef 
           | ;

## Here we have to do a mixed hacking for various Expr:
## 1. Hacking for: Expr = (Bindings | id) ‘=>’ Expr | Expr1
##     Bindings = "(" Binding ("," Binding)* ")";
##     Binding = NameId [":" Type];
## Since 
##     CaseClause = "case" Pattern [Guard] "=>" CaseBlockStats; 
## where 
##     Guard = "if" PostfixExpr; 
## Thus we cannot add another ("=>" Expr) after an expr which level is lower than 
## or same as PostfixExpr
Expr = CtrlExpr
     | PostfixExpr [Ascription [FunExprTail] | MatchExprTail | AssignExprTail | FunExprTail];
## Hacking for: Ascription = <colon> (CompoundType | (Annotation)+); @see AnnotType
Ascription = <colon> (CompoundType);
## MatchExprTail, AssignExprTail is same for Expr, ExprInParen, ExprInTemplate, ExprInBlock, ExprInCaseBlock, 
## but FunExprTail may not 
MatchExprTail = <match> <lbrace> CaseClauses <rbrace>;
AssignExprTail = <eq> Expr;
FunExprTail = <rarrow> Expr;

CtrlExpr = IfExpr
         | WhileExpr
         | TryExpr
         | DoExpr
         | ForExpr
         | ThrowExpr
         | ReturnExpr;

IfExpr = <if> <lparen> Expr <rparen> Expr [<else> Expr];
WhileExpr = <while> <lparen> Expr <rparen> Expr;
TryExpr = <try> <lbrace> BlockStats <rbrace> [<catch> <lbrace> CaseClauses <rbrace>] [<finally> Expr];
DoExpr = <do> Expr [<semi>] <while> <lparen> Expr <rparen>;
ForExpr = <for> (<lparen> Enumerators <rparen> | <lbrace> Enumerators <rbrace>) [<yield>] Expr;
ThrowExpr = <throw> Expr;
ReturnExpr = <return> [Expr];


## Hacking for:
##     PostfixExpr = InfixExpr [NameId [<nl>]];
##     InfixExpr = PrefixExpr  (NameId [<nl>] InfixExpr)*;
## Should connect two exprs separated by <nl> to one expr when possible in semantic analyzer
#PostfixExpr = PrefixExpr (NameId [PrefixExpr])*;
#PrefixExpr = [PrefixOp] SimpleExpr;
#PrefixOp = "-" 
#         | "+" 
#         | "~" 
#         | "!";
PostfixExpr = (SimpleExpr)+;
PrefixExpr = [PrefixOp] SimpleExpr;
PrefixOp = "-" 
         | "+" 
         | "~" 
         | "!";

SimpleExpr = PathIdWithTypeArgs    (<dot> PathIdWithTypeArgs | Arguments | <under>)*
           | LiteralWithTypeArgs   (<dot> PathIdWithTypeArgs | Arguments | <under>)*
           | WildCardWithTypeArgs  (<dot> PathIdWithTypeArgs | Arguments | <under>)*
           | TupleExprWithTypeArgs (<dot> PathIdWithTypeArgs | Arguments | <under>)*
           | BlockExprWithTypeArgs (<dot> PathIdWithTypeArgs [Arguments])*
           | NewExpr               (<dot> PathIdWithTypeArgs | Arguments |  <under>)*
           | XmlExpr;

PathIdWithTypeArgs    = PathId    (TypeArgs)*;
LiteralWithTypeArgs   = Literal   (TypeArgs)*;
WildCardWithTypeArgs  = <under>   (TypeArgs)*;
TupleExprWithTypeArgs = TupleExpr (TypeArgs)*;
BlockExprWithTypeArgs = BlockExpr (TypeArgs)*;

TupleExpr = ParenExpr;

#TypedArguments = TypedWildCard
#               | TypedParenExpr
#               | TypedBlockExpr;


## Hacking for: "new" ([EarlyDef] ClassParents [Template] | Template)
## Since EalyBody and Template all start with "{" and Template is super set of EarlyBody,
## So, we have to use Template instead of EarlyBody
##    NewExpr = "new" [Block] AnnotType ClassTemplateBody [<dot> NameId];
##    ClassTemplateBody = (PrthsOrBlock ("with" AnnotType)* (TypeArgs)*)*;
##    ClassParents = AnnotType (Arguments)* ("with" AnnotType)*;
## A possible expr: NewExpr = "new" [Block] ClassParents (PrthsOrBlock (TypeArgs)*)* [<dot> NameId];
NewExpr = <new> (ClassParents [Template] | Template [ClassParents [Template]]) (TypeArgs)*;

Arguments = ParenExpr
          | BlockExpr;

## Hacking for: Prths = "(" [Expr ("," Expr)* [","]] ")";
## To let a optional [","] at the end, we just let PrthsExpr can be empty
## @NOTICE 
## Although "," is used to separator one expr, but, all <nl> in parenthsis should be ignor,
## so, we use (ExprInParen)+ here, and let ExprInParen include <nl>.
## ** Should combine them to one expr in semantic analyzer **
ParenExpr = <lparen> ExprInParen (<comma> ExprInParen)* <rparen>;
ExprInParen = CtrlExpr
            | PostfixExpr [AscriptionInParen [FunExprTail] | MatchExprTail | AssignExprTail | FunExprTail]
            | ;
## Hacking for: Ascription and Binding;
##     Ascription = ":" (CompoundType | (Annotation)+ | "_" "*")
##     Bindings = "(" Binding ("," Binding)* ")";
##     Binding = NameId [":" Type];
## Since (Bindings | id) ‘=>’ Expr also conflicts with (PostfixExpr Ascription "=>" Expr), 
## we have to combine them as: Ascription = ":" (Type | (Annotation)+);
## Hacking for: AscriptionInPrths = <colon> (Type | (Annotation)+); @see AnnotType
AscriptionInParen = <colon> (Type);

BlockExpr = <lbrace> (BlockStats | CaseClauses) <rbrace>;
Template = <lbrace> TemplateStats <rbrace> [<with>];

####### Blocked Statements: #############
TemplateStats = TemplateStat ([<semi>] TemplateStat)*;
TemplateStat = Import
             | DclDefInTemplate
             | ExprInTemplate
             | ;
DclDefInTemplate = (Annotation)* (Modifier)* (ValDclDef | VarDclDef | FunDclDef | TypeDclDef | TmplDef);
## Hacking for Template ::= [nl] ‘{’ [id [‘:’ Type] ‘=>’] TemplateStat {semi TemplateStat} ‘}’
## Where, [id [‘:’ Type] ‘=>’] conflicts with Expr
ExprInTemplate = CtrlExpr
               | PostfixExpr [Ascription [FunExprTailInTemplate] | MatchExprTail | AssignExprTail | FunExprTailInTemplate];
FunExprTailInTemplate = <rarrow> TemplateStats;

BlockStats = BlockStat ([<semi>] BlockStat)*;
BlockStat = Import
          | DclDefInBlock
          | ExprInBlock
          | ;
DclDefInBlock = [<implicit>] (ValDclDef | VarDclDef | FunDclDef | TypeDclDef)
              | (LocalModifier)* TmplDef;
## Hacking for: ResultExpr = (Bindings | NameId [":" CompoundType]) "=>" BlockStats;
## Where, the right part of "=>" is BlockStats vs Expr in anonynous function expression
ExprInBlock = CtrlExpr
            | PostfixExpr [Ascription [FunExprTailInBlock] | MatchExprTail | AssignExprTail | FunExprTailInBlock];
FunExprTailInBlock = <rarrow> BlockStats;

## Hacking for CaseClause BlockStats, where another "case" starting TmplDef maybe 
## recognized as a CaseClause in LL(k)
CaseBlockStats = CaseBlockStat ([<semi>] CaseBlockStat)*;
CaseBlockStat = Import
              | DclDefInCaseBlock
              | ExprInCaseBlock
              | ;
DclDefInCaseBlock = [<implicit>] (ValDclDef | VarDclDef | FunDclDef | TypeDclDef)
                  | (LocalModifier)+ TmplDef;
ExprInCaseBlock = CtrlExpr
                | PostfixExpr [Ascription [FunExprTailInCaseBlock] | MatchExprTail | AssignExprTail | FunExprTailInCaseBlock];
FunExprTailInCaseBlock = <rarrow> CaseBlockStats;

CaseClauses = CaseClause (CaseClause)*;
CaseClause = <case> CasePattern [Guard] <rarrow> CaseBlockStats;
Guard = <if> PostfixExpr;

## The old style for-comprehensions' generator: ["val"] Pattern1 "<-" Expr [Guard]; 
## has been depracated in Version 2.6 
#Enumerators = Generator ([<semi>] Enumerator)*;
#Generator = Pattern1 <larrow> Expr [Guard];
#Enumerator = Generator
#           | Guard
#           | ValDefInEnumerator
#           | ;
#ValDefInEnumerator = <val> Pattern1 <eq> Expr;
Enumerators = Generator ([<semi>] Enumerator)*;
Generator = Pattern1 (<larrow> Expr [Guard])+;
Enumerator = Generator
           | Guard
           | ValDefInEnumerator
           | ;
ValDefInEnumerator = <val> Pattern1 <eq> Expr;


XmlExpr = XmlElement (XmlElement)*
        | XmlCDSect  (XmlElement)*
        | <xml_pi>   (XmlElement)*;

XmlElement = <xml_element_start> (XmlAttribute)* (<xml_end_element_end> | <xml_element_end> (XmlContent)* XmlEndTag);

XmlEndTag = <xml_end_element_start> (XmlAttribute)* <xml_element_end>;
XmlAttribute = <xml_attribute_name> <eq> (<xml_attribute_value> | <xml_scala_expr>);

XmlCDSect = <cdsect_start> <cddata> <cdsect_end>;
XmlContent = XmlCharData
           | XmlElement
           | XmlCDSect
           | <xml_pi>
           | XmlScalaExpr;
XmlCharData = Literal
         | <var_identifier>
         | <upper_identifier>
         | <op_identifier>
         | <semi>
         | <lparen>
         | <rparen>
         | <lbracket>
         | <rbracket>
         | <larrow>
         | <rarrow>
         | <tlower>
         | <tupper>
         | <tview>
         | <at>
         | <eq>
         | <colon>
         | <dot>
         | <comma>
         | <hash>
         | <under>
         | <quote>
         | Keyword;
XmlScalaExpr = <lbrace> BlockStats <rbrace>;

Pattern = Pattern1 ("|" Pattern1)*
        | ;
Pattern1 = Pattern3;

## Hacking: used only by PatDef
Pattern2 = <under> ["*"]
         | Literal
         | StableId [<lparen> Patterns <rparen> | <at> Pattern3]
         | TuplePattern
         | XmlPattern;

## Hacking for neg number in Literal
Pattern3 = ["-"] SimplePattern (NameId ["-"] SimplePattern)*;
SimplePattern = <under> ["*"]
              | Literal
              | StableId [<lparen> Patterns <rparen> | <at> Pattern3 | <colon> Type]
              | TuplePattern
              | XmlPattern;

## Hacking for pattern in case clause:
## The only difference from Pattern for case clause is:
## we use (":" InfixType) rather than (":" Type). For example:
##     case rw: List[TemplateHolder] => rw
## where, (List[TemplateHolder] => rw) which is behind ":", may be parsed as a 
## function type rather then a (Type => Expr), so we here have to limit the Type to InfixType
CasePattern = CasePattern1 ("|" CasePattern1)*;
## Hacking for neg number in Literal
CasePattern1 = ["-"] CasePattern0 (NameId ["-"] CasePattern0)*;
CasePattern0 = <under> ["*"]
             | Literal
             | StableId [<lparen> Patterns <rparen> | <at> Pattern3 | <colon> InfixType]
             | TuplePattern
             | XmlPattern;

TuplePattern = <lparen> Patterns <rparen>;

XmlPattern = <xml_element_start> (XmlAttribute)* (<xml_end_element_end> | <xml_element_end> (XmlContentP)* XmlEndTag);
XmlContentP = XmlCharData
            | XmlPattern
            | XmlCDSect
            | <xml_pi>
            | XmlScalaPatterns;
XmlScalaPatterns = <lbrace> Patterns <rbrace>;

Patterns = Pattern (<comma> Pattern)*;


TypeParamClause = <lbracket> VariantTypeParam (<comma> VariantTypeParam)* <rbracket>;
VariantTypeParam = ["+" | "-"] TypeParam;

FunTypeParamClause = <lbracket> TypeParam (<comma> TypeParam)* <rbracket>;

## Hacking for TypeParam = NameId [">:" Type] ["<:" Type] ["<%" Type];
## Is the ScalaReference error? the following code is from examples.tcpoly.collection.HOSeq
##   trait Accumulator[+coll[x], elT] {...}
TypeParam = NameId [TypeParamClause] [<tupper> Type] [<tlower> Type] [<tview> Type];

Modifier = LocalModifier
         | AccessModifier
         | <override>;

LocalModifier = <abstract>
              | <final>
              | <sealed>
              | <implicit>
              | <lazy>;

AccessModifier = (<private> | <protected>) [AccessQualifier];
AccessQualifier = <lbracket> (NameId | <this>) <rbracket>;

Annotation = <at> AnnotationExpr;
## Hacking for AnnotationExpr = AnnotType (Arguments)* [<lbrace> (<nl>)* NameValuePair (<comma> (<nl>)* NameValuePair)* <rbrace>]
##     where Arguments and followed braced NameValuePair conflict
AnnotationExpr = AnnotType (ParenExpr)* [<lbrace> NameValuePair (<comma> NameValuePair)* <rbrace>];
NameValuePair = <val> NameId <eq> PrefixExpr;

Import = <import> ImportStat (<comma> ImportStat)*;
## Hacking for: ImportExpr = StableId "." (NameId | "_" | ImportSelectors);
ImportStat = ImportId;
ImportId = ImportId0 (<dot> ImportId0)*;
ImportId0 = NameId
          | <super> [ClassQualifier] <dot> NameId
          | <under>
          | ImportSelectors;
ImportSelectors = <lbrace> ImportSelector (<comma> ImportSelector)* <rbrace>;
ImportSelector = (NameId [<rarrow> (NameId | <under>)] | <under>);

## Hacking for TemplateStat: Dcl and Def all belongs to TemplateStat
DclDef = ValDclDef
       | VarDclDef
       | FunDclDef
       | TypeDclDef
       | TmplDef;
ValDclDef = <val> PatDef [<eq> Expr];
VarDclDef = <var> PatDef [<eq> Expr];
FunDclDef = <def> NameId [FunTypeParamClause] [ParamClauses] ([<colon> Type] [<eq> Expr] | <lbrace> BlockStats <rbrace>)
          | <def> <this> [ParamClauses] (<eq> ConstrExpr | ConstrBlock);
TypeDclDef = <type> NameId [TypeParamClause] ([<tupper> Type] [<tlower> Type] [<tview> Type] | <eq> Type);

PatDef = Pattern2 (<comma> Pattern2)* [<colon> Type] ;

ParamClauses = ParamClause (ParamClause)*;
ParamClause = <lparen> [[<implicit>] Params] <rparen>;
Params = Param (<comma> Param)*;
Param = (Annotation)* NameId [<colon> ParamType];
ParamType = Type ["*"]
          | <rarrow> Type;

ConstrExpr = SelfInvocation
           | ConstrBlock;
SelfInvocation = <this> (Arguments)+;
ConstrBlock = <lbrace> SelfInvocation ([<semi>] BlockStat)* <rbrace>;

TmplDef = ClassDef
        | ObjectDef
        | TraitDef;
ClassDef  = [<case>] <class> NameId [TypeParamClause] (Annotation)* [AccessModifier] ClassParamClauses            
            [<requires> AnnotType] [ClassTemplateOpt];
ObjectDef = [<case>] <object> NameId [ClassTemplateOpt];
TraitDef  = <trait> NameId [TypeParamClause] [<requires> AnnotType] [TraitTemplateOpt];

## Hacking for ClassParamClauses = (<lparen> (<nl>)* [ClassParams] (<nl>)* <rparen>)* [<lparen> (<nl>)* <implicit> ClassParams (<nl>)* <rparen>];
## Where:
##     ClassParam = (Annotation)* [(Modifier)* (<val> | <var>)] NameId [<colon> ParamType];
ClassParamClauses = (<lparen> [ClassParams] <rparen>)*;
ClassParams = ClassParam (<comma> ClassParam)*;
ClassParam = (Annotation)* (Modifier)* [(<val> | <var>)] NameId [<colon> ParamType];

ClassTemplateOpt = <extends> (ClassParents [Template] | Template [ClassParents [Template]])
                 | Template;
TraitTemplateOpt = <extends> (TraitParents [Template] | Template [TraitParents [Template]])
                 | Template;

ClassParents = AnnotType (ParenExpr)* (<with> AnnotType)*;
TraitParents = AnnotType (<with> AnnotType)*;

## Hacking for: [<nl>] Template
## Since Semi (which is ";" | <nl>) is separator between TopStat, we can not add [<nl>] Template at
## the end of ClassDef etc, instead, we have to let Template also be a TopStats
TopStats = TopStat ([<semi>] TopStat)*;
TopStat = TopTmplDef
        | Import
        | Packaging
        | ;

TopTmplDef = (Annotation)* (Modifier)* TmplDef;
Packaging = <package> QualId [<lbrace> TopStats <rbrace>];

#AST {
#    process:org.netbeans.modules.scala.editing.semantic.ScalaSemanticAnalyser.process;
#}


#SYNTAX_ERROR:Expr: {
#    token_identifier:";";
#    nt:"Expr";
#}

########### CODE FOLDING #######################################################
FOLD:ClassDef:{
    fold_display_name: "Class: $NameId$";
}

FOLD:TraitDef:{
    fold_display_name: "Trait: $NameId$";
}

FOLD:ObjectDef:{
    fold_display_name: "Object: $NameId$";
}

FOLD:FunDclDef:{
    fold_display_name: "Function: $NameId$";
}

#FOLD:MethodDeclaration:{
#    fold_display_name: "Methos: $MethodName$";
#}
#FOLD:block:"{...}"


########## NAVIGATOR ###########################################################
NAVIGATOR:ClassDef: {
    display_name: "$NameId$";
    icon: "/org/netbeans/modules/languages/resources/class.gif";
}

NAVIGATOR:TraitDef: {
    display_name: "$NameId$";
    icon: "/org/netbeans/modules/languages/resources/class.gif";
}

NAVIGATOR:ObjectDef: {
    display_name: "$NameId$";
    icon: "/org/netbeans/modules/languages/resources/class.gif";
}

NAVIGATOR:FunDclDef: {
    display_name: "$NameId$$FunTypeParamClause$$ParamClauses$ $colon$$Type$";
    icon: "/org/netbeans/modules/languages/resources/method.gif";
}

NAVIGATOR:TypeDclDef: {
    display_name: "$NameId$";
    icon: "/org/netbeans/modules/languages/resources/variable.gif";
}

NAVIGATOR:TemplateStat.DclDef.ValDclDef: {
    display_name: "$PatDef$";
    icon: "/org/netbeans/modules/languages/resources/variable.gif";
}

NAVIGATOR:TemplateStat.DclDef.VarDclDef: {
    display_name: "$PatDef$";
    icon: "/org/netbeans/modules/languages/resources/variable.gif";
}

NAVIGATOR:CaseClause: {
    display_name: "case $CasePattern$";
    icon: "/org/netbeans/modules/languages/resources/method.gif";
}


MARK:ERROR: {
    type:"Error";
    message:"LBL_SYNTAX_ERROR";
}

MARK:error: {
    type:"Error";
    message:"LBL_UNEXPECTED_CHARACTER";
}

########### colors #############################################################
COLOR:
abstract,
case,
class,
def,
do,
false,
final,
for,
if,
implicit,
import,
lazy,
new,
null,
object,
override,
package,
private,
protected,
return,
sealed,
super,
this,
throw,
trait,
try,
true,
type,
val,
var,
while,
catch,
else,
extends,
finally,
forSome,
match,
requires,
with,
yield,
at,
eq,
colon,
rarrow,
larrow,
tlower,
tupper,
tview: 
{
    foreground_color: "0x0000FE";
}

COLOR:SimpleType, TypeParam.NameId: {
#    foreground_color: "0x2E92C7";
#    foreground_color: "0xA020F0";
#    foreground_color: "0xB8860B";
    foreground_color: "0x000000";
    font_type: "bold";
}

COLOR:ObjectDef.NameId: {
#    foreground_color: "0xB8860B";
    foreground_color: "0x000000";
    font_type: "italics-bold";
}

COLOR:ClassDef.NameId, TraitDef.NameId, TypeDclDef.NameId: {
#    foreground_color: "0xB8860B";
    foreground_color: "0x000000";
    font_type: "bold";
}

COLOR:FunDclDef.NameId: {
#    foreground_color: "0x9966ff";
#    foreground_color: "0x5F9EA0";
#    foreground_color: "0x2E92C7";
#    foreground_color: "0xB8860B";
    foreground_color: "0x000000";
#    foreground_color: "0xA020F0";
    font_type: "bold";
#    underline_color: "0x000000";
}

COLOR:PostfixExpr.NameId, PrefixExpr.PrefixOp: {
#    foreground_color: "0x9966ff";
#    foreground_color: "0x5F9EA0";
    foreground_color: "0x2E92C7";
#    foreground_color: "0xB8860B";
#    foreground_color: "0x000000";
#    foreground_color: "0xA020F0";
#    font_type: "bold";
}

COLOR:integer,float: {
    foreground_color: "0x780000";
}

COLOR:string,char: {
    foreground_color: "0xCE7B00";
}

COLOR:comment,line_comment,xml_comment: {
    foreground_color: "0x737373";
    #defualt_coloring: "comment";
}

COLOR:comment_keyword: {
    foreground_color: "0x737373";
    font_type:"bold";
}

COLOR:xml_element_start,xml_end_element_start,xml_element_end,xml_end_element_end: {
    foreground_color: "0x228B22";
}

########### complete and indentation ########################################################
COMPLETE "(:)"
COMPLETE "{:}"
COMPLETE "\":\""
COMPLETE "':'"
COMPLETE "[:]"

######## Brace matching
BRACE "{:}"
BRACE "(:)"
BRACE "[:]"
BRACE "\":\""

INDENT "(:)"
INDENT "{:}"
INDENT "[:]"
INDENT ".*(((=|=>|yield)\\s*))"
INDENT "\\s*(((if|while)\\s*\\(|else\\s*|else\\s+if\\s*\\()[^{;]*)"
#INDENT "\\s*(def|val|var|type).*=\\s*"
#INDENT "\\s*for\\s*\\(.*\\)\\s*yield\\s*"


#INDENT "(:)"
#INDENT "{:}"
#INDENT "[:]"
#INDENT ".*(((object|=)\\s*)[^;,]*)"
#INDENT "\\s*(((if|while)\\s*\\(|else\\s*|else\\s+if\\s*\\(|for\\s*\\(.*\\))[^{;]*)"

BUNDLE "org.netbeans.modules.scala.editing.resources.Bundle"

SELECTION ( ["a"-"z" "A"-"Z" "0"-"9" "_" "$"] )

COMMENT_LINE {
    prefix:"//";
}

COMPLETION:var_identifier, upper_identifier, op_identifier, keyword, separator, comment, whitespace, nl: {
    text1:org.netbeans.modules.scala.editing.Scala.completionItems;
    confirmChars:";(,.";
}

COMPLETION:dot: {
    text1:org.netbeans.modules.scala.editing.Scala.completionItems;
    type: "append";
    confirmChars:";(,.";
}

COMPLETION:colon: {
    text1:org.netbeans.modules.scala.editing.Scala.completionItems;
    type: "append";
    confirmChars:";(,.";
}
