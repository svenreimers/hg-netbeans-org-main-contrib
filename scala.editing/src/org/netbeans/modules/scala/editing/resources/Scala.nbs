# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common
# Development and Distribution License("CDDL") (collectively, the
# "License"). You may not use this file except in compliance with the
# License. You can obtain a copy of the License at
# http://www.netbeans.org/cddl-gplv2.html
# or nbbuild/licenses/CDDL-GPL-2-CP. See the License for the
# specific language governing permissions and limitations under the
# License.  When distributing the software, include this License Header
# Notice in each file and include the License file at
# nbbuild/licenses/CDDL-GPL-2-CP.  Sun designates this
# particular file as subject to the "Classpath" exception as provided
# by Sun in the GPL Version 2 section of the License file that
# accompanied this code. If applicable, add the following below the
# License Header, with the fields enclosed by brackets [] replaced by
# your own identifying information:
# "Portions Copyrighted [year] [name of copyright owner]"
#
# Contributor(s):
#
# The Original Software is NetBeans. The Initial Developer of the Original
# Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
# Microsystems, Inc. All Rights Reserved.
#
# If you wish your version of this file to be governed by only the CDDL
# or only the GPL Version 2, indicate your decision by adding
# "[Contributor] elects to include this software in this distribution
# under the [CDDL or GPL Version 2] license." If you do not indicate a
# single choice of license, a recipient has the option to distribute
# your version of this file under either the CDDL, the GPL Version 2 or
# to extend the choice of license to its licensees as provided above.
# However, if you add GPL Version 2 code and therefore, elected the GPL
# Version 2 license, then the option applies only if the new code is
# made subject to such option by the copyright holder.

# Scala.nbs
# @author Caoyuan Deng

#upper = ‘A’ | . . . | ‘Z’ | ‘$’ | ‘_’ and Unicode Lu
#lower = ‘a’ | . . . | ‘z’ and Unicode Ll
#letter = upper | lower and Unicode categories Lo, Lt, Nl
#digit = ‘0’ | . . . | ‘9’
#opchar = “all other characters in\u0020-007F and Unicode categories
#Sm, So except parentheses ([]) and periods”

## XML mode
<DEFAULT>:
TOKEN:xml_element_start: ( 
      "<"  [ "a"-"z" "A"-"Z" ] [ "a"-"z" "A"-"Z" "0"-"9" "-" "_" ":" ]* 
):<IN_XML_ELEMENT>

<IN_XML_ELEMENT> {
      TOKEN:xml_attribute_name: ( [ "a"-"z" "A"-"Z" ] [ "a"-"z" "A"-"Z" "0"-"9" "-" "_" ":" ]* ):<IN_XML_ATTRIBUTE>
      TOKEN:whitespace: ( [ " " "\t" "\n" "\r" ]* )
      TOKEN:xml_element_end: ( ">" ):<DEFAULT> # <IN_XML_CONTENT>
      TOKEN:xml_end_element_end: ( "/>" ):<DEFAULT>
}

<IN_XML_ATTRIBUTE> {
      TOKEN:xml_eq: ( "=" ):<IN_XML_ATTRIBUTE_VALUE>
      TOKEN:whitespace: ( [ " " "\t" "\n" "\r" ]* )
      TOKEN:xml_attribute_name: ( [ "a"-"z" "A"-"Z" ] [ "a"-"z" "A"-"Z" "0"-"9" "-" "_" ":" ]* )
      TOKEN:xml_element_end: ( ">" ):<DEFAULT> # <IN_XML_CONTENT>
      TOKEN:xml_end_element_end: ( "/>" ):<DEFAULT>
}

<IN_XML_ATTRIBUTE_VALUE> {
      TOKEN:xml_attribute_value: ( 
            "\"" [^ "\"" "\n" "\r" ]* "\"" 
          | "\'" [^ "\'" "\n" "\r" ]* "\'"
      ):<IN_XML_ATTRIBUTE>
      TOKEN:xml_scala_expr: ( "{" - "}" ):<IN_XML_ATTRIBUTE>
      TOKEN:whitespace: ( [" " "\t" "\n" "\r"]* )
}

#<IN_XML_CONTENT> {
#      TOKEN:xml_pcdata: ( [^ ">" "<" ]* )
#      TOKEN:xml_element_start: ( 
#            "<"  [ "a"-"z" "A"-"Z" "?" "!" ] [ "a"-"z" "A"-"Z" "0"-"9" "-" "_" ":" ]* 
#      ):<IN_XML_ELEMENT>
#      TOKEN:xml_end_element_start: (
#            "</" [ "a"-"z" "A"-"Z" "?" "!" ] [ "a"-"z" "A"-"Z" "0"-"9" "-" "_" ":" ]* 
#      ):<IN_XML_END_ELEMENT>
#}

# <IN_XML_CONTENT>
<DEFAULT>:
TOKEN:xml_end_element_start: (
      "</" [ "a"-"z" "A"-"Z" ] [ "a"-"z" "A"-"Z" "0"-"9" "-" "_" ":" ]* 
):<IN_XML_END_ELEMENT>

<IN_XML_END_ELEMENT> {
      TOKEN:xml_attribute_name: ( [ "a"-"z" "A"-"Z" ] [ "a"-"z" "A"-"Z" "0"-"9" "-" "_" ":" ]* )
      TOKEN:whitespace: ( [ " " "\t" "\n" "\r" ]* )
      TOKEN:xml_element_end: ( ">" ):<DEFAULT>
}

TOKEN:xml_pi: (
      "<?" - "?>"
)

TOKEN:xml_comment: ( "<!--" - "-->" )

# <IN_XML_CONTENT>
<DEFAULT>:
TOKEN:xml_cdsect_start: ( "<![CDATA[" ):<IN_XML_CDSEC>

<IN_XML_CDSEC> {
      TOKEN:xml_cddata: ( [^ "]" ]+ )
      TOKEN:xml_cddata: ( "]" [^ ">" ] )
      TOKEN:xml_cdsect_end: ( "]]>" ):<DEFAULT> # <IN_XML_CONTENT>
}

<DEFAULT>:
TOKEN:comment: ( "/*" ):<IN_COMMENT>

<IN_COMMENT> {
      TOKEN:comment_keyword: (
            "@author" 
          | "@deprecated"
          | "@exception" 
          | "@param" 
          | "@pre" 
          | "@return"
          | "@see" 
          | "@since" 
          | "@throws" 
          | "@todo" 
          | "@version"
      )
      TOKEN:comment: ( "/*" ):<IN_COMMENT2>
      TOKEN:comment: ( "@" )
      TOKEN:comment: ( [^ "@" "*" "/" ]+ )
      TOKEN:comment: ( "*" [^ "/" "*" ]* )
      TOKEN:comment: ( "/" [^ "*" ]* )
      TOKEN:comment: {
          pattern:( "*/" );
          end_state:"DEFAULT";
#        end_state:"IN_COMMENT2";
    }
}

<IN_COMMENT2> {
      TOKEN:comment_keyword: (
            "@author" 
          | "@deprecated"
          | "@exception" 
          | "@param" 
          | "@pre" 
          | "@return"
          | "@see" 
          | "@since" 
          | "@throws" 
          | "@todo" 
          | "@version"
      )
      TOKEN:comment: ( "/*" ):<IN_COMMENT>
      TOKEN:comment: ( "@" )
      TOKEN:comment: ( [^ "@" "*" "/" ]+ )
      TOKEN:comment: ( "*" [^ "/" "*" ]* )
      TOKEN:comment: ( "/" [^ "*" ] )
      TOKEN:comment: ( "*/" ):<IN_COMMENT>
}

TOKEN:line_comment: ( "//" [^ "\n" "\r" ]* )


## The tokens that can terminate a statement are: literals, identifiers and the following
## delimiters and reserved words:
##     this null true false return type <xmlstart>
##     _ ) ] }
## A case token can begin a statement only
## That means: all keyword and delimiters except above should consume all followed [" " "\t" "\n" "\r"]*
## they are: 
## catch else extends finally forSome, match, requires, with, yield

## The tokens that can begin a statement are all Scala tokens except the following delimiters
## and reserved words: (<nl> before them should be consumed)
##     catch else extends finally forSome match requires with yield
##     , . ; : _ = => <- <: <% >: # [ ) ] }
## Notice: _ : = => <- <: <% >: # is also keyword
## That means: all keyword and delimiters above should consume all preceded [" " "\t" "\n" "\r"]*

###### keywords
## abstract case catch class def
## do else extends false final
## finally for forSome if implicit
## import match new null object
## override package private protected requires
## return sealed super this throw
## trait try true type val
## var while with yield
## _ : = => <- <: <% >: # @
TOKEN:keyword: (
      "abstract" 
    | "case" 
    | "catch" 
    | "class" 
    | "def" 
    | "do" 
    | "else" 
    | "extends" 
    | "false" 
    | "final" 
    | "finally" 
    | "for" 
    | "forSome" 
    | "if" 
    | "implicit" 
    | "import" 
    | "lazy" 
    | "match" 
    | "new" 
    | "null" 
    | "object" 
    | "override" 
    | "package" 
    | "private" 
    | "protected" 
    | "requires" 
    | "return" 
    | "sealed"
    | "super"
    | "this"
    | "throw" 
    | "trait" 
    | "try" 
    | "true" 
    | "type" 
    | "val" 
    | "var" 
    | "while" 
    | "with" 
    | "yield" 
    | "_" 
    | ":" 
    | "=" 
    | "=>" 
    | "<-" 
    | "<:"
    | "<%"
    | ">:"
    | "#"
    | "@" 
)



## Operators
TOKEN:op_identifier: (
      [ "!" "%" "&" "+" "-" "<"     ">" "?"     "\\" "^" "`" "|" "~"             "*" ]
      [ "!" "%" "&" "+" "-" "<" "=" ">" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/" "*" ]* 
    | [ "#" ":" "@" ]
      [ "!" "%" "&" "+" "-"     "=" ">" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/" "*" ]+ 
    | [ "=" ]
      [ "!" "%" "&" "+" "-" "<" "="     "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/" "*" ]+ 
      [ "!" "%" "&" "+" "-" "<" "=" ">" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/" "*" ]*
    | [ "/"]
      [ "!" "%" "&" "+" "-" "<" "=" ">" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/"     ]*
)

## Separators
TOKEN:separator: (
      "{" | "}" | "(" | ")" |"[" | "]"
    | ";" | "." | ","
)

### identifier
# upper = ‘A’ | . . . | ‘Z’ | ‘$’ | ‘_’ and Unicode Lu
# lower = ‘a’ | . . . | ‘z’ and Unicode Ll
# letter = upper | lower and Unicode categories Lo, Lt, Nl
# digit = ‘0’ | . . . | ‘9’
# opchar = “all other characters in\u0020-007F and Unicode categories Sm, So 
#          except parentheses ([]) and periods”
#   [^ "\u0000"-"\u001F" "[" "]" "(" ")" "."]
# op = opchar {opchar}
# idrest = {letter | digit} [‘_’ op]
#   (["a"-"z" "A"-"Z" "$" "_" "0"-"9"])* ("_" ([^ " " "\t" "\n" "\r" "[" "]" "(" ")" "," "." ";" "=" ":" "{" "}"])+)?
# varid: lower idrest
TOKEN:var_identifier: ( 
      [ "a"-"z" ] 
      [ "a"-"z" "A"-"Z" "$" "_" "0"-"9" ]* ( "_" [^ " " "\t" "\n" "\r" "[" "]" "(" ")" "," "." ";" "=" ":" "{" "}" ]+ )?
)
# upperid: upper idrest
TOKEN:upper_identifier: (
      [ "_" ]
      [ "a"-"z" "A"-"Z" "$" "_" "0"-"9" ]+ ( "_" [^ " " "\t" "\n" "\r" "[" "]" "(" ")" ","  "." ";" "=" ":" "{" "}" ]+ )? 
    | [ "A"-"Z" "$" ] 
      [ "a"-"z" "A"-"Z" "$" "_" "0"-"9" ]* ( "_" [^ " " "\t" "\n" "\r" "[" "]" "(" ")" ","  "." ";" "=" ":" "{" "}" ]+ )?
)
## Backquoted id
TOKEN:bquote_identifier: (
      "`" 
      ( [^ "\\" "`" "\n" "\r" ] 
      | ( "\\" 
          ( . 
          | ( [ "0"-"7" ] [ "0"-"7" ] [ "0"-"7" ] ) 
          | ( "x" [ "0"-"9" "a"-"f" "A"-"F" ] [ "0"-"9" "a"-"f" "A"-"F" ] ) 
          | ( "u" [ "0"-"9" "a"-"f" "A"-"F" ] [ "0"-"9" "a"-"f" "A"-"F" ] [ "0"-"9" "a"-"f" "A"-"F" ] [ "0"-"9" "a"-"f" "A"-"F" ] )
          ) 
        )
      )*
      "`"
)

TOKEN:symbol: (
      "\'"
      ( ( [ "a"-"z" "A"-"Z" "$" "_" ] 
          [ "a"-"z" "A"-"Z" "$" "_" "0"-"9" ]* ( "_" [^ " " "\t" "\n" "\r" "[" "]" "(" ")" "," "." ";" "=" ":" "{" "}" ]+ )?
        )
      | [ "!" "%" "&" "+" "-" "<" "=" ">" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/" "*" ]+
      ) 
)

TOKEN:string: (
      "\"" 
      ( [^ "\\" "\"" "\n" "\r" ] 
      | ( "\\" 
          ( . 
          | ( [ "0"-"7" ] [ "0"-"7" ] [ "0"-"7" ] ) 
          | ( "x" [ "0"-"9" "a"-"f" "A"-"F" ] [ "0"-"9" "a"-"f" "A"-"F" ] ) 
          | ( "u" [ "0"-"9" "a"-"f" "A"-"F" ] [ "0"-"9" "a"-"f" "A"-"F" ] [ "0"-"9" "a"-"f" "A"-"F" ] [ "0"-"9" "a"-"f" "A"-"F" ] )
          ) 
        )
      )* 
      "\""
)
TOKEN:string: (
      "\"\"\""
      ( [ "\"" ]? [ "\"" ]? [^ "\"" ] 
      | ( "\\" 
          ( . 
          | ( [ "0"-"7" ] [ "0"-"7" ] [ "0"-"7" ] ) 
          | ( "x" [ "0"-"9" "a"-"f" "A"-"F" ] [ "0"-"9" "a"-"f" "A"-"F" ] ) 
          | ( "u" [ "0"-"9" "a"-"f" "A"-"F" ] [ "0"-"9" "a"-"f" "A"-"F" ] [ "0"-"9" "a"-"f" "A"-"F" ] [ "0"-"9" "a"-"f" "A"-"F" ] )
          )
        )
      )*
      "\"\"\""
)

TOKEN:char: (
      "\'" 
      ( [^ "\\" "\'" "\n" "\r" ] 
      | ( "\\" 
          ( . 
          | ( [ "0"-"7" ] [ "0"-"7" ] [ "0"-"7" ] )
          | ( "x" [ "0"-"9" "a"-"f" "A"-"F" ] [ "0"-"9" "a"-"f" "A"-"F" ] ) 
          | ( "u" [ "0"-"9" "a"-"f" "A"-"F" ] [ "0"-"9" "a"-"f" "A"-"F" ] [ "0"-"9" "a"-"f" "A"-"F" ] [ "0"-"9" "a"-"f" "A"-"F" ] )
          ) 
        )
      ) 
      "\'"
)

TOKEN:integer: (
      [ "0"-"9" ] [ 'l' 'L' ]? 
    | [ "1"-"9" ] [ "0"-"9" ]* [ 'l' 'L' ]? 
    | "0" [ "0"-"7" ]+ [ 'l' 'L' ]? 
    | "0" [ "x" "X" ] [ "0"-"9" "a"-"f" "A"-"F" ]+ [ 'l' 'L' ]? 
)

## Hacking for: ["0"-"9"]+ "." ["0"-"9"]* ( ["e" "E"] ["+" "-"]? ["0"-"9"]+ )? ["f" "F" "d" "D"]? |
## In sepacial case, for example: 9.seconds, should be scanned as integer 9 followed by "."
## So, we write the regex as:
##    ["0"-"9"]+ "." [" " "\t"]+ |
##    ["0"-"9"]+ "." ["0"-"9"]+ ( ["e" "E"] ["+" "-"]? ["0"-"9"]+ )? ["f" "F" "d" "D"]? |
##    ["0"-"9"]+ "." ["e" "E"] ["+" "-"]? ["0"-"9"]+ ["f" "F" "d" "D"]? |
## "." must followed by float content, a "9." is scanned as float only when followed by whitespace
## @TODO "9." followed by <nl>: a float or may be an integer that can be followed by operator? 
TOKEN:float: (
      [ "0"-"9" ]+ "." [ " " "\t" ]+ 
    | [ "0"-"9" ]+ "." [ "0"-"9" ]+ ( [ "e" "E" ] [ "+" "-" ]? [ "0"-"9" ]+ )? [ "f" "F" "d" "D" ]? 
    | [ "0"-"9" ]+ "."              ( [ "e" "E" ] [ "+" "-" ]? [ "0"-"9" ]+ )  [ "f" "F" "d" "D" ]? 
    |              "." [ "0"-"9" ]+ ( [ "e" "E" ] [ "+" "-" ]? [ "0"-"9" ]+ )? [ "f" "F" "d" "D" ]? 
    | [ "0"-"9" ]+                  ( [ "e" "E" ] [ "+" "-" ]? [ "0"-"9" ]+ )  [ "f" "F" "d" "D" ]? 
    | [ "0"-"9" ]+                  ( [ "e" "E" ] [ "+" "-" ]? [ "0"-"9" ]+ )? [ "f" "F" "d" "D" ]
)


TOKEN:nl: (
      [ "\n" "\r" ]+
)

TOKEN:whitespace: ( 
      [ " " "\t" ]+ 
)


########## grammar #############################################################

SKIP:whitespace
SKIP:comment
SKIP:line_comment
SKIP:xml_comment
SKIP:comment_keyword
SKIP:nl

## CompilationUnit
S = TopStats;

## PlainId is not used yet, just keep it here for future:
# PlainId = <upper_identifier>
#        | <var_identifier>
#        | <op_identifier>;

ScalaId = 
      <upper_identifier>
    | <var_identifier>
    | <op_identifier>
    | <bquote_identifier>;

Literal = 
      <integer>
    | <float>
    | <char>
    | <string>
    | <symbol>
    | "true" 
    | "false"
    | "null";

QualId = ScalaId ( "." ScalaId )*;

Ids = ScalaId ( "," ScalaId )*;

StableId = PathId ( "." PathId )*;

## Hacking for: Path = StableId ["." "this"], since Path is also belongs to SimpleType etc
PathId = 
      ScalaId
    | "this"
    | "super" [ ClassQualifier ] "." ScalaId;

ClassQualifier = "[" ScalaId "]";

Type = 
      InfixType 
      [ "=>" Type 
      | ExistentialClause 
      ];
## Hacking for:
#     | "(" <rarrow> Type ")" <rarrow> Type;
# @see SimpleType

ExistentialClause = "forSome" "{" ExistentialDcl ( [ ";" ] ExistentialDcl )* "}";

ExistentialDcl =
      "type" ScalaId [ TypeParamClause ] [ ">:" Type ] [ "<:" Type ]
    | "val" Ids ":" Type
    | ;

InfixType = CompoundType ( ScalaId CompoundType )*;

CompoundType = 
      AnnotType ("with" AnnotType)* [ Refinement ]
    | Refinement;

## Hacking for Ascription = <colon> (CompoundType | (Annotation)+);
## AnnotType actually should be AnnotType = (Annotation)* SimpleType ["*"]
AnnotType = 
      SimpleType [ "*" ]
    | Annotation+ [ SimpleType [ "*" ] ];

## Hacking for: Type ("," Type)* [","]:
##              Type ("," [Type])*
SimpleType = 
      TypeStableId ( TypeArgs | "#" ScalaId )*
    | "(" 
      [ Type ( "," [ Type ] )* 
      | "=>" Type
      ] 
      ")" ( TypeArgs | "#" ScalaId )*;

TypeStableId = TypeId ( "." TypeId )*;

TypeId = 
      PathId
    | "_"
    | "type";

TypeArgs = "[" Types "]";

Types = Type ( "," Type )*;

Refinement = "{" [RefineStat ( [ ";" ] RefineStat )*] "}";

RefineStat = 
      DclDef 
    | ;

## Here we have to do a mixed hacking for various Expr:
## 1. Hacking for: Expr = (Bindings | id) ‘=>’ Expr | Expr1
##     Bindings = "(" Binding ("," Binding)* ")";
##     Binding = ScalaId [":" Type];
## Since 
##     CaseClause = "case" Pattern [Guard] "=>" CaseBlockStats; 
## where 
##     Guard = "if" PostfixExpr; 
## Thus we cannot add another ("=>" Expr) after an expr which level is lower than 
## or same as PostfixExpr
Expr = 
      CtrlExpr
    | PostfixExpr 
      [ Ascription [ FunExprTail ] 
      | MatchExprTail 
      | AssignExprTail 
      | FunExprTail
      ];

## Hacking for: Ascription = <colon> (CompoundType | (Annotation)+); @see AnnotType
Ascription = ":" CompoundType;

## MatchExprTail, AssignExprTail is same for Expr, ExprInParen, ExprInTemplate, ExprInBlock, ExprInCaseBlock, 
## but FunExprTail may not 
MatchExprTail = "match" "{" CaseClauses "}";

AssignExprTail = "=" Expr;

FunExprTail = "=>" Expr;

CtrlExpr = 
      IfExpr
    | WhileExpr
    | TryExpr
    | DoExpr
    | ForExpr
    | ThrowExpr
    | ReturnExpr;

IfExpr = "if" "(" Expr ")" Expr [ "else" Expr ];
WhileExpr = "while" "(" Expr ")" Expr;
TryExpr = "try" "{" BlockStats "}" ["catch" "{" CaseClauses "}"] [ "finally" Expr ];
DoExpr = "do" Expr [ ";" ] "while" "(" Expr ")";
ForExpr = "for" ( "(" Enumerators ")" | "{" Enumerators "}" ) [ "yield" ] Expr;
ThrowExpr = "throw" Expr;
ReturnExpr = "return" [ Expr ];


## Hacking for:
##     PostfixExpr = InfixExpr [ScalaId [<nl>]];
##     InfixExpr = PrefixExpr  (ScalaId [<nl>] InfixExpr)*;
#PostfixExpr = PrefixExpr (ScalaId [PrefixExpr])*;
#PrefixExpr = [PrefixOp] SimpleExpr;
#PrefixOp = "-" 
#         | "+" 
#         | "~" 
#         | "!";
## Can't write as: PostfixExpr = (PrefixExpr)+;
## Otherwise, the "nl+" will be broken.
##       val semi = nl+
##
## Should connect two exprs separated by <nl> to one expr when possible in semantic analyzer,
## The rule could be: if encounter a ScalaId and followed only one <nl>, then next SimpleExpr 
## is of the same Expr

#PostfixExpr = InfixExpr;
#InfixExpr = 
#      PrefixExpr
#    (
#    | ( LOOKAHEAD( ( <upper_identifier> | <var_identifier> | <op_identifier> | <bquote_identifier> )  ( "." | "(" | "[" ) ) 
#        PrefixExpr )*
#      ( ScalaId [ PrefixExpr ] )*
#    );
#PrefixExpr = [ PrefixOp ] SimpleExpr;

PostfixExpr = SimpleExpr+;
#InfixExpr = PrefixExpr ( ScalaId [ PrefixExpr ] )*;
PrefixExpr  = [ PrefixOp ] SimpleExpr;

PrefixOp =
      "-"
    | "+" 
    | "~" 
    | "!";

SimpleExpr = 
      SimplePathIdExpr
    | SimpleLiteralExpr
    | SimpleWildCardExpr
    | SimpleTupleExpr
    | SimpleBlockExpr
    | SimpleNewExpr
    | XmlExpr;

## Why following rules conflict under LL(k) when k >= 2
#SimpleExpr = 
#      SimpleScalaId
#    | SimplePathIdExpr
#    | ...;
#SimpleScalaId      = ScalaId;
#SimplePathIdExpr   = PathId  ( TypeArgs SimpleExprRest* | SimpleExprRest+ );


SimplePathIdExpr   = PathId    [ TypeArgs ] SimpleExprRest*;
SimpleLiteralExpr  = Literal   [ TypeArgs ] SimpleExprRest*;
SimpleWildCardExpr = "_"       [ TypeArgs ] SimpleExprRest*;
SimpleTupleExpr    = ParenExpr [ TypeArgs ] SimpleExprRest*;
SimpleBlockExpr    = BlockExpr [ TypeArgs ] SimpleExprRest*;
SimpleNewExpr      = NewExpr   [ TypeArgs ] SimpleExprRest*;

SimpleExprRest = 
      PathRest
    | Arguments+
    | "_";

## Define this intermedia expr for convenience of semantic anlysis
PathRest = ( "." PathId [ TypeArgs ] )+;

## Hacking for: "new" ([EarlyDef] ClassParents [Template] | Template)
## Since EalyBody and Template all start with "{" and Template is super set of EarlyBody,
## So, we have to use Template instead of EarlyBody
##    NewExpr = "new" [Block] AnnotType ClassTemplateBody [<dot> ScalaId];
##    ClassTemplateBody = (PrthsOrBlock ("with" AnnotType)* (TypeArgs)*)*;
##    ClassParents = AnnotType (Arguments)* ("with" AnnotType)*;
## A possible expr: NewExpr = "new" [Block] ClassParents (PrthsOrBlock (TypeArgs)*)* [<dot> ScalaId];
NewExpr = 
      "new" 
      ( ClassParents [ Template ] 
      | Template [ ClassParents [ Template ] ] 
      );

Arguments = 
        ParenExpr
      | BlockExpr;

ParenExpr = "(" [ ExprInParen ( "," [ ExprInParen ] )* ] ")";

ExprInParen = 
      CtrlExpr
    | PostfixExpr 
      [ AscriptionInParen [ FunExprTail ] 
      | MatchExprTail 
      | AssignExprTail 
      | FunExprTail 
      ];

## Hacking for: Ascription and Binding;
##     Ascription = ":" (CompoundType | (Annotation)+ | "_" "*")
##     Bindings = "(" Binding ("," Binding)* ")";
##     Binding = ScalaId [":" Type];
## Since (Bindings | id) ‘=>’ Expr also conflicts with (PostfixExpr Ascription "=>" Expr), 
## we have to combine them as: Ascription = ":" (Type | (Annotation)+);
## Hacking for: AscriptionInPrths = <colon> (Type | (Annotation)+); @see AnnotType
AscriptionInParen = ":" Type;

BlockExpr = "{" ( BlockStats | CaseClauses ) "}";

Template = "{" TemplateStats "}" [ "with" ];

####### Blocked Statements: #############
TemplateStats = TemplateStat ( [ ";" ] TemplateStat )*;

TemplateStat = 
      Import
    | DclDefInTemplate
    | ExprInTemplate
    | ;

DclDefInTemplate = 
      Annotation* Modifier* 
      ( ValDclDef 
      | VarDclDef 
      | FunDclDef 
      | TypeDclDef 
      | TmplDef 
      );

## Hacking for Template ::= [nl] ‘{’ [id [‘:’ Type] ‘=>’] TemplateStat {semi TemplateStat} ‘}’
## Where, [id [‘:’ Type] ‘=>’] conflicts with Expr
ExprInTemplate = 
      CtrlExpr
    | PostfixExpr 
      [ Ascription [ FunExprTailInTemplate ] 
      | MatchExprTail 
      | AssignExprTail 
      | FunExprTailInTemplate 
      ];

FunExprTailInTemplate = "=>" TemplateStats;

BlockStats = BlockStat ( [ ";" ] BlockStat )*;

BlockStat = 
      Import
    | DclDefInBlock
    | ExprInBlock
    | ;

DclDefInBlock = 
      LocalModifier*
      ( ValDclDef 
      | VarDclDef 
      | FunDclDef 
      | TypeDclDef
      | TmplDef
      );

#DclDefInBlock = 
#      [ "implicit" ] 
#      ( ValDclDef 
#      | VarDclDef 
#      | FunDclDef 
#      | TypeDclDef
#      )
#    | LocalModifier* TmplDef;

## Hacking for: ResultExpr = (Bindings | ScalaId [":" CompoundType]) "=>" BlockStats;
## Where, the right part of "=>" is BlockStats vs Expr in anonynous function expression
ExprInBlock = 
      CtrlExpr
    | PostfixExpr 
      [ Ascription [ FunExprTailInBlock ] 
      | MatchExprTail 
      | AssignExprTail 
      | FunExprTailInBlock 
      ];

FunExprTailInBlock = "=>" BlockStats;

## Hacking for CaseClause BlockStats, where another "case" starting TmplDef maybe 
## recognized as a CaseClause in LL(k)
CaseBlockStats = CaseBlockStat ( [ ";" ] CaseBlockStat )*;

CaseBlockStat = 
      Import
    | DclDefInCaseBlock
    | ExprInCaseBlock
    | ;

DclDefInCaseBlock = 
      [ "implicit" ] 
      ( ValDclDef 
      | VarDclDef 
      | FunDclDef 
      | TypeDclDef 
      )
    | (LocalModifier)+ TmplDef;

ExprInCaseBlock = 
      CtrlExpr
    | PostfixExpr 
      [ Ascription [ FunExprTailInCaseBlock ] 
      | MatchExprTail 
      | AssignExprTail 
      | FunExprTailInCaseBlock 
      ];

FunExprTailInCaseBlock = "=>" CaseBlockStats;

CaseClauses = CaseClause CaseClause*;

CaseClause = "case" CasePattern [ Guard ] "=>" CaseBlockStats;

Guard = "if" PostfixExpr;

## The old style for-comprehensions' generator: ["val"] Pattern1 "<-" Expr [Guard]; 
## has been depracated in Version 2.6 
#Enumerators = Generator ([<semi>] Enumerator)*;
#Generator = Pattern1 <larrow> Expr [Guard];
#Enumerator = Generator
#           | Guard
#           | ValDefInEnumerator
#           | ;
#ValDefInEnumerator = <val> Pattern1 <eq> Expr;
Enumerators = Generator ( [ ";" ] Enumerator )*;

Generator = Pattern1 ( "<-" Expr [ Guard ] )+;

Enumerator = 
      Generator
    | Guard
    | ValDefInEnumerator
    | ;

ValDefInEnumerator = "val" Pattern1 "=" Expr;


XmlExpr = 
      XmlElement XmlElement*
    | XmlCDSect  XmlElement*
    | <xml_pi>   XmlElement*;

XmlElement = <xml_element_start> XmlAttribute* ( <xml_end_element_end> | <xml_element_end> XmlContent* XmlEndTag );

XmlEndTag = <xml_end_element_start> XmlAttribute* <xml_element_end>;

XmlAttribute = <xml_attribute_name> <xml_eq> (<xml_attribute_value> | <xml_scala_expr>);

XmlCDSect = <xml_cdsect_start> <xml_cddata> <xml_cdsect_end>;

XmlContent = 
      XmlCharData
    | XmlElement
    | XmlCDSect
    | <xml_pi>
    | XmlScalaExpr;

XmlCharData = 
      Literal
    | <var_identifier>
    | <upper_identifier>
    | <op_identifier>
    | <separator>
    | <keyword>;

XmlScalaExpr = "{" BlockStats "}";

Pattern = 
      Pattern1 ( "|" Pattern1 )*
      | ;

Pattern1 = Pattern3;

## Hacking: used only by PatDef
Pattern2 = 
      "_" [ "*" ]
    | Literal
    | StableId [ "(" Patterns ")" | "@" Pattern3 ]
    | TuplePattern
    | XmlPattern;

## Hacking for neg number in Literal
Pattern3 = [ "-" ] SimplePattern ( ScalaId [ "-" ] SimplePattern )*;

SimplePattern = 
      "_" [ "*" ] [ ":" Type ]
    | Literal
    | StableId ["(" Patterns ")" | "@" Pattern3 | ":" Type]
    | TuplePattern
    | XmlPattern;

## Hacking for pattern in case clause:
## The only difference from Pattern for case clause is:
## we use (":" InfixType) rather than (":" Type). For example:
##     case rw: List[TemplateHolder] => rw
## where, (List[TemplateHolder] => rw) which is behind ":", may be parsed as a 
## function type rather then a (Type => Expr), so we here have to limit the Type to InfixType
CasePattern = CasePattern1 ( "|" CasePattern1 )*;

## Hacking for neg number in Literal
CasePattern1 = [ "-" ] CasePattern0 ( ScalaId [ "-" ] CasePattern0 )*;

CasePattern0 = 
      "_" [ "*" ] [ ":" InfixType ]
    | Literal
    | StableId [ "(" Patterns ")" | "@" Pattern3 | ":" InfixType ]
    | TuplePattern
    | XmlPattern;

TuplePattern = "(" Patterns ")";

XmlPattern = <xml_element_start> XmlAttribute* (<xml_end_element_end> | <xml_element_end> XmlContentP* XmlEndTag);
XmlContentP = 
      XmlCharData
    | XmlPattern
    | XmlCDSect
    | <xml_pi>
    | XmlScalaPatterns;

XmlScalaPatterns = "{" Patterns "}";

Patterns = Pattern ( "," Pattern )*;


TypeParamClause = "[" VariantTypeParam ( "," VariantTypeParam )* "]";

VariantTypeParam = [ "+" | "-" ] TypeParam;

FunTypeParamClause = "[" TypeParam ( "," TypeParam )* "]";

## Hacking for TypeParam = ScalaId [">:" Type] ["<:" Type] ["<%" Type];
## Is the ScalaReference error? the following code is from examples.tcpoly.collection.HOSeq
##   trait Accumulator[+coll[x], elT] {...}
TypeParam = ScalaId [ TypeParamClause ] [ ">:" Type ] [ "<:" Type ] [ "<%" Type ];

Modifier = 
      LocalModifier
    | AccessModifier
    | "override";

LocalModifier = 
      "abstract"
    | "final"
    | "sealed"
    | "implicit"
    | "lazy";

AccessModifier = ( "private" | "protected" ) [ AccessQualifier ];
AccessQualifier = "[" ( ScalaId | "this" ) "]";

Annotation = "@" AnnotationExpr;
## Hacking for AnnotationExpr = AnnotType (Arguments)* [<lbrace> (<nl>)* NameValuePair (<comma> (<nl>)* NameValuePair)* <rbrace>]
##     where Arguments and followed braced NameValuePair conflict
AnnotationExpr = AnnotType ParenExpr* [ "{" NameValuePair ( "," NameValuePair )* "}" ];
NameValuePair = "val" ScalaId "=" PrefixExpr;

Import = "import" ImportStat ( "," ImportStat )*;
## Hacking for: ImportExpr = StableId "." (ScalaId | "_" | ImportSelectors);
ImportStat = ImportId;
ImportId = ImportId0 ( "." ImportId0 )*;
ImportId0 = 
      ScalaId
    | "super" [ ClassQualifier ] "." ScalaId
    | "_"
    | ImportSelectors;

ImportSelectors = "{" ImportSelector ( "," ImportSelector )* "}";
ImportSelector = ( ScalaId [ "=>" ( ScalaId | "_" ) ] | "_" );

## Hacking for TemplateStat: Dcl and Def all belongs to TemplateStat
DclDef = 
      ValDclDef
    | VarDclDef
    | FunDclDef
    | TypeDclDef
    | TmplDef;

ValDclDef = "val" PatDef [ "=" Expr ];

VarDclDef = "var" PatDef [ "=" Expr ];

FunDclDef = 
      "def" ScalaId [ FunTypeParamClause ] [ ParamClauses ] 
      ( [ ":" Type ] [ "=" Expr ] 
      | "{" BlockStats "}" 
      )
    | "def" "this" [ParamClauses] 
      ( "=" ConstrExpr 
      | ConstrBlock 
      );

TypeDclDef = 
      "type" ScalaId [ TypeParamClause ] 
      ( [ ">:" Type ] [ "<:" Type ] [ "<%" Type ] 
      | "=" Type 
      );

PatDef = Pattern2 ( "," Pattern2 )* [ ":" Type ] ;

ParamClauses = ParamClause ParamClause*;
ParamClause = "(" [ [ "implicit" ] Params ] ")";
Params = Param ( "," Param )*;
Param = Annotation* ScalaId [ ":" ParamType ];
ParamType = 
      Type [ "*" ]
    | "=>" Type;

ConstrExpr = 
      SelfInvocation
    | ConstrBlock;

SelfInvocation = "this" Arguments+;
ConstrBlock = "{" SelfInvocation ( [ ";" ] BlockStat )* "}";

TmplDef = 
    ClassDef
  | ObjectDef
  | TraitDef;

ClassDef = 
      [ "case"] "class" ScalaId [ TypeParamClause ] Annotation* [ AccessModifier ] ClassParamClauses            
      [ "requires" AnnotType ] [ ClassTemplateOpt ];

ObjectDef = 
      [ "case" ] "object" ScalaId [ ClassTemplateOpt ];

TraitDef  = 
      "trait" ScalaId [ TypeParamClause ] [ "requires" AnnotType ] [ TraitTemplateOpt ];

## Hacking for ClassParamClauses = (<lparen> (<nl>)* [ClassParams] (<nl>)* <rparen>)* [<lparen> (<nl>)* <implicit> ClassParams (<nl>)* <rparen>];
## Where:
##     ClassParam = (Annotation)* [(Modifier)* (<val> | <var>)] ScalaId [<colon> ParamType];
ClassParamClauses = ( "(" [ ClassParams ] ")" )*;
ClassParams = ClassParam ( "," ClassParam )*;
ClassParam = Annotation* Modifier* [ ( "val" | "var" ) ] ScalaId [ ":" ParamType ];

ClassTemplateOpt = 
      "extends" 
      ( ClassParents [ Template ] 
      | Template [ ClassParents [ Template ] ] 
      )
    | Template;

TraitTemplateOpt = 
      "extends" 
      ( TraitParents [ Template ] 
      | Template [ TraitParents [ Template ] ]
      )
    | Template;

ClassParents = AnnotType ParenExpr* ( "with" AnnotType )*;
TraitParents = AnnotType ( "with" AnnotType )*;

## Hacking for: [<nl>] Template
## Since Semi (which is ";" | <nl>) is separator between TopStat, we can not add [<nl>] Template at
## the end of ClassDef etc, instead, we have to let Template also be a TopStats
TopStats = TopStat ( [ ";" ] TopStat )*;
TopStat = 
      TopTmplDef
    | Import
    | Packaging
    | ;

TopTmplDef = Annotation* Modifier* TmplDef;
Packaging = "package" QualId [ "{" TopStats "}" ];

#AST {
#    process:org.netbeans.modules.scala.editing.semantic.ScalaSemanticAnalyser.process;
#}


#SYNTAX_ERROR:Expr: {
#    token_identifier:";";
#    nt:"Expr";
#}

########### CODE FOLDING #######################################################
FOLD:ClassDef:{
    fold_display_name: "Class: $ScalaId$";
}

FOLD:TraitDef:{
    fold_display_name: "Trait: $ScalaId$";
}

FOLD:ObjectDef:{
    fold_display_name: "Object: $ScalaId$";
}

FOLD:FunDclDef:{
    fold_display_name: "Function: $ScalaId$";
}

#FOLD:MethodDeclaration:{
#    fold_display_name: "Methos: $MethodName$";
#}
#FOLD:block:"{...}"


########## NAVIGATOR ###########################################################
NAVIGATOR:ClassDef: {
    display_name: "$ScalaId$";
    icon: "/org/netbeans/modules/languages/resources/class.gif";
}

NAVIGATOR:TraitDef: {
    display_name: "$ScalaId$";
    icon: "/org/netbeans/modules/languages/resources/class.gif";
}

NAVIGATOR:ObjectDef: {
    display_name: "$ScalaId$";
    icon: "/org/netbeans/modules/languages/resources/class.gif";
}

NAVIGATOR:FunDclDef: {
    display_name: "$ScalaId$$FunTypeParamClause$$ParamClauses$ $colon$$Type$";
    icon: "/org/netbeans/modules/languages/resources/method.gif";
}

NAVIGATOR:TypeDclDef: {
    display_name: "$ScalaId$";
    icon: "/org/netbeans/modules/languages/resources/variable.gif";
}

NAVIGATOR:TemplateStat.DclDef.ValDclDef: {
    display_name: "$PatDef$";
    icon: "/org/netbeans/modules/languages/resources/variable.gif";
}

NAVIGATOR:TemplateStat.DclDef.VarDclDef: {
    display_name: "$PatDef$";
    icon: "/org/netbeans/modules/languages/resources/variable.gif";
}

NAVIGATOR:CaseClause: {
    display_name: "case $CasePattern$";
    icon: "/org/netbeans/modules/languages/resources/method.gif";
}


MARK:ERROR: {
    type:"Error";
    message:"LBL_SYNTAX_ERROR";
}

MARK:error: {
    type:"Error";
    message:"LBL_UNEXPECTED_CHARACTER";
}

########### colors ##############################################################
## http://ui.netbeans.org/docs/ui/editor_fonts_colors/Editor_fonts_and_colors.htm
COLOR:keyword: {
    foreground_color: "0x0000E6";
}

COLOR:SimpleType, TypeParam.ScalaId: {
#    foreground_color: "0x2E92C7";
#    foreground_color: "0xA020F0";
#    foreground_color: "0xB8860B";
    foreground_color: "0x000000";
    font_type: "bold";
}

COLOR:ObjectDef.ScalaId: {
#    foreground_color: "0xB8860B";
    foreground_color: "0x000000";
    font_type: "italics-bold";
}

COLOR:ClassDef.ScalaId, TraitDef.ScalaId, TypeDclDef.ScalaId: {
#    foreground_color: "0xB8860B";
    foreground_color: "0x000000";
    font_type: "bold";
}

COLOR:FunDclDef.ScalaId: {
#    foreground_color: "0x9966ff";
#    foreground_color: "0x5F9EA0";
#    foreground_color: "0x2E92C7";
#    foreground_color: "0xB8860B";
    foreground_color: "0x000000";
#    foreground_color: "0xA020F0";
    font_type: "bold";
#    underline_color: "0x000000";
}

COLOR:ValDclDef.PatDef.Pattern2.StableId.PathId.ScalaId, ValDefInEnumerator.Pattern1.Pattern3.StableId.PathId.ScalaId, NameValuePair.ScalaId: {
    foreground_color: "0x009B00";
}

COLOR:VarDclDef.PatDef.Pattern2.StableId.PathId.ScalaId: {
    foreground_color: "0x009B00";
    font_type: "bold";
}


COLOR:PostfixExpr.ScalaId, PrefixExpr.PrefixOp: {
#    foreground_color: "0x9966ff";
#    foreground_color: "0x5F9EA0";
    foreground_color: "0x2E92C7";
#    foreground_color: "0xB8860B";
#    foreground_color: "0x000000";
#    foreground_color: "0xA020F0";
#    font_type: "bold";
}

COLOR:integer,float: {
    foreground_color: "0x780000";
}

COLOR:string,char: {
    foreground_color: "0xCE7B00";
}

COLOR:comment,line_comment,xml_comment: {
    foreground_color: "0x737373";
    #defualt_coloring: "comment";
}

COLOR:comment_keyword: {
    foreground_color: "0x737373";
    font_type:"bold";
}

COLOR:xml_element_start,xml_end_element_start,xml_element_end,xml_end_element_end: {
    foreground_color: "0x9933CC";
}

########### complete and indentation ########################################################
COMPLETE "(:)"
COMPLETE "{:}"
COMPLETE "\":\""
COMPLETE "':'"
COMPLETE "[:]"

######## Brace matching
BRACE "{:}"
BRACE "(:)"
BRACE "[:]"
BRACE "\":\""

INDENT "(:)"
INDENT "{:}"
INDENT "[:]"
INDENT ".*(((=|=>|yield)\\s*))"
INDENT "\\s*(((if|while)\\s*\\(|else\\s*|else\\s+if\\s*\\()[^{;]*)"
#INDENT "\\s*(def|val|var|type).*=\\s*"
#INDENT "\\s*for\\s*\\(.*\\)\\s*yield\\s*"


#INDENT "(:)"
#INDENT "{:}"
#INDENT "[:]"
#INDENT ".*(((object|=)\\s*)[^;,]*)"
#INDENT "\\s*(((if|while)\\s*\\(|else\\s*|else\\s+if\\s*\\(|for\\s*\\(.*\\))[^{;]*)"

BUNDLE "org.netbeans.modules.scala.editing.resources.Bundle"

SELECTION ( ["a"-"z" "A"-"Z" "0"-"9" "_" "$"] )

COMMENT_LINE {
    prefix:"//";
}

COMPLETION:var_identifier, upper_identifier, op_identifier, keyword, separator, comment, whitespace, nl: {
    text1:org.netbeans.modules.scala.editing.Scala.completionItems;
    confirmChars:";(,.";
}

COMPLETION:dot: {
    text1:org.netbeans.modules.scala.editing.Scala.completionItems;
    type: "append";
    confirmChars:";(,.";
}

COMPLETION:colon: {
    text1:org.netbeans.modules.scala.editing.Scala.completionItems;
    type: "append";
    confirmChars:";(,.";
}
