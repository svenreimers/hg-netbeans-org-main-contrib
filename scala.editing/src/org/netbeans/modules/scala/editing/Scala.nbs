# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common
# Development and Distribution License("CDDL") (collectively, the
# "License"). You may not use this file except in compliance with the
# License. You can obtain a copy of the License at
# http://www.netbeans.org/cddl-gplv2.html
# or nbbuild/licenses/CDDL-GPL-2-CP. See the License for the
# specific language governing permissions and limitations under the
# License.  When distributing the software, include this License Header
# Notice in each file and include the License file at
# nbbuild/licenses/CDDL-GPL-2-CP.  Sun designates this
# particular file as subject to the "Classpath" exception as provided
# by Sun in the GPL Version 2 section of the License file that
# accompanied this code. If applicable, add the following below the
# License Header, with the fields enclosed by brackets [] replaced by
# your own identifying information:
# "Portions Copyrighted [year] [name of copyright owner]"
#
# Contributor(s):
#
# The Original Software is NetBeans. The Initial Developer of the Original
# Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
# Microsystems, Inc. All Rights Reserved.
#
# If you wish your version of this file to be governed by only the CDDL
# or only the GPL Version 2, indicate your decision by adding
# "[Contributor] elects to include this software in this distribution
# under the [CDDL or GPL Version 2] license." If you do not indicate a
# single choice of license, a recipient has the option to distribute
# your version of this file under either the CDDL, the GPL Version 2 or
# to extend the choice of license to its licensees as provided above.
# However, if you add GPL Version 2 code and therefore, elected the GPL
# Version 2 license, then the option applies only if the new code is
# made subject to such option by the copyright holder.

# Scala.nbs
# @author Caoyuan Deng

#upper = ‘A’ | . . . | ‘Z’ | ‘$’ | ‘_’ and Unicode Lu
#lower = ‘a’ | . . . | ‘z’ and Unicode Ll
#letter = upper | lower and Unicode categories Lo, Lt, Nl
#digit = ‘0’ | . . . | ‘9’
#opchar = “all other characters in\u0020-007F and Unicode categories
#Sm, So except parentheses ([]) and periods”

TOKEN:element_start: (
    "<"  ["a"-"z" "A"-"Z" "!" "?"]["a"-"z" "A"-"Z" "0"-"9" "-" "_" ":"]*
)
TOKEN:end_element: (
    "</" ["a"-"z" "A"-"Z" "!" "?"]["a"-"z" "A"-"Z" "0"-"9" "-" "_" ":"]* ">"
)
TOKEN:pi: (
    "<?" - "?>"
)
TOKEN:xml_comment: ("<!--" - "-->")
<DEFAULT>:TOKEN:cdsect_start: ("<![CDATA["):<IN_CDSEC>
<IN_CDSEC> {
    TOKEN:cddata: ([^"]"]+)
    TOKEN:cddata: ("]" [^">"])
    TOKEN:cdsect_end: ("]>"):<DEFAULT>
}

#TOKEN:xml: (
#    "<"  ["a"-"z" "A"-"Z"]["a"-"z" "A"-"Z" "0"-"9" "-" "_" ":"]* [^">"]* "/>" |
#    "<"  ["a"-"z" "A"-"Z"]["a"-"z" "A"-"Z" "0"-"9" "-" "_" ":"]* [^">"]* ">" 
#    [^">"]* 
#    "<"  ["a"-"z" "A"-"Z"]["a"-"z" "A"-"Z" "0"-"9" "-" "_" ":"]* [^">"]* "/>"
#)



<DEFAULT>:TOKEN:comment: ("/*"):<IN_COMMENT>
<IN_COMMENT> {
    TOKEN:comment_keyword: (
        "@author" |
        "@deprecated" |
        "@exception" |
        "@param" |
        "@pre" |
        "@return" |
        "@see" |
        "@since" |
        "@throws" |
        "@todo" |
        "@version"
    )
    TOKEN:comment: ("@")
    TOKEN:comment: ([^"@" "*"]+)
    TOKEN:comment: ("*" [^"/"])
    TOKEN:comment: ("*/"):<DEFAULT>
}

TOKEN:line_comment: ("//" [^"\n" "\r"]*)


###### keywords
## abstract case catch class def
## do else extends false final
## finally for forSome if implicit
## import match new null object
## override package private protected requires
## return sealed super this throw
## trait try true type val
## var while with yield
## _ : = => <- <: <% >: # @
TOKEN:keyword: ( 
    "abstract" |
    "case" |
    "class" |
    "def" |
    "do" |
    "false" |
    "final" |
    "for" |
    "if" |
    "implicit" |
    "import" |
    "lazy" |
    "new" |
    "null" |
    "object" |
    "override" |
    "package" |
    "private" |
    "protected" |
    "return" |
    "sealed" |
    "super" |
    "this" |
    "throw" |
    "trait" |
    "try" |
    "true" |
    "type" |
    "val" |
    "var" |
    "while" |
    "_" | "<-" | "<:" | "<%" | ">:" | "#" | "@"
)
TOKEN:colon: (
   ":"
)

## The tokens that can terminate a statement are: literals, identifiers and the following
## delimiters and reserved words:
##     this null true false return type <xmlstart>
##     _ ) ] }
## A case token can begin a statement only
## That means: all keyword and delimiters except above should eat all followed [" " "\t" "\n" "\r"]*
## they are: 
## catch else extends finally forSome, match, requires, with, yield


## keywords II
## The tokens that can begin a statement are all Scala tokens except the following delimiters
## and reserved words: (<nl> before them should be eaten)
##     catch else extends finally forSome match requires with yield
##     , . ; : _ = => <- <: <% >: # [ ) ] }
## Notice: _ : = => <- <: <% >: # is also keyword
## That means: all keyword and delimiters above should eat all preceded [" " "\t" "\n" "\r"]*
TOKEN:catch: (
    [" " "\t" "\n" "\r"]* "catch"
)
TOKEN:else: (
    [" " "\t" "\n" "\r"]* "else"
)
TOKEN:extends: (
    [" " "\t" "\n" "\r"]* "extends"
)
TOKEN:finally: (
    [" " "\t" "\n" "\r"]* "finally"
)
TOKEN:forSome: (
    [" " "\t" "\n" "\r"]* "forSome"
)
TOKEN:match: (
    [" " "\t" "\n" "\r"]* "match"
)
TOKEN:requires: (
    [" " "\t" "\n" "\r"]* "requires"
)
TOKEN:with: (
    [" " "\t" "\n" "\r"]* "with"
)
TOKEN:yield: (
    [" " "\t" "\n" "\r"]* "yield" [" " "\t" "\n" "\r"]*
)
TOKEN:eq: (
    "=" [" " "\t" "\n" "\r"]*
)
TOKEN:rarrow: (
    [" " "\t" "\n" "\r"]* "=>" [" " "\t" "\n" "\r"]* 
)

## Operators
TOKEN:operator: (
    ["!" "%" "&" "+" "-" "<" "?" "\\" "^" "`" "|" "~" "*" ]
    ["!" "%" "&" "+" "-" "<" "=" ">" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/" "*"]* 
    |
    ["#" ":" "@"]
    ["!" "%" "&" "+" "-" "<" "=" ">" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/" "*"]+ 
    |
    ["="]
    ["!" "%" "&" "+" "-" "<" "=" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/" "*"]+ 
    ["!" "%" "&" "+" "-" "<" "=" ">" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/" "*"]*
    |
    ["/"]
    ["!" "%" "&" "+" "-" "<" "=" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/"]*
)
## Hacking for xml
TOKEN:rangle: (
    ">"  ["!" "%" "&" "+" "-" "=" ">" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/" "*"]*
)
TOKEN:slashrangle: (
    "/>" ["!" "%" "&" "+" "-" "=" ">" "?" "@" "\\" "^" "`" "|" "~" "#" ":" "/" "*"]*
)

## separators
TOKEN:separator: (
    "[" | "]" | "(" | ")" | ";"
)
TOKEN:lcurly: (
    "{"
)
TOKEN:rcurly: (
    "}"
)
## Here, try to eat all <nl> before following separators, if there are comments 
## before them, the <nl> after comments should also be eaten by this regex
## @NOTICE: we can usally apply (<nl>)* after a separator or keyword in LL(k). But
##          It may not work if apply (<nl>)* before them, so it's better to solve 
##          these <nl> in token definition
TOKEN:dot: (
    [" " "\t" "\n" "\r"]* "."
)
TOKEN:comma: (
    [" " "\t" "\n" "\r"]* ","
)


### identifier
# upper = ‘A’ | . . . | ‘Z’ | ‘$’ | ‘_’ and Unicode Lu
# lower = ‘a’ | . . . | ‘z’ and Unicode Ll
# letter = upper | lower and Unicode categories Lo, Lt, Nl
# digit = ‘0’ | . . . | ‘9’
# opchar = “all other characters in\u0020-007F and Unicode categories Sm, So 
#          except parentheses ([]) and periods”
#   [^ "\u0000"-"\u001F" "[" "]" "(" ")" "."]
# op = opchar {opchar}
# idrest = {letter | digit} [‘_’ op]
#   (["a"-"z" "A"-"Z" "$" "_" "0"-"9"])* ("_" ([^ " " "\t" "\n" "\r" "[" "]" "(" ")" "," "." ";" "=" ":"])+)?
# varid: lower idrest
TOKEN:varid: ( 
    ["a"-"z"] 
    (["a"-"z" "A"-"Z" "$" "_" "0"-"9"])* ("_" ([^" " "\t" "\n" "\r" "[" "]" "(" ")" "," "." ";" "=" ":"])+)?
)
# varid: upper idrest
TOKEN:upperid: (
    ["_"]
    (["a"-"z" "A"-"Z" "$" "_" "0"-"9"])+ ("_" ([^" " "\t" "\n" "\r" "[" "]" "(" ")" ","  "." ";" "=" ":"])+)? 
    |
    ["A"-"Z" "$"] 
    (["a"-"z" "A"-"Z" "$" "_" "0"-"9"])* ("_" ([^" " "\t" "\n" "\r" "[" "]" "(" ")" ","  "." ";" "=" ":"])+)?
)

TOKEN:stringid: (
    "\'" ( 
        [^ "\\" "\'" "\n" "\r"] |
        ("\\" (
            . |
            (["0"-"7"] ["0"-"7"] ["0"-"7"]) |
            ("x" ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"]) |
            ("u" ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"])
        ))
    )*
    "\'"
)


### Literal
TOKEN:string: (
    "\"" ( 
        [^ "\\" "\"" "\n" "\r"] |
        ("\\" (
            . |
            (["0"-"7"] ["0"-"7"] ["0"-"7"]) |
            ("x" ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"]) |
            ("u" ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"])
        ))
    )* 
    "\""
)
TOKEN:string: (
    "\"\"\"" ( 
        [^ "\\" "\""] |
        ("\\" (
            . |
            (["0"-"7"] ["0"-"7"] ["0"-"7"]) |
            ("x" ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"]) |
            ("u" ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"])
        ))
    )* 
    "\"\"\""
)

TOKEN:char: (
    "\'" ( 
        [^ "\\" "\'" "\n" "\r"] |
        ("\\" (
            . |
            (["0"-"7"] ["0"-"7"] ["0"-"7"]) |
            ("x" ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"]) |
            ("u" ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"] ["0"-"9" "a"-"f" "A"-"F"])
        ))
    ) 
    "\'"
)

TOKEN:symbal: (
    "\'" (["a"-"z" "A"-"Z" "$" "_" "0"-"9"])* ("_" ([^" " "\t" "\n" "\r" "[" "]" "(" ")" "." ";" "="])+)?
)

TOKEN:integer: (
    ["0"-"9"] ['l' 'L']? |
    ["1"-"9"] ["0"-"9"]* ['l' 'L']? |
    "0" ["0"-"7"]+ ['l' 'L']? |
    "0" ["x" "X"] ["0"-"9" "a"-"f" "A"-"F"]+ ['l' 'L']? 
)

TOKEN:float: (
    ["0"-"9"]+ "." ["0"-"9"]* (["e" "E"] ["+" "-"]? ["0"-"9"]+)? ["f" "F" "d" "D"]? |
    "." ["0"-"9"]+ (["e" "E"] ["+" "-"]? ["0"-"9"]+)? ["f" "F" "d" "D"]? |
    ["0"-"9"]+ ["e" "E"] ["+" "-"]? ["0"-"9"]+ ["f" "F" "d" "D"]? |
    ["0"-"9"]+ (["e" "E"] ["+" "-"]? ["0"-"9"]+)? ["f" "F" "d" "D"]
)


TOKEN:nl: (
    ["\n" "\r"]+
)

TOKEN:whitespace:( 
    [" " "\t"]+ 
)


########## grammar #############################################################

SKIP:whitespace
SKIP:comment
SKIP:line_comment
SKIP:xml_comment
SKIP:comment_keyword

S = CompilationUnit;

OpId = <operator>
     | <rangle>
     | <slashrangle>;

PlainId = <upperid>
        | <varid>
        | OpId;

NameId = PlainId
       | <stringid>;

# all (<nl>)* behind ";" should also be eaten
Semi = ";" (<nl>)*
     | (<nl>)+ [";" (<nl>)*];

Literal = <integer>
        | <float>
        | <char>
        | <string>
        | <symbal>
        | "true" 
        | "false"
        | "null";

QualId = NameId (<dot> (<nl>)* NameId)*;

Ids = NameId (<comma> NameId)*;

## Hacking for: Path = StableId ["." "this"], since Path is also belongs to SimpleType etc
StableId = PathId (<dot> (<nl>)* PathId)*;
PathId = NameId
       | "this"
       | "super" [ClassQualifier] <dot> (<nl>)* NameId;
ClassQualifier = "[" NameId "]";

## Hacking for: SimpleType = StableId ["." "type"] (TypeArgs | "#" NameId)*
##  "." "type" should only be in SimpleType, but since StableId may also belongs to SimpleType,
##  we cannot add any more "." "anything" behind StableId
TypeStableId = TypeId (<dot> (<nl>)* TypeId)*;
TypeId = PathId
       | "_"
       | "type";

Types = Type (<comma> Type)*;
Type = InfixType [<rarrow> Type | ExistentialClause]
     | "(" <rarrow> Type ")" <rarrow> Type;

ExistentialClause = <forSome> <lcurly> (<nl>)* ExistentialDcl (Semi ExistentialDcl)* <rcurly>;
ExistentialDcl = "type" NameId [TypeParamClause] [">:" Type] ["<:" Type]
               | "val" Ids ":" Type;

InfixType = CompoundType (NameId [<nl>] CompoundType)*;
CompoundType = AnnotType ("with" AnnotType)* [Refinement]
             | Refinement;
AnnotType = (Annotation)* SimpleType ["*"];

SimpleType = TypeStableId (TypeArgs | "#" NameId)*
           | "(" Types1 ")" (TypeArgs | "#" NameId)*;
## Hacking for: Type (<comma> Type)* [<comma>];
Types1 = Type1 (<comma> Type1)*;
Type1 = Type
      | ;
TypeArgs = "[" Types "]";

Refinement = <lcurly> (<nl>)* [RefineStat (Semi RefineStat)*] <rcurly>;
RefineStat = DclDef;

## Here we have to do a mixed hacking for various Expr:
## 1. Hacking for: Expr = (Bindings | id) ‘=>’ Expr | Expr1
##     Bindings = "(" Binding ("," Binding)* ")";
##     Binding = NameId [":" Type];
## Since 
##     CaseClause = "case" Pattern [Guard] "=>" CaseBlockStats; 
## where 
##     Guard = "if" PostfixExpr; 
## Thus we cannot add another ("=>" Expr) after an expr which level is lower than 
## or same as PostfixExpr
Expr = CtrlExpr
     | PostfixExpr [Ascription [<rarrow> Expr] | <match> (<nl>)* <lcurly> (<nl>)* CaseClauses <rcurly> | <eq> Expr | <rarrow> Expr];
Ascription = ":" (CompoundType | (Annotation)+);

CtrlExpr = "if" "(" (<nl>)* Expr ")" (<nl>)* Expr [<else> (<nl>)* Expr]
         | "while" "(" (<nl>)* Expr ")" (<nl>)* Expr
         | "try" (<nl>)* <lcurly> (<nl>)* BlockStats <rcurly> [<catch> (<nl>)* <lcurly> (<nl>)* CaseClauses <rcurly>] [<finally> Expr]
         | "do" Expr [Semi] "while" "(" (<nl>)* Expr ")"
         | "for" ("(" (<nl>)* Enumerators ")" | <lcurly> (<nl>)* Enumerators <rcurly>) (<nl>)* [<yield>] Expr
         | "throw" Expr
         | "return" [Expr];



## Hacking for:
##     PostfixExpr = InfixExpr [NameId [<nl>]];
##     InfixExpr = PrefixExpr  (NameId [<nl>] InfixExpr)*;
PostfixExpr = PrefixExpr (NameId [<nl>] [PrefixExpr])*;
PrefixExpr = [PrefixOp] SimpleExpr;
PrefixOp = "-" 
         | "+" 
         | "~" 
         | "!";

SimpleExpr = SimpleExpr1 (<dot> (<nl>)* SimpleExpr1 | SimpleExpr2)*
           | SimpleExpr2 (<dot> (<nl>)* SimpleExpr1 | SimpleExpr2)*
           | NewExpr     (<dot> (<nl>)* SimpleExpr1 | SimpleExpr2)*
           | XmlExpr;
SimpleExpr1 = PathId (TypeArgs)*
            | Literal (TypeArgs)*;
SimpleExpr2 = "_" (TypeArgs)*
            | PrthsBody (TypeArgs)*
            | BlockBody (TypeArgs)*;

## Hacking for: "new" ([EarlyDef] ClassParents [TemplateBody] | TemplateBody)
## Since EalyBody and TemplateBody all start with "{" and TemplateBody is super set of EarlyBody,
## So, we have to use TemplateBody instead of EarlyBody
##    NewExpr = "new" [Block] AnnotType ClassTemplateBody [<dot> NameId];
##    ClassTemplateBody = (PrthsOrBlock ("with" AnnotType)* (TypeArgs)*)*;
##    ClassParents = AnnotType (Arguments)* ("with" AnnotType)*;
## A possible expr: NewExpr = "new" [Block] ClassParents (PrthsOrBlock (TypeArgs)*)* [<dot> NameId];
NewExpr = "new" (ClassParents [TemplateBody] | TemplateBody [ClassParents [TemplateBody]]) (TypeArgs)*;

Arguments = PrthsBody
          | BlockBody;

## Hacking for: Prths = "(" [Expr ("," Expr)* [","]] ")";
## To let a optional [","] at the end, we just let PrthsExpr can be empty
PrthsBody = "(" (<nl>)* ExprInPrths (<comma> (<nl>)* ExprInPrths)* (<nl>)* ")";
ExprInPrths = CtrlExpr
            | PostfixExpr [AscriptionInPrths [<rarrow> Expr] | <match> (<nl>)* <lcurly> (<nl>)* CaseClauses <rcurly> | <eq> Expr | <rarrow> Expr]
            | ;
## Hacking for: Ascription and Binding;
##     Ascription = ":" (CompoundType | (Annotation)+ | "_" "*")
##     Bindings = "(" Binding ("," Binding)* ")";
##     Binding = NameId [":" Type];
## Since (Bindings | id) ‘=>’ Expr also conflicts with (PostfixExpr Ascription "=>" Expr), 
## we have to combine them as: Ascription = ":" (Type | (Annotation)+);
AscriptionInPrths = ":" (Type | (Annotation)+);

BlockBody = <lcurly> (<nl>)* (BlockStats | CaseClauses) <rcurly>;
TemplateBody = <lcurly> (<nl>)* TemplateStats <rcurly> [<with>];

####### Blocked Statements: #############
TemplateStats = TemplateStat (Semi TemplateStat)*;
TemplateStat = Import
             | (Annotation)* (Modifier)* DclDef
             | ExprInTemplate
             | ;
## Hacking for TemplateBody ::= [nl] ‘{’ [id [‘:’ Type] ‘=>’] TemplateStat {semi TemplateStat} ‘}’
## Where, [id [‘:’ Type] ‘=>’] conflicts with Expr
ExprInTemplate = CtrlExpr
               | PostfixExpr [Ascription [<rarrow> TemplateStats] | <match> (<nl>)* <lcurly> (<nl>)* CaseClauses <rcurly> | <eq> Expr | <rarrow> TemplateStats];

BlockStats = BlockStat (Semi BlockStat)*;
BlockStat = Import
          | ["implicit"] DclDef
          | (LocalModifier)+ TmplDef
          | ExprInBlock
          | ;
## Hacking for: ResultExpr = (Bindings | NameId [":" CompoundType]) "=>" BlockStats;
## Where, the right part of "=>" is BlockStats vs Expr in anonynous function expression
ExprInBlock = CtrlExpr
            | PostfixExpr [Ascription [<rarrow> BlockStats] | <match> (<nl>)* <lcurly> (<nl>)* CaseClauses <rcurly> | <eq> Expr | <rarrow> BlockStats];

## Hacking for CaseClause BlockStats, where another "case" starting TmplDef maybe 
## recognized as a CaseClause in LL(k)
CaseBlockStats = CaseBlockStat (Semi CaseBlockStat)*;
CaseBlockStat = Import
              | ["implicit"] (ValDclDef | VarDclDef | FunDclDef | TypeDclDef)
              | (LocalModifier)+ TmplDef
              | ExprInCaseBlock
              | ;
ExprInCaseBlock = CtrlExpr
                | PostfixExpr [Ascription [<rarrow> CaseBlockStats] | <match> (<nl>)* <lcurly> (<nl>)* CaseClauses <rcurly> | <eq> Expr | <rarrow> CaseBlockStats];

CaseClauses = CaseClause (CaseClause)*;
CaseClause = "case" CasePattern [Guard] <rarrow> CaseBlockStats;
Guard = "if" PostfixExpr;

## The old style for-comprehensions' generator: ["val"] Pattern1 "<-" Expr [Guard]; 
## has been depracated in Version 2.6 
Enumerators = Generator (Semi Enumerator)*;
Generator = Pattern1 "<-" Expr [Guard];
Enumerator = Generator
           | Guard
           | "val" Pattern1 <eq> Expr
           | ;


XmlExpr = Element (Element)*
        | CDSect (Element)*
        | <pi> (Element)*;
XmlContent = Element
           | CDSect
           | <pi>;
Element = <element_start> (Attribute)* (<slashrangle> | <rangle> (Content)* <end_element>);
CDSect = <cdsect_start> <cddata> <cdsect_end>;
Content = CharData
        | XmlContent
        | ScalaExpr;
CharData = Literal
         | <keyword>
         | <varid>
         | <upperid>
         | <operator>
         | <separator>
         | <colon>
         | <dot>
         | <nl>;
Attribute = NSName <eq> AttValue;
AttValue = <string> # "\"" {CharQ | CharRef} "\""
         | <stringid> # "’" {CharA | CharRef} "’"
         | ScalaExpr
         | <nl>;
NSName = Name (":" Name)*;
Name = <varid>
     | <upperid>
     | <keyword>;
ScalaExpr = <lcurly> (<nl>)* BlockStats <rcurly>;

Pattern = Pattern1 ("|" Pattern1)*
        | ;
Pattern1 = Pattern3;

## Hacking: used only by PatDef
Pattern2 = "_" ["*"]
         | Literal
         | StableId ["(" (<nl>)* Patterns (<nl>)* ")" | "@" Pattern3]
         | "(" (<nl>)* Patterns (<nl>)* ")"
         | XmlPattern;

Pattern3 = SimplePattern (NameId [<nl>] SimplePattern)*;
SimplePattern = "_" ["*"]
              | Literal
              | StableId ["(" (<nl>)* Patterns (<nl>)* ")" | "@" Pattern3 | ":" Type]
              | "(" (<nl>)* Patterns (<nl>)* ")"
              | XmlPattern;

## Hacking for pattern in case clause:
## The only difference from Pattern for case clause is:
## we use (":" InfixType) rather than (":" Type). For example:
##     case rw: List[TemplateHolder] => rw
## where, (List[TemplateHolder] => rw) which is behind ":", may be parsed as a 
## function type rather then a (Type => Expr), so we here have to limit the Type to InfixType
CasePattern = CasePattern1 ("|" CasePattern1)*;
CasePattern1 = CasePattern0 (NameId [<nl>] CasePattern0)*;
CasePattern0 = "_" ["*"]
             | Literal
             | StableId ["(" (<nl>)* Patterns (<nl>)* ")" | "@" Pattern3 | ":" InfixType]
             | "(" (<nl>)* Patterns (<nl>)* ")"
             | XmlPattern;

XmlPattern = ElemPattern;
ElemPattern = <element_start> (<slashrangle> | <rangle> (ContentP)* <end_element>);
ContentP = ElemPattern
         | CDSect
         | <pi>
         | CharData
         | ScalaPatterns;
ScalaPatterns = <lcurly> (<nl>)* Patterns (<nl>)* <rcurly>;

Patterns = Pattern (<comma> (<nl>)* Pattern)*;


TypeParamClause = "[" VariantTypeParam (<comma> VariantTypeParam)* "]";
VariantTypeParam = ["+" | "-"] TypeParam;

FunTypeParamClause = "[" TypeParam (<comma> TypeParam)* "]";

## Hacking for TypeParam = NameId [">:" Type] ["<:" Type] ["<%" Type];
## Is the ScalaReference error? the following code is from examples.tcpoly.collection.HOSeq
##   trait Accumulator[+coll[x], elT] {...}
TypeParam = NameId [TypeParamClause] [">:" Type] ["<:" Type] ["<%" Type];

Modifier = LocalModifier
         | AccessModifier
         | "override";

LocalModifier = "abstract"
              | "final"
              | "sealed"
              | "implicit"
              | "lazy";

AccessModifier = ("private" | "protected") [AccessQualifier];
AccessQualifier = "[" (NameId | "this") "]";

Annotation = "@" AnnotationExpr [<nl>];
AnnotationExpr = AnnotType (Arguments)* [<lcurly> (<nl>)* (NameValuePair)* <rcurly>];
NameValuePair = "val" NameId <eq> PrefixExpr;

Import = "import" ImportExpr (<comma> ImportExpr)*;
## Hacking for: ImportExpr = StableId "." (NameId | "_" | ImportSelectors);
ImportExpr = ImportId;
ImportSelectors = <lcurly> (<nl>)* ImportSelector (<comma> ImportSelector)* <rcurly>;
ImportSelector = (NameId [<rarrow> (NameId | "_")] | "_");

ImportId = ImportId0 (<dot> (<nl>)* ImportId0)*;
ImportId0 = NameId
          | "super" [ClassQualifier] <dot> (<nl>)* NameId
          | "_"
          | ImportSelectors;

## Hacking for TemplateStat: Dcl and Def all belong to TemplateStat
DclDef = ValDclDef
       | VarDclDef
       | FunDclDef
       | TypeDclDef
       | TmplDef;
ValDclDef = "val" PatDef [<eq> Expr];
VarDclDef = "var" PatDef [<eq> Expr];
FunDclDef = "def" NameId [FunTypeParamClause] [ParamClauses] ([":" Type] [<eq> Expr] | <lcurly> BlockStats <rcurly>)
          | "def" "this" [ParamClauses] (<eq> ConstrExpr | ConstrBlock);
TypeDclDef = "type" NameId [TypeParamClause] ([">:" Type] ["<:" Type] ["<%" Type] | <eq> Type);

PatDef = Pattern2 (<comma> Pattern2)* [":" Type] ;

ParamClauses = ParamClause (ParamClause)*;
ParamClause = "(" (<nl>)* [["implicit"] Params] (<nl>)* ")";
Params = Param (<comma> (<nl>)* Param)*;
Param = (Annotation)* NameId [":" ParamType];
ParamType = Type ["*"]
          | <rarrow> Type;

ConstrExpr = SelfInvocation
           | ConstrBlock;
SelfInvocation = "this" (Arguments)+;
ConstrBlock = <lcurly> (<nl>)* SelfInvocation (Semi BlockStat)* <rcurly>;

TmplDef = ClassDef
        | ObjectDef
        | TraitDef;
ClassDef  = ["case"] "class" NameId [TypeParamClause] (Annotation)* [AccessModifier] ClassParamClauses            
            [<requires> AnnotType] [ClassTemplateOpt];
ObjectDef = ["case"] "object" NameId [ClassTemplateOpt];
TraitDef  = "trait" NameId [TypeParamClause] [<requires> AnnotType] [TraitTemplateOpt];

ClassParamClauses = ("(" (<nl>)* [ClassParams] (<nl>)* ")")* ["(" (<nl>)* "implicit" ClassParams (<nl>)* ")"];
ClassParams = ClassParam (<comma> (<nl>)* ClassParam)*;
ClassParam = (Annotation)* [(Modifier)* ("val" | "var")] NameId [":" ParamType];

ClassTemplateOpt = <extends> (ClassParents [TemplateBody] | TemplateBody [ClassParents [TemplateBody]])
                 | TemplateBody;
TraitTemplateOpt = <extends> (TraitParents [TemplateBody] | TemplateBody [TraitParents [TemplateBody]])
                 | TemplateBody;

ClassParents = AnnotType (PrthsBody)* (<with> AnnotType)*;
TraitParents = AnnotType (<with> AnnotType)*;

## Hacking for: [<nl>] TemplateBody
## Since Semi (which is ";" | <nl>) is separator between TopStat, we can not add [<nl>] TemplateBody at
## the end of ClassDef etc, instead, we have to let TemplateBody also be a TopStats
TopStats = TopStat (Semi TopStat)*;
#TopStat =  Expr | Packaging | Import;
TopStat = (Annotation)* (Modifier)* TmplDef
        | Import
        | Packaging
        | TemplateBody
        | ;

Packaging = "package" QualId <lcurly> (<nl>)* TopStats <rcurly>;
CompilationUnit = (<nl>)* ["package" QualId Semi] TopStats;


#SYNTAX_ERROR:Expr: {
#    token_identifier:";";
#    nt:"Expr";
#}

########### CODE FOLDING #######################################################
FOLD:ClassDef:{
    fold_display_name: "Class: $NameId$";
}

FOLD:TraitDef:{
    fold_display_name: "Trait: $NameId$";
}

FOLD:ObjectDef:{
    fold_display_name: "Object: $NameId$";
}

FOLD:FunDclDef:{
    fold_display_name: "Function: $NameId$";
}

#FOLD:MethodDeclaration:{
#    fold_display_name: "Methos: $MethodName$";
#}
#FOLD:block:"{...}"


########## NAVIGATOR ###########################################################
NAVIGATOR:ClassDef: {
    display_name: "$NameId$";
    icon: "/org/netbeans/modules/languages/resources/class.gif";
}

NAVIGATOR:TraitDef: {
    display_name: "$NameId$";
    icon: "/org/netbeans/modules/languages/resources/class.gif";
}

NAVIGATOR:ObjectDef: {
    display_name: "$NameId$";
    icon: "/org/netbeans/modules/languages/resources/class.gif";
}

NAVIGATOR:FunDclDef: {
    display_name: "$NameId$";
    icon: "/org/netbeans/modules/languages/resources/method.gif";
}

NAVIGATOR:TypeDclDef: {
    display_name: "$NameId$";
    icon: "/org/netbeans/modules/languages/resources/method.gif";
}

NAVIGATOR:TemplateStat.DclDef.ValDclDef: {
    display_name: "$PatDef$";
    icon: "/org/netbeans/modules/languages/resources/variable.gif";
}

NAVIGATOR:TemplateStat.DclDef.VarDclDef: {
    display_name: "$PatDef$";
    icon: "/org/netbeans/modules/languages/resources/variable.gif";
}

NAVIGATOR:CaseClause: {
    display_name: "case $CasePattern$";
    icon: "/org/netbeans/modules/languages/resources/method.gif";
}


MARK:ERROR: {
    type:"Error";
    message:"LBL_SYNTAX_ERROR";
}

MARK:error: {
    type:"Error";
    message:"LBL_UNEXPECTED_CHARACTER";
}

########### colors #############################################################
COLOR:keyword,colon,catch,else,extends,finally,forSome,match,requires,with,yield,eq,rarrow,larrow: {
    foreground_color: "0x0000FE";
}

COLOR:Type,InfixType,AnnotType,SimpleType: {
    foreground_color: "black";
    font_type: "bold";
}

COLOR:ClassDef.NameId, TraitDef.NameId, ObjectDef.NameId: {
    foreground_color: "black";
    font_type: "bold";
}

COLOR:FunDclDef.NameId: {
    foreground_color: "black";
    underline_color: "0x000000";
}

COLOR:integer,float: {
    foreground_color: "0x780000";
}

COLOR:sting,char: {
    foreground_color: "0xCE7B00";
}

COLOR:comment,line_comment,xml_comment: {
    foreground_color: "0x737373";
    #defualt_coloring: "comment";
}

COLOR:comment_keyword: {
    foreground_color: "0x737373";
    font_type:"bold";
}

COLOR:PostfixExpr.NameId,PrefixExpr.PrefixOp: {
    foreground_color: "0x2E92C7";
}

COLOR:element_start,end_element,Element.rslashangle,Element.rangle,ElemPattern.rslashangle,ElemPattern.rangle: {
    foreground_color: "0x228B22";
}

########### complete and indentation ########################################################
COMPLETE "(:)"
COMPLETE "{:}"
COMPLETE "\":\""
COMPLETE "':'"
COMPLETE "[:]"

######## Brace matching
BRACE "{:}"
BRACE "(:)"
BRACE "[:]"
BRACE "\":\""

INDENT "(:)"
INDENT "{:}"
INDENT "[:]"
INDENT "\\s*(((if|while)\\s*\\(|else\\s*|else\\s+if\\s*\\(|for\\s*\\(.*\\))[^{;]*)"

BUNDLE "org.netbeans.modules.scala.editing.Bundle"

SELECTION ( ["a"-"z" "A"-"Z" "0"-"9" "_" "$"] )

COMMENT_LINE {
    prefix:"//";
}
