// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.13.2,
// (C) 2004-2007 Robert Grimm,
// on Monday, March 24, 2008 at 12:22:15 PM.
// Edit at your own risk.
// ===========================================================================

package org.netbeans.modules.scala.editing.rats;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Pair;

import xtc.tree.Node;
import xtc.tree.GNode;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

/**
 * Packrat parser for grammar <code>org.netbeans.modules.scala.editing.rats.ParserScala</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.13.2, (C) 2004-2007 Robert Grimm.
 */
public final class ParserScala extends ParserBase {

  /** The SCALA_KEYWORDS set. */
  public static final Set<String> SCALA_KEYWORDS = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fQualId;
    Result f$$Shared1;
    Result fIds;
    Result fIds$$Star1;
    Result fPath;
    Result fStableId;
    Result fClassQualifier;
    Result fType;
    Result fExistentialDcl;
    Result fInfixType;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fInfixType$$Star1;
    Result fCompoundType;
    Result fCompoundType$$Star1;
    Result fAnnotType;
    Result f$$Shared2;
    Result fTypeArgs;
    Result fTypes;
    Result fTypes$$Star1;
    Result fRefinement;
    Result fRefinement$$Star1;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fRefineStat;
    Result fTypePat;
    Result fExpr;
    Result fExprNotFun;
    Result f$$Shared3;
    Result fPostfixExpr;
    Result fPrefixExpr;
    Result fSimpleExpr;
    Result fSimpleExprRest;
    Result fSimpleExprRest$$Plus1;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fSimpleExprRest$$Plus2;
    Result fArgumentExprs;
    Result fParenExpr;
    Result fBlockExpr;
    Result fBlock;
    Result fBlock$$Star1;
    Result fBlockStat;
    Result fBlockStat$$Star1;
    Result fEnumerators;
    Result fEnumerators$$Star1;
  }

  /** Chunk 5 of memoized results. */
  static final class Chunk5 {
    Result fGenerator;
    Result fCaseClauses;
    Result fCaseClauses$$Star1;
    Result fCaseClause;
    Result fGuard;
    Result fPattern;
    Result fPattern$$Star1;
    Result fPattern1;
    Result fPattern2;
    Result fPattern3;
  }

  /** Chunk 6 of memoized results. */
  static final class Chunk6 {
    Result fPattern3$$Plus1;
    Result fSimplePattern;
    Result fTuplePattern;
    Result fPatterns;
    Result fPatterns$$Star1;
    Result fTypeParamClause;
    Result fTypeParamClause$$Star1;
    Result fVariantTypeParam;
    Result fTypeParam;
    Result fParamClauses;
  }

  /** Chunk 7 of memoized results. */
  static final class Chunk7 {
    Result fParamClauses$$Star1;
    Result fParamClause;
    Result fParams;
    Result fParams$$Star1;
    Result fParam;
    Result fParamType;
    Result fClassParams;
    Result fClassParams$$Star1;
    Result fClassParam;
    Result fClassParam$$Star2;
  }

  /** Chunk 8 of memoized results. */
  static final class Chunk8 {
    Result fBindings;
    Result fBindings$$Star1;
    Result fBinding;
    Result fModifier;
    Result fLocalModifier;
    Result fAccessModifier;
    Result fAnnotation;
    Result fTemplateBody;
    Result fTemplateBody$$Star1;
    Result fTemplateStat;
  }

  /** Chunk 9 of memoized results. */
  static final class Chunk9 {
    Result f$$Shared4;
    Result fImport;
    Result fImport$$Star1;
    Result fImportExpr;
    Result fImportSelector;
    Result fDcl;
    Result fValDcl;
    Result fFunSig;
    Result fTypeDcl;
    Result fPatVarDef;
  }

  /** Chunk 10 of memoized results. */
  static final class Chunk10 {
    Result fDef;
    Result fPatDef;
    Result fPatDef$$Star1;
    Result fTypeDef;
    Result fTmplDef;
    Result fClassTemplateOpt;
    Result fExtends;
    Result fClassTemplate;
    Result fConstr;
    Result f$$Shared5;
  }

  /** Chunk 11 of memoized results. */
  static final class Chunk11 {
    Result fEarlyDefs;
    Result fEarlyDefs$$Star1;
    Result fEarlyDef;
    Result fConstrBlock;
    Result fConstrBlock$$Star1;
    Result fSelfInvocation;
    Result fTopStatSeq;
    Result fTopStatSeq$$Star1;
    Result fTopStat;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class ParserScalaColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
    Chunk5 chunk5;
    Chunk6 chunk6;
    Chunk7 chunk7;
    Chunk8 chunk8;
    Chunk9 chunk9;
    Chunk10 chunk10;
    Chunk11 chunk11;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public ParserScala(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public ParserScala(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new ParserScalaColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.XmlExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlExpr(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredResult = pXmlExpr$$Choice1(yyStart);
    yyError      = yyPredResult.select(yyError);
    if (yyPredResult.hasValue()) {

      yyResult = pXmlExpr$$Choice2(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$1 = yyResult.semanticValue();

        yyResult = pXmlElement(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("XmlExpr", v$g$1, v$g$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.XmlExpr$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlExpr$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ' ':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '(':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '{':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("xml expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.XmlExpr$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlExpr$$Choice2(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWs(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pSeparator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Literal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;
      String v$g$1 = "-";

      final int yyChoice1 = yyIndex;

      // Nested alternative 1.

      yyResult = pintegerLiteral(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("Literal", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pFloatingPointLiteral(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$3 = yyResult.semanticValue();

        yyValue = GNode.create("Literal", v$g$1, v$g$3);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pBooleanLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$4 = yyResult.semanticValue();

      yyValue = GNode.create("Literal", v$g$4);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pCharacterLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$5 = yyResult.semanticValue();

      yyValue = GNode.create("Literal", v$g$5);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$6 = yyResult.semanticValue();

      yyValue = GNode.create("Literal", v$g$6);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pSymbolLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$7 = yyResult.semanticValue();

      yyValue = GNode.create("Literal", v$g$7);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.BooleanLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBooleanLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;
            String v$g$1 = "true";

            yyValue = GNode.create("BooleanLiteral", v$g$1);

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;
              String v$g$2 = "false";

              yyValue = GNode.create("BooleanLiteral", v$g$2);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("boolean literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.semi.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psemi(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (';' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyResult = pnl(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        continue;
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("semi expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.QualId.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualId(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fQualId) 
      yyColumn.chunk1.fQualId = pQualId$1(yyStart);
    return yyColumn.chunk1.fQualId;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.QualId. */
  private Result pQualId$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = p$$Shared1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("QualId", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.$$Shared1.
   * This nonterminal represents the duplicate productions 
   * org.netbeans.modules.scala.editing.rats.ParserScala.QualId$$Star1 
   * and org.netbeans.modules.scala.editing.rats.ParserScala.Path$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared1) 
      yyColumn.chunk1.f$$Shared1 = p$$Shared1$1(yyStart);
    return yyColumn.chunk1.f$$Shared1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.$$Shared1. */
  private Result p$$Shared1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pId(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyResult = p$$Shared1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Ids.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIds(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIds) yyColumn.chunk1.fIds = pIds$1(yyStart);
    return yyColumn.chunk1.fIds;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Ids. */
  private Result pIds$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pIds$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("Ids", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Ids$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIds$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fIds$$Star1) 
      yyColumn.chunk1.fIds$$Star1 = pIds$$Star1$1(yyStart);
    return yyColumn.chunk1.fIds$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Ids$$Star1. */
  private Result pIds$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pId(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyResult = pIds$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Path.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPath(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fPath) 
      yyColumn.chunk1.fPath = pPath$1(yyStart);
    return yyColumn.chunk1.fPath;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Path. */
  private Result pPath$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = p$$Shared1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("Path", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pId(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$3 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('.' == yyC) {
        yyIndex = yyResult.index + 1;

        yyOption1  = yyIndex;
        yyOpValue1 = v$el$3;
      } else {
        yyError = yyError.select("\".\" expected", yyBase);
      }
    }
    { // Start scope for v$g$3.
      Node v$g$3 = yyOpValue1;

      yyBase = yyOption1;
      yyC    = character(yyBase);
      if ('t' == yyC) {
        yyIndex = yyOption1 + 1;

        yyC = character(yyIndex);
        if ('h' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('s' == yyC) {
              yyIndex = yyIndex + 1;
              String v$g$4 = "this";

              yyValue = GNode.create("Path", v$g$3, v$g$4);

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"this\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"this\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"this\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"this\" expected", yyBase);
      }
    } // End scope for v$g$3.

    // Alternative 3.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$5 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('.' == yyC) {
        yyIndex = yyResult.index + 1;

        yyBase = yyIndex;
        yyC    = character(yyBase);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('p' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('r' == yyC) {
                  yyIndex = yyIndex + 1;
                  String v$g$6 = "super";

                  yyOption1  = yyIndex;
                  yyOpValue1 = null;

                  yyResult = pClassQualifier(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Node v$el$4 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$4;
                  }
                  { // Start scope for v$g$7.
                    Node v$g$7 = yyOpValue1;

                    yyBase = yyOption1;
                    yyC    = character(yyBase);
                    if ('.' == yyC) {
                      yyIndex = yyOption1 + 1;
                      String v$g$8 = ".";

                      yyResult = pId(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Node v$g$9 = yyResult.semanticValue();

                        yyValue = GNode.create("Path", v$g$5, v$g$6, v$g$7, v$g$8, v$g$9);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    } else {
                      yyError = yyError.select("\".\" expected", yyBase);
                    }
                  } // End scope for v$g$7.
                } else {
                  yyError = yyError.select("\"super\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"super\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"super\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"super\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"super\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\".\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.StableId.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStableId(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fStableId) 
      yyColumn.chunk1.fStableId = pStableId$1(yyStart);
    return yyColumn.chunk1.fStableId;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.StableId. */
  private Result pStableId$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("StableId", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pPath(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('.' == yyC) {
        yyIndex = yyResult.index + 1;
        String v$g$3 = ".";

        yyResult = pId(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$4 = yyResult.semanticValue();

          yyValue = GNode.create("StableId", v$g$2, v$g$3, v$g$4);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\".\" expected", yyBase);
      }
    }

    // Alternative 3.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$5 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('.' == yyC) {
        yyIndex = yyResult.index + 1;
        String v$g$6 = ".";

        yyBase = yyIndex;
        yyC    = character(yyBase);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('p' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('r' == yyC) {
                  yyIndex = yyIndex + 1;
                  String v$g$7 = "super";

                  yyOption1  = yyIndex;
                  yyOpValue1 = null;

                  yyResult = pClassQualifier(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Node v$el$1 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$1;
                  }
                  { // Start scope for v$g$8.
                    Node v$g$8 = yyOpValue1;

                    yyBase = yyOption1;
                    yyC    = character(yyBase);
                    if ('.' == yyC) {
                      yyIndex = yyOption1 + 1;
                      String v$g$9 = ".";

                      yyResult = pId(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Node v$g$10 = yyResult.semanticValue();

                        yyValue = GNode.create("StableId", v$g$5, v$g$6, v$g$7, v$g$8, v$g$9, v$g$10);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    } else {
                      yyError = yyError.select("\".\" expected", yyBase);
                    }
                  } // End scope for v$g$8.
                } else {
                  yyError = yyError.select("\"super\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"super\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"super\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"super\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"super\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\".\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ClassQualifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassQualifier(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fClassQualifier) 
      yyColumn.chunk1.fClassQualifier = pClassQualifier$1(yyStart);
    return yyColumn.chunk1.fClassQualifier;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ClassQualifier. */
  private Result pClassQualifier$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;
      String v$g$1 = "[";

      yyResult = pId(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if (']' == yyC) {
          yyIndex = yyResult.index + 1;
          String v$g$3 = "]";

          yyValue = GNode.create("ClassQualifier", v$g$1, v$g$2, v$g$3);

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"]\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("class qualifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fType) 
      yyColumn.chunk1.fType = pType$1(yyStart);
    return yyColumn.chunk1.fType;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Type. */
  private Result pType$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInfixType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('=' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          String v$g$2 = "=>";

          yyResult = pType(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$3 = yyResult.semanticValue();

            yyValue = GNode.create("Type", v$g$1, v$g$2, v$g$3);

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("\"=>\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"=>\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;
      String v$g$4 = "(";

      yyOption1  = yyIndex;
      yyOpValue1 = null;

      yyBase = yyOption1;
      yyC    = character(yyBase);
      if ('=' == yyC) {
        yyIndex = yyOption1 + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pType(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        } else {
          yyError = yyError.select("\"=>\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"=>\" expected", yyBase);
      }
      { // Start scope for v$g$5.
        Node v$g$5 = yyOpValue1;

        yyBase = yyOption1;
        yyC    = character(yyBase);
        if (')' == yyC) {
          yyIndex = yyOption1 + 1;
          String v$g$6 = ")";

          yyBase = yyIndex;
          yyC    = character(yyBase);
          if ('=' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('>' == yyC) {
              yyIndex = yyIndex + 1;
              String v$g$7 = "=>";

              yyResult = pType(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$g$8 = yyResult.semanticValue();

                yyValue = GNode.create("Type", v$g$4, v$g$5, v$g$6, v$g$7, v$g$8);

                return yyResult.createValue(yyValue, yyError);
              }
            } else {
              yyError = yyError.select("\"=>\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"=>\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\")\" expected", yyBase);
        }
      } // End scope for v$g$5.
    }

    // Alternative 3.

    yyResult = pInfixType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$9 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pExistentialClause(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
      { // Start scope for v$g$10.
        Node v$g$10 = yyOpValue1;

        yyValue = GNode.create("Type", v$g$9, v$g$10);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$10.
    }

    // Done.
    yyError = yyError.select("type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ExistentialClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExistentialClause(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('S' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('o' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('m' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;
                  String v$g$1 = "forSome";

                  yyBase = yyIndex;
                  yyC    = character(yyBase);
                  if ('{' == yyC) {
                    yyIndex = yyIndex + 1;
                    String v$g$2 = "{";

                    yyResult = pExistentialDcl(yyIndex);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Node v$g$3 = yyResult.semanticValue();

                      yyRepetition1 = yyResult.index;
                      yyRepValue1   = Pair.empty();
                      while (true) {

                        yyResult = psemi(yyRepetition1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pExistentialDcl(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            Node v$el$1 = yyResult.semanticValue();

                            yyRepetition1 = yyResult.index;
                            yyRepValue1   = 
                              new Pair<Node>(v$el$1, yyRepValue1);
                            continue;
                          }
                        }
                        break;
                      }
                      { // Start scope for v$g$4.
                        Pair<Node> v$g$4 = yyRepValue1.reverse();

                        yyBase = yyRepetition1;
                        yyC    = character(yyBase);
                        if ('}' == yyC) {
                          yyIndex = yyRepetition1 + 1;
                          String v$g$5 = "}";

                          yyValue = GNode.create("ExistentialClause", v$g$4.size() + 4).
                            add(v$g$1).add(v$g$2).add(v$g$3).addAll(v$g$4).add(v$g$5);

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        } else {
                          yyError = yyError.select("\"}\" expected", yyBase);
                        }
                      } // End scope for v$g$4.
                    }
                  } else {
                    yyError = yyError.select("\"{\" expected", yyBase);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("existential clause expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ExistentialDcl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExistentialDcl(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExistentialDcl) 
      yyColumn.chunk1.fExistentialDcl = pExistentialDcl$1(yyStart);
    return yyColumn.chunk1.fExistentialDcl;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ExistentialDcl. */
  private Result pExistentialDcl$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pTypeDcl(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$g$1 = yyResult.semanticValue();

              yyValue = GNode.create("ExistentialDcl", v$g$1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pValDcl(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("ExistentialDcl", v$g$2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("existential dcl expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.InfixType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInfixType(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fInfixType) 
      yyColumn.chunk1.fInfixType = pInfixType$1(yyStart);
    return yyColumn.chunk1.fInfixType;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.InfixType. */
  private Result pInfixType$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCompoundType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pInfixType$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("InfixType", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.InfixType$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInfixType$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fInfixType$$Star1) 
      yyColumn.chunk2.fInfixType$$Star1 = pInfixType$$Star1$1(yyStart);
    return yyColumn.chunk2.fInfixType$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.InfixType$$Star1. */
  private Result pInfixType$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInfixTypeRest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$1 = yyResult.semanticValue();

      yyResult = pInfixType$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.InfixTypeRest.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInfixTypeRest(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;

      yyResult = pnl(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }

      yyResult = pCompoundType(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("InfixTypeRest", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.CompoundType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCompoundType(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fCompoundType) 
      yyColumn.chunk2.fCompoundType = pCompoundType$1(yyStart);
    return yyColumn.chunk2.fCompoundType;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.CompoundType. */
  private Result pCompoundType$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAnnotType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pCompoundType$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pRefinement(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
        { // Start scope for v$g$3.
          Node v$g$3 = yyOpValue1;

          yyValue = GNode.create("CompoundType", v$g$2.size() + 2).
            add(v$g$1).addAll(v$g$2).add(v$g$3);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$3.
      }
    }

    // Alternative 2.

    yyResult = pRefinement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$4 = yyResult.semanticValue();

      yyValue = GNode.create("CompoundType", v$g$4);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.CompoundType$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCompoundType$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fCompoundType$$Star1) 
      yyColumn.chunk2.fCompoundType$$Star1 = pCompoundType$$Star1$1(yyStart);
    return yyColumn.chunk2.fCompoundType$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.CompoundType$$Star1. */
  private Result pCompoundType$$Star1$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('h' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pAnnotType(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$el$1 = yyResult.semanticValue();

              yyResult = pCompoundType$$Star1(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Pair<Node> v$2 = yyResult.semanticValue();

                yyValue = new Pair<Node>(v$el$1, v$2);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.AnnotType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAnnotType(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAnnotType) 
      yyColumn.chunk2.fAnnotType = pAnnotType$1(yyStart);
    return yyColumn.chunk2.fAnnotType;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.AnnotType. */
  private Result pAnnotType$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Node> v$g$1 = yyResult.semanticValue();

      yyResult = pSimpleType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("AnnotType", v$g$1.size() + 1).
          addAll(v$g$1).add(v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.$$Shared2.
   * This nonterminal represents the duplicate productions 
   * org.netbeans.modules.scala.editing.rats.ParserScala.AnnotType$$Star1, 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Param$$Star1, 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ClassParam$$Star1, 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TemplateStat$$Star1, 
   * org.netbeans.modules.scala.editing.rats.ParserScala.EarlyDef$$Star1, 
   * and org.netbeans.modules.scala.editing.rats.ParserScala.TopStat$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared2(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.f$$Shared2) 
      yyColumn.chunk2.f$$Shared2 = p$$Shared2$1(yyStart);
    return yyColumn.chunk2.f$$Shared2;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.$$Shared2. */
  private Result p$$Shared2$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAnnotation(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$1 = yyResult.semanticValue();

      yyResult = p$$Shared2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.SimpleType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleType(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStableId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pTypeArgs(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$g$2.
        Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if ('#' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyResult = pId(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$el$2 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("\"#\" expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$3.
          Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyValue = GNode.create("SimpleType", v$g$2.size() + v$g$3.size() + 1).
            add(v$g$1).addAll(v$g$2).addAll(v$g$3);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$3.
      } // End scope for v$g$2.
    }

    // Alternative 2.

    yyResult = pPath(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$4 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('.' == yyC) {
        yyIndex = yyResult.index + 1;

        yyBase = yyIndex;
        yyC    = character(yyBase);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('y' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('p' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyRepetition1 = yyIndex;
                yyRepValue1   = Pair.empty();
                while (true) {

                  yyResult = pTypeArgs(yyRepetition1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Node v$el$3 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepValue1   = new Pair<Node>(v$el$3, yyRepValue1);
                    continue;
                  }
                  break;
                }
                { // Start scope for v$g$5.
                  Pair<Node> v$g$5 = yyRepValue1.reverse();

                  yyRepValue1   = Pair.empty();
                  while (true) {

                    yyBase = yyRepetition1;
                    yyC    = character(yyBase);
                    if ('#' == yyC) {
                      yyIndex = yyRepetition1 + 1;

                      yyResult = pId(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Node v$el$4 = yyResult.semanticValue();

                        yyRepetition1 = yyResult.index;
                        yyRepValue1   = new Pair<Node>(v$el$4, yyRepValue1);
                        continue;
                      }
                    } else {
                      yyError = yyError.select("\"#\" expected", yyBase);
                    }
                    break;
                  }
                  { // Start scope for v$g$6.
                    Pair<Node> v$g$6 = yyRepValue1.reverse();

                    yyValue = GNode.create("SimpleType", v$g$5.size() + v$g$6.size() + 1).
                      add(v$g$4).addAll(v$g$5).addAll(v$g$6);

                    return new SemanticValue(yyValue, yyRepetition1, yyError);
                  } // End scope for v$g$6.
                } // End scope for v$g$5.
              } else {
                yyError = yyError.select("\"type\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"type\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"type\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"type\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\".\" expected", yyBase);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pTypes(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$7 = yyResult.semanticValue();

        yyOption1  = yyResult.index;

        yyBase = yyOption1;
        yyC    = character(yyBase);
        if (',' == yyC) {
          yyIndex = yyOption1 + 1;

          yyOption1  = yyIndex;
        } else {
          yyError = yyError.select("\",\" expected", yyBase);
        }

        yyBase = yyOption1;
        yyC    = character(yyBase);
        if (')' == yyC) {
          yyIndex = yyOption1 + 1;

          yyRepetition1 = yyIndex;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pTypeArgs(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$el$5 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$5, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for v$g$8.
            Pair<Node> v$g$8 = yyRepValue1.reverse();

            yyRepValue1   = Pair.empty();
            while (true) {

              yyBase = yyRepetition1;
              yyC    = character(yyBase);
              if ('#' == yyC) {
                yyIndex = yyRepetition1 + 1;

                yyResult = pId(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Node v$el$6 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = new Pair<Node>(v$el$6, yyRepValue1);
                  continue;
                }
              } else {
                yyError = yyError.select("\"#\" expected", yyBase);
              }
              break;
            }
            { // Start scope for v$g$9.
              Pair<Node> v$g$9 = yyRepValue1.reverse();

              yyValue = GNode.create("SimpleType", v$g$8.size() + v$g$9.size() + 1).
                add(v$g$7).addAll(v$g$8).addAll(v$g$9);

              return new SemanticValue(yyValue, yyRepetition1, yyError);
            } // End scope for v$g$9.
          } // End scope for v$g$8.
        } else {
          yyError = yyError.select("\")\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("simple type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TypeArgs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeArgs(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTypeArgs) 
      yyColumn.chunk2.fTypeArgs = pTypeArgs$1(yyStart);
    return yyColumn.chunk2.fTypeArgs;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.TypeArgs. */
  private Result pTypeArgs$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;
      String v$g$1 = "[";

      yyResult = pTypes(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if (']' == yyC) {
          yyIndex = yyResult.index + 1;
          String v$g$3 = "]";

          yyValue = GNode.create("TypeArgs", v$g$1, v$g$2, v$g$3);

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"]\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("type args expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Types.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypes(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTypes) 
      yyColumn.chunk2.fTypes = pTypes$1(yyStart);
    return yyColumn.chunk2.fTypes;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Types. */
  private Result pTypes$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pTypes$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("Types", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Types$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypes$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTypes$$Star1) 
      yyColumn.chunk2.fTypes$$Star1 = pTypes$$Star1$1(yyStart);
    return yyColumn.chunk2.fTypes$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Types$$Star1. */
  private Result pTypes$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pType(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyResult = pTypes$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Refinement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRefinement(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fRefinement) 
      yyColumn.chunk2.fRefinement = pRefinement$1(yyStart);
    return yyColumn.chunk2.fRefinement;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Refinement. */
  private Result pRefinement$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyResult = pnl(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
    }

    yyBase = yyOption1;
    yyC    = character(yyBase);
    if ('{' == yyC) {
      yyIndex = yyOption1 + 1;

      yyOption1  = yyIndex;
      yyOpValue1 = null;

      yyResult = pRefineStat(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        Node v$g$1 = yyOpValue1;

        yyResult = pRefinement$$Star1(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$g$2 = yyResult.semanticValue();

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if ('}' == yyC) {
            yyIndex = yyResult.index + 1;

            yyValue = GNode.createFromPair("Refinement", v$g$1, v$g$2);

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("\"}\" expected", yyBase);
          }
        }
      } // End scope for v$g$1.
    } else {
      yyError = yyError.select("\"{\" expected", yyBase);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Refinement$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRefinement$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fRefinement$$Star1) 
      yyColumn.chunk2.fRefinement$$Star1 = pRefinement$$Star1$1(yyStart);
    return yyColumn.chunk2.fRefinement$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Refinement$$Star1. */
  private Result pRefinement$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psemi(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pRefineStat(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$3 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$3;
      }
      { // Start scope for v$el$2.
        Node v$el$2 = yyOpValue1;

        yyResult = pRefinement$$Star1(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$4 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$2, v$4);

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v$el$2.
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.RefineStat.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRefineStat(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fRefineStat) 
      yyColumn.chunk3.fRefineStat = pRefineStat$1(yyStart);
    return yyColumn.chunk3.fRefineStat;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.RefineStat. */
  private Result pRefineStat$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pTypeDef(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$g$1 = yyResult.semanticValue();

              yyValue = GNode.create("RefineStat", v$g$1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pDcl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("RefineStat", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("refine stat expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TypePat.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypePat(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fTypePat) 
      yyColumn.chunk3.fTypePat = pTypePat$1(yyStart);
    return yyColumn.chunk3.fTypePat;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.TypePat. */
  private Result pTypePat$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("TypePat", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Ascription.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAscription(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      final int yyChoice1 = yyIndex;

      // Nested alternative 1.

      yyResult = pCompoundType(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("Ascription", v$g$1);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pAnnotation(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pAnnotation(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$3.
          Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("Ascription", v$g$2, v$g$3);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$3.
      }

      // Nested alternative 3.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('_' == yyC) {
        yyIndex = yyChoice1 + 1;
        String v$g$4 = "_";

        yyBase = yyIndex;
        yyC    = character(yyBase);
        if ('*' == yyC) {
          yyIndex = yyIndex + 1;
          String v$g$5 = "*";

          yyValue = GNode.create("Ascription", v$g$4, v$g$5);

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"*\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"_\" expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("ascription expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Expr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpr(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExpr) 
      yyColumn.chunk3.fExpr = pExpr$1(yyStart);
    return yyColumn.chunk3.fExpr;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Expr. */
  private Result pExpr$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpr$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('=' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pExpr(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("Expr", v$g$1, v$g$2);

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("\"=>\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"=>\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pExprNotFun(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("Expr", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Expr$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpr$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindings(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ExprNotFun.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprNotFun(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExprNotFun) 
      yyColumn.chunk3.fExprNotFun = pExprNotFun$1(yyStart);
    return yyColumn.chunk3.fExprNotFun;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ExprNotFun. */
  private Result pExprNotFun$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    int        yyOption2;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('f' == yyC) {
        yyIndex = yyIndex + 1;

        yyBase = yyIndex;
        yyC    = character(yyBase);
        if ('(' == yyC) {
          yyIndex = yyIndex + 1;
          String v$g$1 = "(";

          yyResult = pExpr(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$2 = yyResult.semanticValue();

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if (')' == yyC) {
              yyIndex = yyResult.index + 1;
              String v$g$3 = ")";

              yyResult = p$$Shared3(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExpr(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Node v$g$4 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyOption2  = yyOption1;

                  yyResult = psemi(yyOption2);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption2  = yyResult.index;
                  }

                  yyBase = yyOption2;
                  yyC    = character(yyBase);
                  if ('e' == yyC) {
                    yyIndex = yyOption2 + 1;

                    yyC = character(yyIndex);
                    if ('l' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('s' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('e' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyResult = pExpr(yyIndex);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            Node v$el$1 = yyResult.semanticValue();

                            yyOption1  = yyResult.index;
                            yyOpValue1 = v$el$1;
                          }
                        } else {
                          yyError = yyError.select("\"else\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"else\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"else\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"else\" expected", yyBase);
                  }
                  { // Start scope for v$g$5.
                    Node v$g$5 = yyOpValue1;

                    yyValue = GNode.create("ExprNotFun", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);

                    return new SemanticValue(yyValue, yyOption1, yyError);
                  } // End scope for v$g$5.
                }
              }
            } else {
              yyError = yyError.select("\")\" expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("\"(\" expected", yyBase);
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyBase = yyIndex;
              yyC    = character(yyBase);
              if ('(' == yyC) {
                yyIndex = yyIndex + 1;
                String v$g$6 = "(";

                yyResult = pExpr(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Node v$g$7 = yyResult.semanticValue();

                  yyBase = yyResult.index;
                  yyC    = character(yyBase);
                  if (')' == yyC) {
                    yyIndex = yyResult.index + 1;
                    String v$g$8 = ")";

                    yyResult = p$$Shared3(yyIndex);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pExpr(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Node v$g$9 = yyResult.semanticValue();

                        yyValue = GNode.create("ExprNotFun", v$g$6, v$g$7, v$g$8, v$g$9);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  } else {
                    yyError = yyError.select("\")\" expected", yyBase);
                  }
                }
              } else {
                yyError = yyError.select("\"(\" expected", yyBase);
              }
            }
          }
        }
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('y' == yyC) {
          yyIndex = yyIndex + 1;

          yyBase = yyIndex;
          yyC    = character(yyBase);
          if ('{' == yyC) {
            yyIndex = yyIndex + 1;
            String v$g$10 = "{";

            yyResult = pBlock(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$g$11 = yyResult.semanticValue();

              yyBase = yyResult.index;
              yyC    = character(yyBase);
              if ('}' == yyC) {
                yyIndex = yyResult.index + 1;
                String v$g$12 = "}";

                yyOption1  = yyIndex;
                yyOpValue1 = null;

                yyBase = yyOption1;
                yyC    = character(yyBase);
                if ('c' == yyC) {
                  yyIndex = yyOption1 + 1;

                  yyC = character(yyIndex);
                  if ('a' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('t' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('c' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('h' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyBase = yyIndex;
                          yyC    = character(yyBase);
                          if ('{' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyResult = pCaseClauses(yyIndex);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              Node v$el$2 = yyResult.semanticValue();

                              yyBase = yyResult.index;
                              yyC    = character(yyBase);
                              if ('}' == yyC) {
                                yyIndex = yyResult.index + 1;

                                yyOption1  = yyIndex;
                                yyOpValue1 = v$el$2;
                              } else {
                                yyError = yyError.select("\"}\" expected", yyBase);
                              }
                            }
                          } else {
                            yyError = yyError.select("\"{\" expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("\"catch\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"catch\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"catch\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"catch\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"catch\" expected", yyBase);
                }
                { // Start scope for v$g$13.
                  Node v$g$13 = yyOpValue1;

                  yyOpValue1 = null;

                  yyBase = yyOption1;
                  yyC    = character(yyBase);
                  if ('f' == yyC) {
                    yyIndex = yyOption1 + 1;

                    yyC = character(yyIndex);
                    if ('i' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('n' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('a' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('l' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('l' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyC = character(yyIndex);
                              if ('y' == yyC) {
                                yyIndex = yyIndex + 1;

                                yyResult = pExpr(yyIndex);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {
                                  Node v$el$3 = yyResult.semanticValue();

                                  yyOption1  = yyResult.index;
                                  yyOpValue1 = v$el$3;
                                }
                              } else {
                                yyError = yyError.select("\"finally\" expected", yyBase);
                              }
                            } else {
                              yyError = yyError.select("\"finally\" expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("\"finally\" expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("\"finally\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"finally\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"finally\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"finally\" expected", yyBase);
                  }
                  { // Start scope for v$g$14.
                    Node v$g$14 = yyOpValue1;

                    yyValue = GNode.create("ExprNotFun", v$g$10, v$g$11, v$g$12, v$g$13, v$g$14);

                    return new SemanticValue(yyValue, yyOption1, yyError);
                  } // End scope for v$g$14.
                } // End scope for v$g$13.
              } else {
                yyError = yyError.select("\"}\" expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("\"{\" expected", yyBase);
          }
        }
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pExpr(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$15 = yyResult.semanticValue();

          yyOption1  = yyResult.index;

          yyResult = psemi(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          yyBase = yyOption1;
          yyC    = character(yyBase);
          if ('w' == yyC) {
            yyIndex = yyOption1 + 1;

            yyC = character(yyIndex);
            if ('h' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('l' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyBase = yyIndex;
                    yyC    = character(yyBase);
                    if ('(' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyResult = pExpr(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Node v$g$16 = yyResult.semanticValue();

                        yyBase = yyResult.index;
                        yyC    = character(yyBase);
                        if (')' == yyC) {
                          yyIndex = yyResult.index + 1;

                          yyValue = GNode.create("ExprNotFun", v$g$15, v$g$16);

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        } else {
                          yyError = yyError.select("\")\" expected", yyBase);
                        }
                      }
                    } else {
                      yyError = yyError.select("\"(\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"while\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"while\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"while\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"while\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"while\" expected", yyBase);
          }
        }
      }
    }

    // Alternative 5.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pExprNotFun$$Choice1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$17 = yyResult.semanticValue();

            yyResult = p$$Shared3(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;

              yyBase = yyOption1;
              yyC    = character(yyBase);
              if ('y' == yyC) {
                yyIndex = yyOption1 + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('l' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('d' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyOption1  = yyIndex;
                      } else {
                        yyError = yyError.select("\"yield\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"yield\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"yield\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"yield\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"yield\" expected", yyBase);
              }

              yyResult = pExpr(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$g$18 = yyResult.semanticValue();

                yyValue = GNode.create("ExprNotFun", v$g$17, v$g$18);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Alternative 6.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('w' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pExpr(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$g$19 = yyResult.semanticValue();

                yyValue = GNode.create("ExprNotFun", v$g$19);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Alternative 7.

    yyC = character(yyStart);
    if ('r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyOption1  = yyIndex;
                yyOpValue1 = null;

                yyResult = pExpr(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Node v$el$6 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$6;
                }
                { // Start scope for v$g$20.
                  Node v$g$20 = yyOpValue1;

                  yyValue = GNode.create("ExprNotFun", v$g$20);

                  return new SemanticValue(yyValue, yyOption1, yyError);
                } // End scope for v$g$20.
              }
            }
          }
        }
      }
    }

    // Alternative 8.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pSimpleExpr(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$7 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('.' == yyC) {
        yyIndex = yyResult.index + 1;

        yyOption1  = yyIndex;
        yyOpValue1 = v$el$7;
      } else {
        yyError = yyError.select("\".\" expected", yyBase);
      }
    }
    { // Start scope for v$g$21.
      Node v$g$21 = yyOpValue1;

      yyResult = pId(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$22 = yyResult.semanticValue();

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('=' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pExpr(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$23 = yyResult.semanticValue();

            yyValue = GNode.create("ExprNotFun", v$g$21, v$g$22, v$g$23);

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("\"=\" expected", yyBase);
        }
      }
    } // End scope for v$g$21.

    // Alternative 9.

    yyResult = pSimpleExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$24 = yyResult.semanticValue();

      yyResult = pArgumentExprs(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$25 = yyResult.semanticValue();

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('=' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pExpr(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$26 = yyResult.semanticValue();

            yyValue = GNode.create("ExprNotFun", v$g$24, v$g$25, v$g$26);

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("\"=\" expected", yyBase);
        }
      }
    }

    // Alternative 10.

    yyResult = pPostfixExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$27 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pAscription(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$28 = yyResult.semanticValue();

        yyValue = GNode.create("ExprNotFun", v$g$27, v$g$28);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('m' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('h' == yyC) {
                yyIndex = yyIndex + 1;

                yyBase = yyIndex;
                yyC    = character(yyBase);
                if ('{' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyResult = pCaseClauses(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Node v$g$29 = yyResult.semanticValue();

                    yyBase = yyResult.index;
                    yyC    = character(yyBase);
                    if ('}' == yyC) {
                      yyIndex = yyResult.index + 1;

                      yyValue = GNode.create("ExprNotFun", v$g$27, v$g$29);

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("\"}\" expected", yyBase);
                    }
                  }
                } else {
                  yyError = yyError.select("\"{\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"match\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"match\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"match\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"match\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"match\" expected", yyBase);
      }

      // Nested alternative 3.

      yyValue = GNode.create("ExprNotFun", v$g$27);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    yyError = yyError.select("expr not fun expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.$$Shared3.
   * This nonterminal represents the duplicate productions 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ExprNotFun$$Star1, 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ExprNotFun$$Star2, 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ExprNotFun$$Star3, 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Dcl$$Star1, 
   * and org.netbeans.modules.scala.editing.rats.ParserScala.Def$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared3(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.f$$Shared3) 
      yyColumn.chunk3.f$$Shared3 = p$$Shared3$1(yyStart);
    return yyColumn.chunk3.f$$Shared3;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.$$Shared3. */
  private Result p$$Shared3$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pnl(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = p$$Shared3(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ExprNotFun$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprNotFun$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pEnumerators(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if (')' == yyC) {
          yyIndex = yyResult.index + 1;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\")\" expected", yyBase);
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pEnumerators(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('}' == yyC) {
          yyIndex = yyResult.index + 1;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"}\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("expr not fun expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.PostfixExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostfixExpr(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fPostfixExpr) 
      yyColumn.chunk3.fPostfixExpr = pPostfixExpr$1(yyStart);
    return yyColumn.chunk3.fPostfixExpr;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.PostfixExpr. */
  private Result pPostfixExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    int        yyOption2;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInfixExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pId(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyOption2  = yyResult.index;

        yyResult = pnl(yyOption2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption2  = yyResult.index;
        }

        yyOption1  = yyOption2;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("PostfixExpr", v$g$1, v$g$2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.InfixExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInfixExpr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPrefixExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pInfixExprRest(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$g$2.
        Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("InfixExpr", v$g$1, v$g$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.InfixExprRest.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInfixExprRest(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;

      yyResult = pnl(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }

      yyResult = pPrefixExpr(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("InfixExprRest", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.PrefixExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrefixExpr(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fPrefixExpr) 
      yyColumn.chunk3.fPrefixExpr = pPrefixExpr$1(yyStart);
    return yyColumn.chunk3.fPrefixExpr;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.PrefixExpr. */
  private Result pPrefixExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pPrefixExpr$$Choice1(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      String v$g$1 = yyOpValue1;

      yyResult = pSimpleExpr(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("PrefixExpr", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.PrefixExpr$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrefixExpr$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "-";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "+";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('~' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "~";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "!";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("prefix expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.SimpleExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExpr(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fSimpleExpr) 
      yyColumn.chunk3.fSimpleExpr = pSimpleExpr$1(yyStart);
    return yyColumn.chunk3.fSimpleExpr;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.SimpleExpr. */
  private Result pSimpleExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimplePathExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("SimpleExpr", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pSimpleLiteralExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("SimpleExpr", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pSimpleWildCardExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("SimpleExpr", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pSimpleTupleExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$4 = yyResult.semanticValue();

      yyValue = GNode.create("SimpleExpr", v$g$4);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pSimpleBlockExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$5 = yyResult.semanticValue();

      yyValue = GNode.create("SimpleExpr", v$g$5);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pSimpleNewExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$6 = yyResult.semanticValue();

      yyValue = GNode.create("SimpleExpr", v$g$6);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pXmlExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$7 = yyResult.semanticValue();

      yyValue = GNode.create("SimpleExpr", v$g$7);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.SimplePathExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimplePathExpr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPath(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pTypeArgs(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyRepetition1 = yyOption1;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pSimpleExprRest(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$3.
          Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyValue = GNode.create("SimplePathExpr", v$g$3.size() + 2).
            add(v$g$1).add(v$g$2).addAll(v$g$3);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$3.
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.SimpleLiteralExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleLiteralExpr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pTypeArgs(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyRepetition1 = yyOption1;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pSimpleExprRest(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$3.
          Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyValue = GNode.create("SimpleLiteralExpr", v$g$3.size() + 2).
            add(v$g$1).add(v$g$2).addAll(v$g$3);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$3.
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.SimpleWildCardExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleWildCardExpr(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;
      String v$g$1 = "_";

      yyOption1  = yyIndex;
      yyOpValue1 = null;

      yyResult = pTypeArgs(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyRepetition1 = yyOption1;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pSimpleExprRest(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$3.
          Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyValue = GNode.create("SimpleWildCardExpr", v$g$3.size() + 2).
            add(v$g$1).add(v$g$2).addAll(v$g$3);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$3.
      } // End scope for v$g$2.
    }

    // Done.
    yyError = yyError.select("simple wild card expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.SimpleTupleExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleTupleExpr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParenExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pTypeArgs(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyRepetition1 = yyOption1;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pSimpleExprRest(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$3.
          Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyValue = GNode.create("SimpleTupleExpr", v$g$3.size() + 2).
            add(v$g$1).add(v$g$2).addAll(v$g$3);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$3.
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.SimpleBlockExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleBlockExpr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBlockExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pTypeArgs(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyRepetition1 = yyOption1;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pSimpleExprRest(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$3.
          Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyValue = GNode.create("SimpleBlockExpr", v$g$3.size() + 2).
            add(v$g$1).add(v$g$2).addAll(v$g$3);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$3.
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.SimpleNewExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleNewExpr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNewExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pTypeArgs(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyRepetition1 = yyOption1;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pSimpleExprRest(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$3.
          Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyValue = GNode.create("SimpleNewExpr", v$g$3.size() + 2).
            add(v$g$1).add(v$g$2).addAll(v$g$3);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$3.
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.SimpleExprRest.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExprRest(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fSimpleExprRest) 
      yyColumn.chunk3.fSimpleExprRest = pSimpleExprRest$1(yyStart);
    return yyColumn.chunk3.fSimpleExprRest;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.SimpleExprRest. */
  private Result pSimpleExprRest$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimpleExprRest$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("SimpleExprRest", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pSimpleExprRest$$Plus2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Node> v$g$2 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("SimpleExprRest", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;
      String v$g$3 = "_";

      yyValue = GNode.create("SimpleExprRest", v$g$3);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("simple expr rest expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.SimpleExprRest$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExprRest$$Plus1(final int yyStart) 
    throws IOException {

    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fSimpleExprRest$$Plus1) 
      yyColumn.chunk3.fSimpleExprRest$$Plus1 = pSimpleExprRest$$Plus1$1(yyStart);
    return yyColumn.chunk3.fSimpleExprRest$$Plus1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.SimpleExprRest$$Plus1. */
  private Result pSimpleExprRest$$Plus1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPathRest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pSimpleExprRest$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Node>(v$el$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.SimpleExprRest$$Plus2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleExprRest$$Plus2(final int yyStart) 
    throws IOException {

    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fSimpleExprRest$$Plus2) 
      yyColumn.chunk4.fSimpleExprRest$$Plus2 = pSimpleExprRest$$Plus2$1(yyStart);
    return yyColumn.chunk4.fSimpleExprRest$$Plus2;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.SimpleExprRest$$Plus2. */
  private Result pSimpleExprRest$$Plus2$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArgumentExprs(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$3 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pSimpleExprRest$$Plus2(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$4 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$3, v$4);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Node>(v$el$3);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.PathRest.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPathRest(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pPath(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pTypeArgs(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$2.
          Node v$g$2 = yyOpValue1;

          yyValue = GNode.create("PathRest", v$g$1, v$g$2);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("path rest expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.NewExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNewExpr(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('n' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('w' == yyC) {
          yyIndex = yyIndex + 1;

          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pClassTemplate(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$1 = yyResult.semanticValue();

            yyValue = GNode.create("NewExpr", v$g$1);

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyResult = pTemplateBody(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("NewExpr", v$g$2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("new expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Exprs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExprs(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase = yyRepetition1;
        yyC    = character(yyBase);
        if (',' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyResult = pExpr(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("\",\" expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("Exprs", v$g$1, v$g$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ArgumentExprs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgumentExprs(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fArgumentExprs) 
      yyColumn.chunk4.fArgumentExprs = pArgumentExprs$1(yyStart);
    return yyColumn.chunk4.fArgumentExprs;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ArgumentExprs. */
  private Result pArgumentExprs$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParenExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("ArgumentExprs", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pnl(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$2.
      String v$g$2 = yyOpValue1;

      yyResult = pBlockExpr(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$3 = yyResult.semanticValue();

        yyValue = GNode.create("ArgumentExprs", v$g$2, v$g$3);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for v$g$2.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ParenExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParenExpr(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fParenExpr) 
      yyColumn.chunk4.fParenExpr = pParenExpr$1(yyStart);
    return yyColumn.chunk4.fParenExpr;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ParenExpr. */
  private Result pParenExpr$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    int        yyOption2;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyOption1  = yyIndex;
      yyOpValue1 = null;

      yyResult = pExprs(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyOption2  = yyResult.index;

        yyBase = yyOption2;
        yyC    = character(yyBase);
        if (',' == yyC) {
          yyIndex = yyOption2 + 1;

          yyOption2  = yyIndex;
        } else {
          yyError = yyError.select("\",\" expected", yyBase);
        }

        yyOption1  = yyOption2;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        Node v$g$1 = yyOpValue1;

        yyBase = yyOption1;
        yyC    = character(yyBase);
        if (')' == yyC) {
          yyIndex = yyOption1 + 1;

          yyValue = GNode.create("ParenExpr", v$g$1);

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\")\" expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("paren expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.BlockExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockExpr(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fBlockExpr) 
      yyColumn.chunk4.fBlockExpr = pBlockExpr$1(yyStart);
    return yyColumn.chunk4.fBlockExpr;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.BlockExpr. */
  private Result pBlockExpr$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      final int yyChoice1 = yyIndex;

      // Nested alternative 1.

      yyResult = pCaseClauses(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$1 = yyResult.semanticValue();

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('}' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = GNode.create("BlockExpr", v$g$1);

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"}\" expected", yyBase);
        }
      }

      // Nested alternative 2.

      yyResult = pBlock(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('}' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = GNode.create("BlockExpr", v$g$2);

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"}\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("block expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Block.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlock(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fBlock) 
      yyColumn.chunk4.fBlock = pBlock$1(yyStart);
    return yyColumn.chunk4.fBlock;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Block. */
  private Result pBlock$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBlock$$Star1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Node> v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pResultExpr(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$4 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$4;
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("Block", v$g$1.size() + 1).
          addAll(v$g$1).add(v$g$2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Block$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlock$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fBlock$$Star1) 
      yyColumn.chunk4.fBlock$$Star1 = pBlock$$Star1$1(yyStart);
    return yyColumn.chunk4.fBlock$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Block$$Star1. */
  private Result pBlock$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pBlockStat(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$2 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$2;
    }
    { // Start scope for v$el$1.
      Node v$el$1 = yyOpValue1;

      yyResult = psemi(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBlock$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$3 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$3);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    } // End scope for v$el$1.

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.BlockStat.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockStat(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fBlockStat) 
      yyColumn.chunk4.fBlockStat = pBlockStat$1(yyStart);
    return yyColumn.chunk4.fBlockStat;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.BlockStat. */
  private Result pBlockStat$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pImport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("BlockStat", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyOption1  = yyStart;

    yyBase = yyOption1;
    yyC    = character(yyBase);
    if ('i' == yyC) {
      yyIndex = yyOption1 + 1;

      yyC = character(yyIndex);
      if ('m' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('c' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('t' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyOption1  = yyIndex;
                  } else {
                    yyError = yyError.select("\"implicit\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"implicit\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"implicit\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"implicit\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"implicit\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"implicit\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"implicit\" expected", yyBase);
      }
    } else {
      yyError = yyError.select("\"implicit\" expected", yyBase);
    }

    yyResult = pDef(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("BlockStat", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pBlockStat$$Star1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Node> v$g$3 = yyResult.semanticValue();

      yyResult = pTmplDef(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$4 = yyResult.semanticValue();

        yyValue = GNode.create("BlockStat", v$g$3.size() + 1).
          addAll(v$g$3).add(v$g$4);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pExprNotFun(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$5 = yyResult.semanticValue();

      yyValue = GNode.create("BlockStat", v$g$5);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.BlockStat$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlockStat$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fBlockStat$$Star1) 
      yyColumn.chunk4.fBlockStat$$Star1 = pBlockStat$$Star1$1(yyStart);
    return yyColumn.chunk4.fBlockStat$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.BlockStat$$Star1. */
  private Result pBlockStat$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLocalModifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$1 = yyResult.semanticValue();

      yyResult = pBlockStat$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ResultExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pResultExpr(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <ResultNotFun>.

    yyResult = pExprNotFun(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("ResultExpr", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <FunResult>.

    yyResult = pResultExpr$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('=' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pBlock(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$3 = yyResult.semanticValue();

            yyValue = GNode.create("ResultExpr", v$g$2, v$g$3);

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("\"=>\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"=>\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ResultExpr$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pResultExpr$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBindings(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pResultBinding(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ResultBinding.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pResultBinding(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (':' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pCompoundType(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("ResultBinding", v$g$1, v$g$2);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\":\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Enumerators.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnumerators(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fEnumerators) 
      yyColumn.chunk4.fEnumerators = pEnumerators$1(yyStart);
    return yyColumn.chunk4.fEnumerators;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Enumerators. */
  private Result pEnumerators$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pGenerator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pEnumerators$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("Enumerators", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Enumerators$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnumerators$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fEnumerators$$Star1) 
      yyColumn.chunk4.fEnumerators$$Star1 = pEnumerators$$Star1$1(yyStart);
    return yyColumn.chunk4.fEnumerators$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Enumerators$$Star1. */
  private Result pEnumerators$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psemi(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pEnumerator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyResult = pEnumerators$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Enumerator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnumerator(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pGenerator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Enumerator", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pGuard(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("Enumerator", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;
          String v$g$3 = "val";

          yyResult = pPattern1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$4 = yyResult.semanticValue();

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if ('=' == yyC) {
              yyIndex = yyResult.index + 1;
              String v$g$5 = "=";

              yyResult = pExpr(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$g$6 = yyResult.semanticValue();

                yyValue = GNode.create("Enumerator", v$g$3, v$g$4, v$g$5, v$g$6);

                return yyResult.createValue(yyValue, yyError);
              }
            } else {
              yyError = yyError.select("\"=\" expected", yyBase);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("enumerator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Generator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGenerator(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fGenerator) 
      yyColumn.chunk5.fGenerator = pGenerator$1(yyStart);
    return yyColumn.chunk5.fGenerator;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Generator. */
  private Result pGenerator$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPattern1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('<' == yyC) {
        yyIndex = yyResult.index + 1;

        yyC = character(yyIndex);
        if ('-' == yyC) {
          yyIndex = yyIndex + 1;
          String v$g$2 = "<-";

          yyResult = pExpr(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pGuard(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
            { // Start scope for v$g$4.
              Node v$g$4 = yyOpValue1;

              yyValue = GNode.create("Generator", v$g$1, v$g$2, v$g$3, v$g$4);

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for v$g$4.
          }
        } else {
          yyError = yyError.select("\"<-\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"<-\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.CaseClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseClauses(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fCaseClauses) 
      yyColumn.chunk5.fCaseClauses = pCaseClauses$1(yyStart);
    return yyColumn.chunk5.fCaseClauses;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.CaseClauses. */
  private Result pCaseClauses$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCaseClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pCaseClauses$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("CaseClauses", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.CaseClauses$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseClauses$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fCaseClauses$$Star1) 
      yyColumn.chunk5.fCaseClauses$$Star1 = pCaseClauses$$Star1$1(yyStart);
    return yyColumn.chunk5.fCaseClauses$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.CaseClauses$$Star1. */
  private Result pCaseClauses$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCaseClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$1 = yyResult.semanticValue();

      yyResult = pCaseClauses$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.CaseClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseClause(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fCaseClause) 
      yyColumn.chunk5.fCaseClause = pCaseClause$1(yyStart);
    return yyColumn.chunk5.fCaseClause;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.CaseClause. */
  private Result pCaseClause$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pPattern(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$g$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pGuard(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$el$1 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$1;
              }
              { // Start scope for v$g$2.
                Node v$g$2 = yyOpValue1;

                yyBase = yyOption1;
                yyC    = character(yyBase);
                if ('=' == yyC) {
                  yyIndex = yyOption1 + 1;

                  yyC = character(yyIndex);
                  if ('>' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyResult = pBlock(yyIndex);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Node v$g$3 = yyResult.semanticValue();

                      yyValue = GNode.create("CaseClause", v$g$1, v$g$2, v$g$3);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  } else {
                    yyError = yyError.select("\"=>\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"=>\" expected", yyBase);
                }
              } // End scope for v$g$2.
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("case clause expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Guard.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGuard(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fGuard) 
      yyColumn.chunk5.fGuard = pGuard$1(yyStart);
    return yyColumn.chunk5.fGuard;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Guard. */
  private Result pGuard$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('f' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pPostfixExpr(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$1 = yyResult.semanticValue();

          yyValue = GNode.create("Guard", v$g$1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("guard expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Pattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPattern(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fPattern) 
      yyColumn.chunk5.fPattern = pPattern$1(yyStart);
    return yyColumn.chunk5.fPattern;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Pattern. */
  private Result pPattern$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPattern1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pPattern$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("Pattern", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Pattern$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPattern$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fPattern$$Star1) 
      yyColumn.chunk5.fPattern$$Star1 = pPattern$$Star1$1(yyStart);
    return yyColumn.chunk5.fPattern$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Pattern$$Star1. */
  private Result pPattern$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pPattern1(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyResult = pPattern$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Pattern1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPattern1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fPattern1) 
      yyColumn.chunk5.fPattern1 = pPattern1$1(yyStart);
    return yyColumn.chunk5.fPattern1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Pattern1. */
  private Result pPattern1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pvarid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (':' == yyC) {
        yyIndex = yyResult.index + 1;
        String v$g$2 = ":";

        yyResult = pTypePat(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("Pattern1", v$g$1, v$g$2, v$g$3);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\":\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;
      String v$g$4 = "_";

      yyBase = yyIndex;
      yyC    = character(yyBase);
      if (':' == yyC) {
        yyIndex = yyIndex + 1;
        String v$g$5 = ":";

        yyResult = pTypePat(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$6 = yyResult.semanticValue();

          yyValue = GNode.create("Pattern1", v$g$4, v$g$5, v$g$6);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\":\" expected", yyBase);
      }
    }

    // Alternative 3.

    yyResult = pPattern2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$7 = yyResult.semanticValue();

      yyValue = GNode.create("Pattern1", v$g$7);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("pattern1 expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Pattern2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPattern2(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fPattern2) 
      yyColumn.chunk5.fPattern2 = pPattern2$1(yyStart);
    return yyColumn.chunk5.fPattern2;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Pattern2. */
  private Result pPattern2$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pvarid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase = yyOption1;
      yyC    = character(yyBase);
      if ('@' == yyC) {
        yyIndex = yyOption1 + 1;

        yyResult = pPattern3(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      } else {
        yyError = yyError.select("\"@\" expected", yyBase);
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("Pattern2", v$g$1, v$g$2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Alternative 2.

    yyResult = pPattern3(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("Pattern2", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Pattern3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPattern3(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fPattern3) 
      yyColumn.chunk5.fPattern3 = pPattern3$1(yyStart);
    return yyColumn.chunk5.fPattern3;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Pattern3. */
  private Result pPattern3$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimplePattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pPattern3$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("Pattern3", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = GNode.create("Pattern3", v$g$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Pattern3$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPattern3$$Plus1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fPattern3$$Plus1) 
      yyColumn.chunk6.fPattern3$$Plus1 = pPattern3$$Plus1$1(yyStart);
    return yyColumn.chunk6.fPattern3$$Plus1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Pattern3$$Plus1. */
  private Result pPattern3$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPattern3Rest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pPattern3$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Node>(v$el$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Pattern3Rest.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPattern3Rest(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;

      yyResult = pnl(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }

      yyResult = pSimplePattern(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("Pattern3Rest", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.SimplePattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimplePattern(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fSimplePattern) 
      yyColumn.chunk6.fSimplePattern = pSimplePattern$1(yyStart);
    return yyColumn.chunk6.fSimplePattern;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.SimplePattern. */
  private Result pSimplePattern$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue("_")) {
      String v$g$1 = "_";

      yyValue = GNode.create("SimplePattern", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("SimplePattern", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pTuplePattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("SimplePattern", v$g$3);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pStableId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$4 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pTuplePattern(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$5 = yyResult.semanticValue();

        yyValue = GNode.create("SimplePattern", v$g$4, v$g$5);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('(' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyOption1  = yyIndex;
        yyOpValue1 = null;

        yyResult = pPatterns(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if (',' == yyC) {
            yyIndex = yyResult.index + 1;

            yyOption1  = yyIndex;
            yyOpValue1 = v$el$1;
          } else {
            yyError = yyError.select("\",\" expected", yyBase);
          }
        }
        { // Start scope for v$g$6.
          Node v$g$6 = yyOpValue1;

          yyBase = yyOption1;
          yyC    = character(yyBase);
          if ('_' == yyC) {
            yyIndex = yyOption1 + 1;

            yyBase = yyIndex;
            yyC    = character(yyBase);
            if ('*' == yyC) {
              yyIndex = yyIndex + 1;

              yyBase = yyIndex;
              yyC    = character(yyBase);
              if (')' == yyC) {
                yyIndex = yyIndex + 1;

                yyValue = GNode.create("SimplePattern", v$g$4, v$g$6);

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("\")\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"*\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"_\" expected", yyBase);
          }
        } // End scope for v$g$6.
      } else {
        yyError = yyError.select("\"(\" expected", yyBase);
      }

      // Nested alternative 3.

      yyValue = GNode.create("SimplePattern", v$g$4);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Alternative 5.

    yyResult = pvarid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$7 = yyResult.semanticValue();

      yyValue = GNode.create("SimplePattern", v$g$7);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("simple pattern expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TuplePattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTuplePattern(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fTuplePattern) 
      yyColumn.chunk6.fTuplePattern = pTuplePattern$1(yyStart);
    return yyColumn.chunk6.fTuplePattern;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.TuplePattern. */
  private Result pTuplePattern$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    int        yyOption2;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyOption1  = yyIndex;
      yyOpValue1 = null;

      yyResult = pPatterns(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyOption2  = yyResult.index;

        yyBase = yyOption2;
        yyC    = character(yyBase);
        if (',' == yyC) {
          yyIndex = yyOption2 + 1;

          yyOption2  = yyIndex;
        } else {
          yyError = yyError.select("\",\" expected", yyBase);
        }

        yyOption1  = yyOption2;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        Node v$g$1 = yyOpValue1;

        yyBase = yyOption1;
        yyC    = character(yyBase);
        if (')' == yyC) {
          yyIndex = yyOption1 + 1;

          yyValue = GNode.create("TuplePattern", v$g$1);

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\")\" expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("tuple pattern expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Patterns.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatterns(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fPatterns) 
      yyColumn.chunk6.fPatterns = pPatterns$1(yyStart);
    return yyColumn.chunk6.fPatterns;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Patterns. */
  private Result pPatterns$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pPatterns$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("Patterns", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;
      String v$g$3 = "_";

      yyBase = yyIndex;
      yyC    = character(yyBase);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;
        String v$g$4 = "*";

        yyValue = GNode.create("Patterns", v$g$3, v$g$4);

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("\"*\" expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("patterns expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Patterns$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatterns$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fPatterns$$Star1) 
      yyColumn.chunk6.fPatterns$$Star1 = pPatterns$$Star1$1(yyStart);
    return yyColumn.chunk6.fPatterns$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Patterns$$Star1. */
  private Result pPatterns$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pPattern(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyResult = pPatterns$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TypeParamClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeParamClause(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fTypeParamClause) 
      yyColumn.chunk6.fTypeParamClause = pTypeParamClause$1(yyStart);
    return yyColumn.chunk6.fTypeParamClause;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.TypeParamClause. */
  private Result pTypeParamClause$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;
      String v$g$1 = "[";

      yyResult = pVariantTypeParam(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyResult = pTypeParamClause$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$g$3 = yyResult.semanticValue();

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if (']' == yyC) {
            yyIndex = yyResult.index + 1;
            String v$g$4 = "]";

            yyValue = GNode.create("TypeParamClause", v$g$3.size() + 3).
              add(v$g$1).add(v$g$2).addAll(v$g$3).add(v$g$4);

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("\"]\" expected", yyBase);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("type param clause expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TypeParamClause$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeParamClause$$Star1(final int yyStart) 
    throws IOException {

    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fTypeParamClause$$Star1) 
      yyColumn.chunk6.fTypeParamClause$$Star1 = pTypeParamClause$$Star1$1(yyStart);
    return yyColumn.chunk6.fTypeParamClause$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.TypeParamClause$$Star1. */
  private Result pTypeParamClause$$Star1$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pVariantTypeParam(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyResult = pTypeParamClause$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.FunTypeParamClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunTypeParamClause(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;
      String v$g$1 = "[";

      yyResult = pTypeParam(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if (',' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyResult = pTypeParam(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("\",\" expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$3.
          Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if (']' == yyC) {
            yyIndex = yyRepetition1 + 1;
            String v$g$4 = "]";

            yyValue = GNode.create("FunTypeParamClause", v$g$3.size() + 3).
              add(v$g$1).add(v$g$2).addAll(v$g$3).add(v$g$4);

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("\"]\" expected", yyBase);
          }
        } // End scope for v$g$3.
      }
    }

    // Done.
    yyError = yyError.select("fun type param clause expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.VariantTypeParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariantTypeParam(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fVariantTypeParam) 
      yyColumn.chunk6.fVariantTypeParam = pVariantTypeParam$1(yyStart);
    return yyColumn.chunk6.fVariantTypeParam;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.VariantTypeParam. */
  private Result pVariantTypeParam$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pVariantTypeParam$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyResult = pTypeParam(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("VariantTypeParam", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.VariantTypeParam$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariantTypeParam$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "+";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "-";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("variant type param expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TypeParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeParam(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fTypeParam) 
      yyColumn.chunk6.fTypeParam = pTypeParam$1(yyStart);
    return yyColumn.chunk6.fTypeParam;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.TypeParam. */
  private Result pTypeParam$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypeParam$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Object v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pTypeParamClause(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$3 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$3;
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyOpValue1 = null;

        yyBase = yyOption1;
        yyC    = character(yyBase);
        if ('>' == yyC) {
          yyIndex = yyOption1 + 1;

          yyC = character(yyIndex);
          if (':' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pType(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$el$4 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$4;
            }
          } else {
            yyError = yyError.select("\">:\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\">:\" expected", yyBase);
        }
        { // Start scope for v$g$3.
          Node v$g$3 = yyOpValue1;

          yyOpValue1 = null;

          yyBase = yyOption1;
          yyC    = character(yyBase);
          if ('<' == yyC) {
            yyIndex = yyOption1 + 1;

            yyC = character(yyIndex);
            if (':' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pType(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$el$5 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$5;
              }
            } else {
              yyError = yyError.select("\"<:\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"<:\" expected", yyBase);
          }
          { // Start scope for v$g$4.
            Node v$g$4 = yyOpValue1;

            yyOpValue1 = null;

            yyBase = yyOption1;
            yyC    = character(yyBase);
            if ('<' == yyC) {
              yyIndex = yyOption1 + 1;

              yyC = character(yyIndex);
              if ('%' == yyC) {
                yyIndex = yyIndex + 1;

                yyResult = pType(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Node v$el$6 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$6;
                }
              } else {
                yyError = yyError.select("\"<%\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"<%\" expected", yyBase);
            }
            { // Start scope for v$g$5.
              Node v$g$5 = yyOpValue1;

              yyValue = GNode.create("TypeParam", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for v$g$5.
          } // End scope for v$g$4.
        } // End scope for v$g$3.
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TypeParam$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeParam$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "_";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("type param expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ParamClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParamClauses(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fParamClauses) 
      yyColumn.chunk6.fParamClauses = pParamClauses$1(yyStart);
    return yyColumn.chunk6.fParamClauses;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ParamClauses. */
  private Result pParamClauses$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    int        yyOption2;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParamClauses$$Star1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Node> v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyOption2  = yyOption1;

      yyResult = pnl(yyOption2);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption2  = yyResult.index;
      }

      yyBase = yyOption2;
      yyC    = character(yyBase);
      if ('(' == yyC) {
        yyIndex = yyOption2 + 1;

        yyBase = yyIndex;
        yyC    = character(yyBase);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('p' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('l' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('c' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('i' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('t' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyResult = pParams(yyIndex);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          Node v$el$3 = yyResult.semanticValue();

                          yyBase = yyResult.index;
                          yyC    = character(yyBase);
                          if (')' == yyC) {
                            yyIndex = yyResult.index + 1;

                            yyOption1  = yyIndex;
                            yyOpValue1 = v$el$3;
                          } else {
                            yyError = yyError.select("\")\" expected", yyBase);
                          }
                        }
                      } else {
                        yyError = yyError.select("\"implicit\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"implicit\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"implicit\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"implicit\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"implicit\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"implicit\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"implicit\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"implicit\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"(\" expected", yyBase);
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("ParamClauses", v$g$1.size() + 1).
          addAll(v$g$1).add(v$g$2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ParamClauses$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParamClauses$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fParamClauses$$Star1) 
      yyColumn.chunk7.fParamClauses$$Star1 = pParamClauses$$Star1$1(yyStart);
    return yyColumn.chunk7.fParamClauses$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ParamClauses$$Star1. */
  private Result pParamClauses$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParamClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$1 = yyResult.semanticValue();

      yyResult = pParamClauses$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ParamClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParamClause(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fParamClause) 
      yyColumn.chunk7.fParamClause = pParamClause$1(yyStart);
    return yyColumn.chunk7.fParamClause;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ParamClause. */
  private Result pParamClause$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pnl(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      String v$g$1 = cast(yyOpValue1);

      yyBase = yyOption1;
      yyC    = character(yyBase);
      if ('(' == yyC) {
        yyIndex = yyOption1 + 1;
        String v$g$2 = "(";

        yyOption1  = yyIndex;
        yyOpValue1 = null;

        yyResult = pParams(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$3.
          Node v$g$3 = cast(yyOpValue1);

          yyBase = yyOption1;
          yyC    = character(yyBase);
          if (')' == yyC) {
            yyIndex = yyOption1 + 1;
            String v$g$4 = ")";

            yyValue = GNode.create("ParamClause", v$g$1, v$g$2, v$g$3, v$g$4);

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("\")\" expected", yyBase);
          }
        } // End scope for v$g$3.
      } else {
        yyError = yyError.select("\"(\" expected", yyBase);
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Params.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParams(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fParams) 
      yyColumn.chunk7.fParams = pParams$1(yyStart);
    return yyColumn.chunk7.fParams;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Params. */
  private Result pParams$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParam(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pParams$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("Params", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Params$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParams$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fParams$$Star1) 
      yyColumn.chunk7.fParams$$Star1 = pParams$$Star1$1(yyStart);
    return yyColumn.chunk7.fParams$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Params$$Star1. */
  private Result pParams$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pParam(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyResult = pParams$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Param.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParam(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fParam) 
      yyColumn.chunk7.fParam = pParam$1(yyStart);
    return yyColumn.chunk7.fParam;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Param. */
  private Result pParam$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Node> v$g$1 = yyResult.semanticValue();

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyBase = yyOption1;
        yyC    = character(yyBase);
        if (':' == yyC) {
          yyIndex = yyOption1 + 1;

          yyResult = pParamType(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
        } else {
          yyError = yyError.select("\":\" expected", yyBase);
        }
        { // Start scope for v$g$3.
          Node v$g$3 = yyOpValue1;

          yyValue = GNode.create("Param", v$g$1.size() + 2).
            addAll(v$g$1).add(v$g$2).add(v$g$3);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$3.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ParamType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParamType(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fParamType) 
      yyColumn.chunk7.fParamType = pParamType$1(yyStart);
    return yyColumn.chunk7.fParamType;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ParamType. */
  private Result pParamType$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('*' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyValue = GNode.create("ParamType", v$g$1);

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("\"*\" expected", yyBase);
      }

      // Nested alternative 2.

      yyValue = GNode.create("ParamType", v$g$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;
        String v$g$2 = "=>";

        yyResult = pType(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("ParamType", v$g$2, v$g$3);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("param type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ClassParamClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassParamClauses(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyOpValue1;
    int        yyOption2;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pClassParamClause(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$g$1.
      Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyOption1  = yyRepetition1;
      yyOpValue1 = null;

      yyOption2  = yyOption1;

      yyResult = pnl(yyOption2);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption2  = yyResult.index;
      }

      yyBase = yyOption2;
      yyC    = character(yyBase);
      if ('(' == yyC) {
        yyIndex = yyOption2 + 1;

        yyBase = yyIndex;
        yyC    = character(yyBase);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('p' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('l' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('c' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('i' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('t' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyResult = pClassParams(yyIndex);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          Node v$el$2 = yyResult.semanticValue();

                          yyBase = yyResult.index;
                          yyC    = character(yyBase);
                          if (')' == yyC) {
                            yyIndex = yyResult.index + 1;

                            yyOption1  = yyIndex;
                            yyOpValue1 = v$el$2;
                          } else {
                            yyError = yyError.select("\")\" expected", yyBase);
                          }
                        }
                      } else {
                        yyError = yyError.select("\"implicit\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"implicit\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"implicit\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"implicit\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"implicit\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"implicit\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"implicit\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"implicit\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"(\" expected", yyBase);
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("ClassParamClauses", v$g$1.size() + 1).
          addAll(v$g$1).add(v$g$2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ClassParamClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassParamClause(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pnl(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      String v$g$1 = cast(yyOpValue1);

      yyBase = yyOption1;
      yyC    = character(yyBase);
      if ('(' == yyC) {
        yyIndex = yyOption1 + 1;
        String v$g$2 = "(";

        yyOption1  = yyIndex;
        yyOpValue1 = null;

        yyResult = pClassParams(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$3.
          Node v$g$3 = cast(yyOpValue1);

          yyBase = yyOption1;
          yyC    = character(yyBase);
          if (')' == yyC) {
            yyIndex = yyOption1 + 1;
            String v$g$4 = ")";

            yyValue = GNode.create("ClassParamClause", v$g$1, v$g$2, v$g$3, v$g$4);

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("\")\" expected", yyBase);
          }
        } // End scope for v$g$3.
      } else {
        yyError = yyError.select("\"(\" expected", yyBase);
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ClassParams.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassParams(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fClassParams) 
      yyColumn.chunk7.fClassParams = pClassParams$1(yyStart);
    return yyColumn.chunk7.fClassParams;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ClassParams. */
  private Result pClassParams$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pClassParam(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pClassParams$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("ClassParams", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ClassParams$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassParams$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fClassParams$$Star1) 
      yyColumn.chunk7.fClassParams$$Star1 = pClassParams$$Star1$1(yyStart);
    return yyColumn.chunk7.fClassParams$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ClassParams$$Star1. */
  private Result pClassParams$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pClassParam(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyResult = pClassParams$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ClassParam.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassParam(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fClassParam) 
      yyColumn.chunk7.fClassParam = pClassParam$1(yyStart);
    return yyColumn.chunk7.fClassParam;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ClassParam. */
  private Result pClassParam$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Node> v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pClassParam$$Choice1(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$el$3 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$3;
      }
      { // Start scope for v$g$2.
        Pair<Node> v$g$2 = cast(yyOpValue1);

        yyResult = pId(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyBase = yyOption1;
          yyC    = character(yyBase);
          if (':' == yyC) {
            yyIndex = yyOption1 + 1;

            yyResult = pParamType(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$el$7 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$7;
            }
          } else {
            yyError = yyError.select("\":\" expected", yyBase);
          }
          { // Start scope for v$g$4.
            Node v$g$4 = cast(yyOpValue1);

            yyValue = GNode.create("ClassParam", v$g$1.size() + 
              (null == v$g$2 ? 0 : v$g$2.size()) + 2).
              addAll(v$g$1);
            if (null != v$g$2) yyValue.addAll(v$g$2);
            yyValue.add(v$g$3).add(v$g$4);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for v$g$4.
        }
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ClassParam$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassParam$$Star2(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fClassParam$$Star2) 
      yyColumn.chunk7.fClassParam$$Star2 = pClassParam$$Star2$1(yyStart);
    return yyColumn.chunk7.fClassParam$$Star2;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ClassParam$$Star2. */
  private Result pClassParam$$Star2$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pModifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$5 = yyResult.semanticValue();

      yyResult = pClassParam$$Star2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$6 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$5, v$6);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ClassParam$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassParam$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pClassParam$$Star2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative <Val>.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('v' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("\"val\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"val\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"val\" expected", yyBase);
      }

      // Nested alternative <Var>.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('v' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("\"var\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"var\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"var\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Bindings.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBindings(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fBindings) 
      yyColumn.chunk8.fBindings = pBindings$1(yyStart);
    return yyColumn.chunk8.fBindings;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Bindings. */
  private Result pBindings$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pBinding(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$1 = yyResult.semanticValue();

        yyResult = pBindings$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$g$2 = yyResult.semanticValue();

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if (')' == yyC) {
            yyIndex = yyResult.index + 1;

            yyValue = GNode.createFromPair("Bindings", v$g$1, v$g$2);

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("\")\" expected", yyBase);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("bindings expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Bindings$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBindings$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fBindings$$Star1) 
      yyColumn.chunk8.fBindings$$Star1 = pBindings$$Star1$1(yyStart);
    return yyColumn.chunk8.fBindings$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Bindings$$Star1. */
  private Result pBindings$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pBinding(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyResult = pBindings$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Binding.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBinding(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fBinding) 
      yyColumn.chunk8.fBinding = pBinding$1(yyStart);
    return yyColumn.chunk8.fBinding;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Binding. */
  private Result pBinding$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase = yyOption1;
      yyC    = character(yyBase);
      if (':' == yyC) {
        yyIndex = yyOption1 + 1;

        yyResult = pType(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      } else {
        yyError = yyError.select("\":\" expected", yyBase);
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("Binding", v$g$1, v$g$2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Modifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pModifier(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fModifier) 
      yyColumn.chunk8.fModifier = pModifier$1(yyStart);
    return yyColumn.chunk8.fModifier;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Modifier. */
  private Result pModifier$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLocalModifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Modifier", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAccessModifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("Modifier", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('v' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('d' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;
                    String v$g$3 = "override";

                    yyValue = GNode.create("Modifier", v$g$3);

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("modifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.LocalModifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalModifier(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fLocalModifier) 
      yyColumn.chunk8.fLocalModifier = pLocalModifier$1(yyStart);
    return yyColumn.chunk8.fLocalModifier;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.LocalModifier. */
  private Result pLocalModifier$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('b' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('c' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('t' == yyC) {
                    yyIndex = yyIndex + 1;
                    String v$g$1 = "abstract";

                    yyValue = GNode.create("LocalModifier", v$g$1);

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('l' == yyC) {
              yyIndex = yyIndex + 1;
              String v$g$2 = "final";

              yyValue = GNode.create("LocalModifier", v$g$2);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;
                String v$g$3 = "sealed";

                yyValue = GNode.create("LocalModifier", v$g$3);

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }
          }
        }
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('m' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('c' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('t' == yyC) {
                    yyIndex = yyIndex + 1;
                    String v$g$4 = "implicit";

                    yyValue = GNode.create("LocalModifier", v$g$4);

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 5.

    yyC = character(yyStart);
    if ('l' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('z' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('y' == yyC) {
            yyIndex = yyIndex + 1;
            String v$g$5 = "lazy";

            yyValue = GNode.create("LocalModifier", v$g$5);

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("local modifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.AccessModifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAccessModifier(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fAccessModifier) 
      yyColumn.chunk8.fAccessModifier = pAccessModifier$1(yyStart);
    return yyColumn.chunk8.fAccessModifier;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.AccessModifier. */
  private Result pAccessModifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAccessModifier$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pAccessQualifier(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$3 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$3;
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("AccessModifier", v$g$1, v$g$2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.AccessModifier$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAccessModifier$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('v' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;
                  yyValue = "private";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('c' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('t' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('d' == yyC) {
                      yyIndex = yyIndex + 1;
                      yyValue = "protected";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("access modifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.AccessQualifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAccessQualifier(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;
      String v$g$1 = "[";

      yyResult = pAccessQualifier$$Choice1(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Object v$g$2 = yyResult.semanticValue();

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if (']' == yyC) {
          yyIndex = yyResult.index + 1;
          String v$g$3 = "]";

          yyValue = GNode.create("AccessQualifier", v$g$1, v$g$2, v$g$3);

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"]\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("access qualifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.AccessQualifier$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAccessQualifier$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;
            yyValue = "this";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("access qualifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Annotation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAnnotation(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fAnnotation) 
      yyColumn.chunk8.fAnnotation = pAnnotation$1(yyStart);
    return yyColumn.chunk8.fAnnotation;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Annotation. */
  private Result pAnnotation$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('@' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pAnnotationExpr(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pnl(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$2.
          String v$g$2 = yyOpValue1;

          yyValue = GNode.create("Annotation", v$g$1, v$g$2);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("annotation expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.AnnotationExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAnnotationExpr(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Pair<Node> yyOpValue1;
    int        yyOption2;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pConstr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyOption2  = yyOption1;

      yyResult = pnl(yyOption2);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption2  = yyResult.index;
      }

      yyBase = yyOption2;
      yyC    = character(yyBase);
      if ('{' == yyC) {
        yyIndex = yyOption2 + 1;

        yyRepetition1 = yyIndex;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pNameValuePair(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$el$1.
          Pair<Node> v$el$1 = yyRepValue1.reverse();

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if ('}' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyOption1  = yyIndex;
            yyOpValue1 = v$el$1;
          } else {
            yyError = yyError.select("\"}\" expected", yyBase);
          }
        } // End scope for v$el$1.
      } else {
        yyError = yyError.select("\"{\" expected", yyBase);
      }
      { // Start scope for v$g$2.
        Pair<Node> v$g$2 = yyOpValue1;

        yyValue = GNode.create("AnnotationExpr", 
          (null == v$g$2 ? 0 : v$g$2.size()) + 1).
          add(v$g$1);
        if (null != v$g$2) yyValue.addAll(v$g$2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.NameValuePair.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNameValuePair(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;
          String v$g$1 = "val";

          yyResult = pId(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$2 = yyResult.semanticValue();

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if ('=' == yyC) {
              yyIndex = yyResult.index + 1;
              String v$g$3 = "=";

              yyResult = pPrefixExpr(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$g$4 = yyResult.semanticValue();

                yyValue = GNode.create("NameValuePair", v$g$1, v$g$2, v$g$3, v$g$4);

                return yyResult.createValue(yyValue, yyError);
              }
            } else {
              yyError = yyError.select("\"=\" expected", yyBase);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("name value pair expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TemplateBody.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTemplateBody(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fTemplateBody) 
      yyColumn.chunk8.fTemplateBody = pTemplateBody$1(yyStart);
    return yyColumn.chunk8.fTemplateBody;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.TemplateBody. */
  private Result pTemplateBody$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pnl(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      String v$g$1 = cast(yyOpValue1);

      yyBase = yyOption1;
      yyC    = character(yyBase);
      if ('{' == yyC) {
        yyIndex = yyOption1 + 1;
        String v$g$2 = "{";

        yyOption1  = yyIndex;
        yyOpValue1 = null;

        yyResult = pSelfType(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$3.
          Node v$g$3 = cast(yyOpValue1);

          yyOpValue1 = null;

          yyResult = pTemplateStat(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
          { // Start scope for v$g$4.
            Node v$g$4 = cast(yyOpValue1);

            yyResult = pTemplateBody$$Star1(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Node> v$g$5 = yyResult.semanticValue();

              yyBase = yyResult.index;
              yyC    = character(yyBase);
              if ('}' == yyC) {
                yyIndex = yyResult.index + 1;
                String v$g$6 = "}";

                yyValue = GNode.create("TemplateBody", v$g$5.size() + 5).
                  add(v$g$1).add(v$g$2).add(v$g$3).add(v$g$4).addAll(v$g$5).add(v$g$6);

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("\"}\" expected", yyBase);
              }
            }
          } // End scope for v$g$4.
        } // End scope for v$g$3.
      } else {
        yyError = yyError.select("\"{\" expected", yyBase);
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TemplateBody$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTemplateBody$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fTemplateBody$$Star1) 
      yyColumn.chunk8.fTemplateBody$$Star1 = pTemplateBody$$Star1$1(yyStart);
    return yyColumn.chunk8.fTemplateBody$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.TemplateBody$$Star1. */
  private Result pTemplateBody$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psemi(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pTemplateStat(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$4 = yyResult.semanticValue();

        yyResult = pTemplateBody$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$5 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$4, v$5);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TemplateStat.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTemplateStat(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fTemplateStat) 
      yyColumn.chunk8.fTemplateStat = pTemplateStat$1(yyStart);
    return yyColumn.chunk8.fTemplateStat;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.TemplateStat. */
  private Result pTemplateStat$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pImport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("TemplateStat", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = p$$Shared2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Node> v$g$2 = yyResult.semanticValue();

      yyResult = p$$Shared4(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$3 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pDef(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$4 = yyResult.semanticValue();

          yyValue = GNode.create("TemplateStat", v$g$2.size() + v$g$3.size() + 1).
            addAll(v$g$2).addAll(v$g$3).add(v$g$4);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pDcl(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$5 = yyResult.semanticValue();

          yyValue = GNode.create("TemplateStat", v$g$2.size() + v$g$3.size() + 1).
            addAll(v$g$2).addAll(v$g$3).add(v$g$5);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = pExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$6 = yyResult.semanticValue();

      yyValue = GNode.create("TemplateStat", v$g$6);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.$$Shared4.
   * This nonterminal represents the duplicate productions 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TemplateStat$$Star2, 
   * org.netbeans.modules.scala.editing.rats.ParserScala.EarlyDef$$Star2, 
   * and org.netbeans.modules.scala.editing.rats.ParserScala.TopStat$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared4(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.f$$Shared4) 
      yyColumn.chunk9.f$$Shared4 = p$$Shared4$1(yyStart);
    return yyColumn.chunk9.f$$Shared4;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.$$Shared4. */
  private Result p$$Shared4$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pModifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$3 = yyResult.semanticValue();

      yyResult = p$$Shared4(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$4 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$3, v$4);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.SelfType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelfType(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase = yyOption1;
      yyC    = character(yyBase);
      if (':' == yyC) {
        yyIndex = yyOption1 + 1;

        yyResult = pType(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      } else {
        yyError = yyError.select("\":\" expected", yyBase);
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyBase = yyOption1;
        yyC    = character(yyBase);
        if ('=' == yyC) {
          yyIndex = yyOption1 + 1;

          yyC = character(yyIndex);
          if ('>' == yyC) {
            yyIndex = yyIndex + 1;
            String v$g$3 = "=>";

            yyValue = GNode.create("SelfType", v$g$1, v$g$2, v$g$3);

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("\"=>\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"=>\" expected", yyBase);
        }
      } // End scope for v$g$2.
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyBase = yyIndex;
            yyC    = character(yyBase);
            if (':' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pType(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$g$4 = yyResult.semanticValue();

                yyBase = yyResult.index;
                yyC    = character(yyBase);
                if ('=' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyC = character(yyIndex);
                  if ('>' == yyC) {
                    yyIndex = yyIndex + 1;
                    String v$g$5 = "=>";

                    yyValue = GNode.create("SelfType", v$g$4, v$g$5);

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("\"=>\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"=>\" expected", yyBase);
                }
              }
            } else {
              yyError = yyError.select("\":\" expected", yyBase);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("self type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Import.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImport(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fImport) 
      yyColumn.chunk9.fImport = pImport$1(yyStart);
    return yyColumn.chunk9.fImport;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Import. */
  private Result pImport$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('m' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;
                String v$g$1 = "import";

                yyResult = pImportExpr(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Node v$g$2 = yyResult.semanticValue();

                  yyResult = pImport$$Star1(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Pair<Node> v$g$3 = yyResult.semanticValue();

                    yyValue = GNode.create("Import", v$g$3.size() + 2).
                      add(v$g$1).add(v$g$2).addAll(v$g$3);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("import expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Import$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImport$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fImport$$Star1) 
      yyColumn.chunk9.fImport$$Star1 = pImport$$Star1$1(yyStart);
    return yyColumn.chunk9.fImport$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Import$$Star1. */
  private Result pImport$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pImportExpr(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyResult = pImport$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ImportExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImportExpr(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fImportExpr) 
      yyColumn.chunk9.fImportExpr = pImportExpr$1(yyStart);
    return yyColumn.chunk9.fImportExpr;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ImportExpr. */
  private Result pImportExpr$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStableId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('.' == yyC) {
        yyIndex = yyResult.index + 1;
        String v$g$2 = ".";

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyResult = pId(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("ImportExpr", v$g$1, v$g$2, v$g$3);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyBase = yyChoice1;
        yyC    = character(yyBase);
        if ('_' == yyC) {
          yyIndex = yyChoice1 + 1;
          String v$g$4 = "_";

          yyValue = GNode.create("ImportExpr", v$g$1, v$g$2, v$g$4);

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"_\" expected", yyBase);
        }

        // Nested alternative 3.

        yyResult = pImportSelectors(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$5 = yyResult.semanticValue();

          yyValue = GNode.create("ImportExpr", v$g$1, v$g$2, v$g$5);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\".\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ImportSelectors.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImportSelectors(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;
      String v$g$1 = "{";

      yyRepetition1 = yyIndex;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pImportSelector(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if (',' == yyC) {
            yyIndex = yyResult.index + 1;

            yyRepetition1 = yyIndex;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          } else {
            yyError = yyError.select("\",\" expected", yyBase);
          }
        }
        break;
      }
      { // Start scope for v$g$2.
        Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyResult = pImportSelectors$$Choice1(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Object v$g$3 = yyResult.semanticValue();

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if ('}' == yyC) {
            yyIndex = yyResult.index + 1;
            String v$g$4 = "}";

            yyValue = GNode.create("ImportSelectors", v$g$2.size() + 3).
              add(v$g$1).addAll(v$g$2).add(v$g$3).add(v$g$4);

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("\"}\" expected", yyBase);
          }
        }
      } // End scope for v$g$2.
    }

    // Done.
    yyError = yyError.select("import selectors expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ImportSelectors$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImportSelectors$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pImportSelector(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "_";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("import selectors expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ImportSelector.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImportSelector(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fImportSelector) 
      yyColumn.chunk9.fImportSelector = pImportSelector$1(yyStart);
    return yyColumn.chunk9.fImportSelector;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ImportSelector. */
  private Result pImportSelector$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pImportSelector$$Choice1(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Object v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        Object v$g$2 = yyOpValue1;

        yyValue = GNode.create("ImportSelector", v$g$1, v$g$2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ImportSelector$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImportSelector$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyResult = pId(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyBase = yyChoice1;
        yyC    = character(yyBase);
        if ('_' == yyC) {
          yyIndex = yyChoice1 + 1;
          yyValue = "_";

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"_\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("import selector expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Dcl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDcl(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fDcl) yyColumn.chunk9.fDcl = pDcl$1(yyStart);
    return yyColumn.chunk9.fDcl;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Dcl. */
  private Result pDcl$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;
          String v$g$1 = "val";

          yyResult = pValDcl(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("Dcl", v$g$1, v$g$2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;
          String v$g$3 = "var";

          yyResult = pVarDcl(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$4 = yyResult.semanticValue();

            yyValue = GNode.create("Dcl", v$g$3, v$g$4);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('f' == yyC) {
          yyIndex = yyIndex + 1;
          String v$g$5 = "def";

          yyResult = pFunDcl(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$6 = yyResult.semanticValue();

            yyValue = GNode.create("Dcl", v$g$5, v$g$6);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;
            String v$g$7 = "type";

            yyResult = p$$Shared3(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pTypeDcl(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$g$8 = yyResult.semanticValue();

                yyValue = GNode.create("Dcl", v$g$7, v$g$8);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("dcl expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ValDcl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pValDcl(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fValDcl) 
      yyColumn.chunk9.fValDcl = pValDcl$1(yyStart);
    return yyColumn.chunk9.fValDcl;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ValDcl. */
  private Result pValDcl$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIds(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (':' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pType(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("ValDcl", v$g$1, v$g$2);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\":\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.VarDcl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVarDcl(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIds(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (':' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pType(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("VarDcl", v$g$1, v$g$2);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\":\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.FunDcl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunDcl(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFunSig(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase = yyOption1;
      yyC    = character(yyBase);
      if (':' == yyC) {
        yyIndex = yyOption1 + 1;

        yyResult = pType(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      } else {
        yyError = yyError.select("\":\" expected", yyBase);
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("FunDcl", v$g$1, v$g$2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.FunSig.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunSig(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fFunSig) 
      yyColumn.chunk9.fFunSig = pFunSig$1(yyStart);
    return yyColumn.chunk9.fFunSig;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.FunSig. */
  private Result pFunSig$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pFunTypeParamClause(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyResult = pParamClauses(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("FunSig", v$g$1, v$g$2, v$g$3);

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TypeDcl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeDcl(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fTypeDcl) 
      yyColumn.chunk9.fTypeDcl = pTypeDcl$1(yyStart);
    return yyColumn.chunk9.fTypeDcl;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.TypeDcl. */
  private Result pTypeDcl$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pTypeParamClause(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyOpValue1 = null;

        yyBase = yyOption1;
        yyC    = character(yyBase);
        if ('>' == yyC) {
          yyIndex = yyOption1 + 1;

          yyC = character(yyIndex);
          if (':' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pType(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          } else {
            yyError = yyError.select("\">:\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\">:\" expected", yyBase);
        }
        { // Start scope for v$g$3.
          Node v$g$3 = yyOpValue1;

          yyOpValue1 = null;

          yyBase = yyOption1;
          yyC    = character(yyBase);
          if ('<' == yyC) {
            yyIndex = yyOption1 + 1;

            yyC = character(yyIndex);
            if (':' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pType(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$el$3 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$3;
              }
            } else {
              yyError = yyError.select("\"<:\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"<:\" expected", yyBase);
          }
          { // Start scope for v$g$4.
            Node v$g$4 = yyOpValue1;

            yyValue = GNode.create("TypeDcl", v$g$1, v$g$2, v$g$3, v$g$4);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for v$g$4.
        } // End scope for v$g$3.
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.PatVarDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatVarDef(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fPatVarDef) 
      yyColumn.chunk9.fPatVarDef = pPatVarDef$1(yyStart);
    return yyColumn.chunk9.fPatVarDef;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.PatVarDef. */
  private Result pPatVarDef$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;
          String v$g$1 = "val";

          yyResult = pPatDef(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("PatVarDef", v$g$1, v$g$2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;
          String v$g$3 = "var";

          yyResult = pVarDef(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$4 = yyResult.semanticValue();

            yyValue = GNode.create("PatVarDef", v$g$3, v$g$4);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("pat var def expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Def.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDef(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fDef) 
      yyColumn.chunk10.fDef = pDef$1(yyStart);
    return yyColumn.chunk10.fDef;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Def. */
  private Result pDef$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPatVarDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Def", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('f' == yyC) {
          yyIndex = yyIndex + 1;

          yyResult = pFunDef(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("Def", v$g$2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = p$$Shared3(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pTypeDef(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$g$3 = yyResult.semanticValue();

                yyValue = GNode.create("Def", v$g$3);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pTmplDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$4 = yyResult.semanticValue();

      yyValue = GNode.create("Def", v$g$4);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("def expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.PatDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatDef(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fPatDef) 
      yyColumn.chunk10.fPatDef = pPatDef$1(yyStart);
    return yyColumn.chunk10.fPatDef;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.PatDef. */
  private Result pPatDef$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPattern2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pPatDef$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyBase = yyOption1;
        yyC    = character(yyBase);
        if (':' == yyC) {
          yyIndex = yyOption1 + 1;

          yyResult = pType(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
        } else {
          yyError = yyError.select("\":\" expected", yyBase);
        }
        { // Start scope for v$g$3.
          Node v$g$3 = yyOpValue1;

          yyBase = yyOption1;
          yyC    = character(yyBase);
          if ('=' == yyC) {
            yyIndex = yyOption1 + 1;
            String v$g$4 = "=";

            yyResult = pExpr(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$g$5 = yyResult.semanticValue();

              yyValue = GNode.create("PatDef", v$g$2.size() + 4).
                add(v$g$1).addAll(v$g$2).add(v$g$3).add(v$g$4).add(v$g$5);

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("\"=\" expected", yyBase);
          }
        } // End scope for v$g$3.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.PatDef$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatDef$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fPatDef$$Star1) 
      yyColumn.chunk10.fPatDef$$Star1 = pPatDef$$Star1$1(yyStart);
    return yyColumn.chunk10.fPatDef$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.PatDef$$Star1. */
  private Result pPatDef$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pPattern2(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyResult = pPatDef$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.VarDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVarDef(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPatDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("VarDef", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIds(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (':' == yyC) {
        yyIndex = yyResult.index + 1;
        String v$g$3 = ":";

        yyResult = pType(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$4 = yyResult.semanticValue();

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if ('=' == yyC) {
            yyIndex = yyResult.index + 1;
            String v$g$5 = "=";

            yyBase = yyIndex;
            yyC    = character(yyBase);
            if ('_' == yyC) {
              yyIndex = yyIndex + 1;
              String v$g$6 = "_";

              yyValue = GNode.create("VarDef", v$g$2, v$g$3, v$g$4, v$g$5, v$g$6);

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"_\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"=\" expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("\":\" expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.FunDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunDef(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFunSig(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyBase = yyOption1;
      yyC    = character(yyBase);
      if (':' == yyC) {
        yyIndex = yyOption1 + 1;

        yyResult = pType(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      } else {
        yyError = yyError.select("\":\" expected", yyBase);
      }
      { // Start scope for v$g$2.
        Node v$g$2 = cast(yyOpValue1);

        yyBase = yyOption1;
        yyC    = character(yyBase);
        if ('=' == yyC) {
          yyIndex = yyOption1 + 1;
          String v$g$3 = "=";

          yyResult = pExpr(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$4 = yyResult.semanticValue();

            yyValue = GNode.create("FunDef", v$g$1, v$g$2, v$g$3, v$g$4);

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("\"=\" expected", yyBase);
        }
      } // End scope for v$g$2.

      // Nested alternative 2.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pnl(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
      { // Start scope for v$g$5.
        String v$g$5 = cast(yyOpValue1);

        yyBase = yyOption1;
        yyC    = character(yyBase);
        if ('{' == yyC) {
          yyIndex = yyOption1 + 1;
          String v$g$6 = "{";

          yyResult = pBlock(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$7 = yyResult.semanticValue();

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if ('}' == yyC) {
              yyIndex = yyResult.index + 1;
              String v$g$8 = "}";

              yyValue = GNode.create("FunDef", v$g$1, v$g$5, v$g$6, v$g$7, v$g$8);

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"}\" expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("\"{\" expected", yyBase);
        }
      } // End scope for v$g$5.
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;
            String v$g$9 = "this";

            yyResult = pParamClause(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$g$10 = yyResult.semanticValue();

              yyResult = pParamClauses(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$g$11 = yyResult.semanticValue();

                final int yyChoice1 = yyResult.index;

                // Nested alternative 1.

                yyBase = yyChoice1;
                yyC    = character(yyBase);
                if ('=' == yyC) {
                  yyIndex = yyChoice1 + 1;

                  yyResult = pConstrExpr(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Node v$g$12 = yyResult.semanticValue();

                    yyValue = GNode.create("FunDef", v$g$9, v$g$10, v$g$11, v$g$12);

                    return yyResult.createValue(yyValue, yyError);
                  }
                } else {
                  yyError = yyError.select("\"=\" expected", yyBase);
                }

                // Nested alternative 2.

                yyOption1  = yyChoice1;

                yyResult = pnl(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                }

                yyResult = pConstrBlock(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Node v$g$13 = yyResult.semanticValue();

                  yyValue = GNode.create("FunDef", v$g$9, v$g$10, v$g$11, v$g$13);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("fun def expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TypeDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeDef(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fTypeDef) 
      yyColumn.chunk10.fTypeDef = pTypeDef$1(yyStart);
    return yyColumn.chunk10.fTypeDef;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.TypeDef. */
  private Result pTypeDef$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pTypeParamClause(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyBase = yyOption1;
        yyC    = character(yyBase);
        if ('=' == yyC) {
          yyIndex = yyOption1 + 1;

          yyResult = pType(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$3 = yyResult.semanticValue();

            yyValue = GNode.create("TypeDef", v$g$1, v$g$2, v$g$3);

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("\"=\" expected", yyBase);
        }
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TmplDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTmplDef(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fTmplDef) 
      yyColumn.chunk10.fTmplDef = pTmplDef$1(yyStart);
    return yyColumn.chunk10.fTmplDef;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.TmplDef. */
  private Result pTmplDef$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase = yyOption1;
    yyC    = character(yyBase);
    if ('c' == yyC) {
      yyIndex = yyOption1 + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;
            String v$el$1 = "case";

            yyOption1  = yyIndex;
            yyOpValue1 = v$el$1;
          } else {
            yyError = yyError.select("\"case\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"case\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"case\" expected", yyBase);
      }
    } else {
      yyError = yyError.select("\"case\" expected", yyBase);
    }
    { // Start scope for v$g$1.
      String v$g$1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('c' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('s' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;
                String v$g$2 = "class";

                yyResult = pClassDef(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Node v$g$3 = yyResult.semanticValue();

                  yyValue = GNode.create("TmplDef", v$g$1, v$g$2, v$g$3);

                  return yyResult.createValue(yyValue, yyError);
                }
              } else {
                yyError = yyError.select("\"class\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"class\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"class\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"class\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"class\" expected", yyBase);
      }

      // Nested alternative 2.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('o' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyC = character(yyIndex);
        if ('b' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('j' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('c' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('t' == yyC) {
                  yyIndex = yyIndex + 1;
                  String v$g$4 = "object";

                  yyResult = pObjectDef(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Node v$g$5 = yyResult.semanticValue();

                    yyValue = GNode.create("TmplDef", v$g$1, v$g$4, v$g$5);

                    return yyResult.createValue(yyValue, yyError);
                  }
                } else {
                  yyError = yyError.select("\"object\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"object\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"object\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"object\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"object\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"object\" expected", yyBase);
      }
    } // End scope for v$g$1.

    // Alternative 2.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;
              String v$g$6 = "trait";

              yyResult = pTraitDef(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$g$7 = yyResult.semanticValue();

                yyValue = GNode.create("TmplDef", v$g$6, v$g$7);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("tmpl def expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ClassDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassDef(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pTypeParamClause(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyRepetition1 = yyOption1;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pAnnotation(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$3.
          Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyOption1  = yyRepetition1;
          yyOpValue1 = null;

          yyResult = pAccessModifier(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
          { // Start scope for v$g$4.
            Node v$g$4 = yyOpValue1;

            yyResult = pClassParamClauses(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$g$5 = yyResult.semanticValue();

              yyResult = pClassTemplateOpt(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$g$6 = yyResult.semanticValue();

                yyValue = GNode.create("ClassDef", v$g$3.size() + 5).
                  add(v$g$1).add(v$g$2).addAll(v$g$3).add(v$g$4).add(v$g$5).add(v$g$6);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for v$g$4.
        } // End scope for v$g$3.
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TraitDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitDef(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pTypeParamClause(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        Node v$g$2 = yyOpValue1;

        yyResult = pTraitTemplateOpt(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("TraitDef", v$g$1, v$g$2, v$g$3);

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ObjectDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pObjectDef(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pClassTemplateOpt(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("ObjectDef", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ClassTemplateOpt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassTemplateOpt(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fClassTemplateOpt) 
      yyColumn.chunk10.fClassTemplateOpt = pClassTemplateOpt$1(yyStart);
    return yyColumn.chunk10.fClassTemplateOpt;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ClassTemplateOpt. */
  private Result pClassTemplateOpt$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExtends(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pClassTemplate(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("ClassTemplateOpt", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pClassTemplateOpt$$Choice1(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$3.
      Node v$g$3 = yyOpValue1;

      yyValue = GNode.create("ClassTemplateOpt", v$g$3);

      return new SemanticValue(yyValue, yyOption1, yyError);
    } // End scope for v$g$3.
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ClassTemplateOpt$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassTemplateOpt$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyResult = pTemplateBody(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    yyValue = yyResult.semanticValue();

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (':' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pTemplateBody(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("class template opt expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TraitTemplateOpt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitTemplateOpt(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExtends(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pTraitTemplate(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("TraitTemplateOpt", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pTraitTemplateOpt$$Choice1(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$3.
      Node v$g$3 = yyOpValue1;

      yyValue = GNode.create("TraitTemplateOpt", v$g$3);

      return new SemanticValue(yyValue, yyOption1, yyError);
    } // End scope for v$g$3.
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TraitTemplateOpt$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitTemplateOpt$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyResult = pTemplateBody(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    yyValue = yyResult.semanticValue();

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (':' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pTemplateBody(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("trait template opt expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Extends.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExtends(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fExtends) 
      yyColumn.chunk10.fExtends = pExtends$1(yyStart);
    return yyColumn.chunk10.fExtends;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Extends. */
  private Result pExtends$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('d' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;
                  String v$g$1 = "extends";

                  yyValue = GNode.create("Extends", v$g$1);

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (':' == yyC) {
        yyIndex = yyIndex + 1;
        String v$g$2 = "<:";

        yyValue = GNode.create("Extends", v$g$2);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("extends expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ClassTemplate.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassTemplate(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fClassTemplate) 
      yyColumn.chunk10.fClassTemplate = pClassTemplate$1(yyStart);
    return yyColumn.chunk10.fClassTemplate;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ClassTemplate. */
  private Result pClassTemplate$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    int        yyOption2;
    Node       yyOpValue2;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase = yyOption1;
    yyC    = character(yyBase);
    if ('{' == yyC) {
      yyIndex = yyOption1 + 1;

      yyOption2  = yyIndex;
      yyOpValue2 = null;

      yyResult = pEarlyDefs(yyOption2);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$2 = yyResult.semanticValue();

        yyOption2  = yyResult.index;
        yyOpValue2 = v$el$2;
      }
      { // Start scope for v$el$1.
        Node v$el$1 = yyOpValue2;

        yyBase = yyOption2;
        yyC    = character(yyBase);
        if ('}' == yyC) {
          yyIndex = yyOption2 + 1;

          yyBase = yyIndex;
          yyC    = character(yyBase);
          if ('w' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('h' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyOption1  = yyIndex;
                  yyOpValue1 = v$el$1;
                } else {
                  yyError = yyError.select("\"with\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"with\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"with\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"with\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"}\" expected", yyBase);
        }
      } // End scope for v$el$1.
    } else {
      yyError = yyError.select("\"{\" expected", yyBase);
    }
    { // Start scope for v$g$1.
      Node v$g$1 = yyOpValue1;

      yyResult = pClassParents(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pTemplateBody(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
        { // Start scope for v$g$3.
          Node v$g$3 = yyOpValue1;

          yyValue = GNode.create("ClassTemplate", v$g$1, v$g$2, v$g$3);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$3.
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TraitTemplate.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitTemplate(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    int        yyOption2;
    Node       yyOpValue2;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase = yyOption1;
    yyC    = character(yyBase);
    if ('{' == yyC) {
      yyIndex = yyOption1 + 1;

      yyOption2  = yyIndex;
      yyOpValue2 = null;

      yyResult = pEarlyDefs(yyOption2);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$2 = yyResult.semanticValue();

        yyOption2  = yyResult.index;
        yyOpValue2 = v$el$2;
      }
      { // Start scope for v$el$1.
        Node v$el$1 = yyOpValue2;

        yyBase = yyOption2;
        yyC    = character(yyBase);
        if ('}' == yyC) {
          yyIndex = yyOption2 + 1;

          yyBase = yyIndex;
          yyC    = character(yyBase);
          if ('w' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('h' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyOption1  = yyIndex;
                  yyOpValue1 = v$el$1;
                } else {
                  yyError = yyError.select("\"with\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"with\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"with\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"with\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"}\" expected", yyBase);
        }
      } // End scope for v$el$1.
    } else {
      yyError = yyError.select("\"{\" expected", yyBase);
    }
    { // Start scope for v$g$1.
      Node v$g$1 = yyOpValue1;

      yyResult = pTraitParents(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pTemplateBody(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
        { // Start scope for v$g$3.
          Node v$g$3 = yyOpValue1;

          yyValue = GNode.create("TraitTemplate", v$g$1, v$g$2, v$g$3);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$3.
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ClassParents.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassParents(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pConstr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase = yyRepetition1;
        yyC    = character(yyBase);
        if ('w' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('h' == yyC) {
                yyIndex = yyIndex + 1;

                yyResult = pAnnotType(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Node v$el$1 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
                  continue;
                }
              } else {
                yyError = yyError.select("\"with\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"with\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"with\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"with\" expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("ClassParents", v$g$1, v$g$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TraitParents.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTraitParents(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAnnotType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase = yyRepetition1;
        yyC    = character(yyBase);
        if ('w' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('h' == yyC) {
                yyIndex = yyIndex + 1;

                yyResult = pAnnotType(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Node v$el$1 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
                  continue;
                }
              } else {
                yyError = yyError.select("\"with\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"with\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"with\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"with\" expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("TraitParents", v$g$1, v$g$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Constr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstr(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fConstr) 
      yyColumn.chunk10.fConstr = pConstr$1(yyStart);
    return yyColumn.chunk10.fConstr;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.Constr. */
  private Result pConstr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAnnotType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = p$$Shared5(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("Constr", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.$$Shared5.
   * This nonterminal represents the duplicate productions 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Constr$$Star1 
   * and org.netbeans.modules.scala.editing.rats.ParserScala.SelfInvocation$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared5(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.f$$Shared5) 
      yyColumn.chunk10.f$$Shared5 = p$$Shared5$1(yyStart);
    return yyColumn.chunk10.f$$Shared5;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.$$Shared5. */
  private Result p$$Shared5$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArgumentExprs(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$1 = yyResult.semanticValue();

      yyResult = p$$Shared5(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.EarlyDefs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEarlyDefs(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fEarlyDefs) 
      yyColumn.chunk11.fEarlyDefs = pEarlyDefs$1(yyStart);
    return yyColumn.chunk11.fEarlyDefs;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.EarlyDefs. */
  private Result pEarlyDefs$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEarlyDef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pEarlyDefs$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("EarlyDefs", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.EarlyDefs$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEarlyDefs$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fEarlyDefs$$Star1) 
      yyColumn.chunk11.fEarlyDefs$$Star1 = pEarlyDefs$$Star1$1(yyStart);
    return yyColumn.chunk11.fEarlyDefs$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.EarlyDefs$$Star1. */
  private Result pEarlyDefs$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psemi(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pEarlyDef(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyResult = pEarlyDefs$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.EarlyDef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEarlyDef(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fEarlyDef) 
      yyColumn.chunk11.fEarlyDef = pEarlyDef$1(yyStart);
    return yyColumn.chunk11.fEarlyDef;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.EarlyDef. */
  private Result pEarlyDef$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Node> v$g$1 = yyResult.semanticValue();

      yyResult = p$$Shared4(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyResult = pPatVarDef(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("EarlyDef", v$g$1.size() + v$g$2.size() + 1).
            addAll(v$g$1).addAll(v$g$2).add(v$g$3);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ConstrExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstrExpr(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSelfInvocation(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("ConstrExpr", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pConstrBlock(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("ConstrExpr", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ConstrBlock.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstrBlock(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fConstrBlock) 
      yyColumn.chunk11.fConstrBlock = pConstrBlock$1(yyStart);
    return yyColumn.chunk11.fConstrBlock;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ConstrBlock. */
  private Result pConstrBlock$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;
      String v$g$1 = "{";

      yyResult = pSelfInvocation(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyResult = pConstrBlock$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$g$3 = yyResult.semanticValue();

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if ('}' == yyC) {
            yyIndex = yyResult.index + 1;
            String v$g$4 = "}";

            yyValue = GNode.create("ConstrBlock", v$g$3.size() + 3).
              add(v$g$1).add(v$g$2).addAll(v$g$3).add(v$g$4);

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("\"}\" expected", yyBase);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("constr block expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.ConstrBlock$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstrBlock$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fConstrBlock$$Star1) 
      yyColumn.chunk11.fConstrBlock$$Star1 = pConstrBlock$$Star1$1(yyStart);
    return yyColumn.chunk11.fConstrBlock$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.ConstrBlock$$Star1. */
  private Result pConstrBlock$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psemi(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pBlockStat(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$1 = yyResult.semanticValue();

        yyResult = pConstrBlock$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.SelfInvocation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelfInvocation(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fSelfInvocation) 
      yyColumn.chunk11.fSelfInvocation = pSelfInvocation$1(yyStart);
    return yyColumn.chunk11.fSelfInvocation;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.SelfInvocation. */
  private Result pSelfInvocation$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyResult = pArgumentExprs(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$g$1 = yyResult.semanticValue();

              yyResult = p$$Shared5(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Pair<Node> v$g$2 = yyResult.semanticValue();

                yyValue = GNode.createFromPair("SelfInvocation", v$g$1, v$g$2);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("self invocation expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TopStatSeq.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTopStatSeq(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fTopStatSeq) 
      yyColumn.chunk11.fTopStatSeq = pTopStatSeq$1(yyStart);
    return yyColumn.chunk11.fTopStatSeq;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.TopStatSeq. */
  private Result pTopStatSeq$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pTopStat(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      Node v$g$1 = yyOpValue1;

      yyResult = pTopStatSeq$$Star1(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("TopStatSeq", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TopStatSeq$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTopStatSeq$$Star1(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fTopStatSeq$$Star1) 
      yyColumn.chunk11.fTopStatSeq$$Star1 = pTopStatSeq$$Star1$1(yyStart);
    return yyColumn.chunk11.fTopStatSeq$$Star1;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.TopStatSeq$$Star1. */
  private Result pTopStatSeq$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psemi(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pTopStat(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$el$3 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$3;
      }
      { // Start scope for v$el$2.
        Node v$el$2 = yyOpValue1;

        yyResult = pTopStatSeq$$Star1(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Node> v$4 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$2, v$4);

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v$el$2.
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.TopStat.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTopStat(final int yyStart) throws IOException {
    ParserScalaColumn yyColumn = (ParserScalaColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fTopStat) 
      yyColumn.chunk11.fTopStat = pTopStat$1(yyStart);
    return yyColumn.chunk11.fTopStat;
  }

  /** Actually parse org.netbeans.modules.scala.editing.rats.ParserScala.TopStat. */
  private Result pTopStat$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Node> v$g$1 = yyResult.semanticValue();

      yyResult = p$$Shared4(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Node> v$g$2 = yyResult.semanticValue();

        yyResult = pTmplDef(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("TopStat", v$g$1.size() + v$g$2.size() + 1).
            addAll(v$g$1).addAll(v$g$2).add(v$g$3);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pImport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$4 = yyResult.semanticValue();

      yyValue = GNode.create("TopStat", v$g$4);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pPackaging(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$5 = yyResult.semanticValue();

      yyValue = GNode.create("TopStat", v$g$5);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.Packaging.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPackaging(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('c' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('k' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('g' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyResult = pQualId(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Node v$g$1 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;

                    yyResult = pnl(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                    }

                    yyBase = yyOption1;
                    yyC    = character(yyBase);
                    if ('{' == yyC) {
                      yyIndex = yyOption1 + 1;

                      yyResult = pTopStatSeq(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Node v$g$2 = yyResult.semanticValue();

                        yyBase = yyResult.index;
                        yyC    = character(yyBase);
                        if ('}' == yyC) {
                          yyIndex = yyResult.index + 1;

                          yyValue = GNode.create("Packaging", v$g$1, v$g$2);

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        } else {
                          yyError = yyError.select("\"}\" expected", yyBase);
                        }
                      }
                    } else {
                      yyError = yyError.select("\"{\" expected", yyBase);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("packaging expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.CompilationUnit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pCompilationUnit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase = yyOption1;
    yyC    = character(yyBase);
    if ('p' == yyC) {
      yyIndex = yyOption1 + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('c' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('k' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('g' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyResult = pQualId(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Node v$el$1 = yyResult.semanticValue();

                    yyResult = psemi(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$1;
                    }
                  }
                } else {
                  yyError = yyError.select("\"package\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"package\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"package\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"package\" expected", yyBase);
          }
        } else {
          yyError = yyError.select("\"package\" expected", yyBase);
        }
      } else {
        yyError = yyError.select("\"package\" expected", yyBase);
      }
    } else {
      yyError = yyError.select("\"package\" expected", yyBase);
    }
    { // Start scope for v$g$1.
      Node v$g$1 = yyOpValue1;

      yyResult = pTopStatSeq(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("CompilationUnit", v$g$1, v$g$2);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Character.decimalNumeral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdecimalNumeral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
                {
                  yyRepetition1 = yyIndex;
                  continue;
                }

              default:
                /* No match. */
              }
            }
            break;
          }

          yyValue = null;

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("decimal numeral expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Character.hexNumeral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result phexNumeral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (-1 != yyC) {
        yyIndex = yyIndex + 1;

        switch (yyC) {
        case 'X':
        case 'x':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = false;
            while (true) {

              yyC = character(yyRepetition1);
              if (-1 != yyC) {
                yyIndex = yyRepetition1 + 1;

                switch (yyC) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                  {
                    yyRepetition1 = yyIndex;
                    yyRepeated1   = true;
                    continue;
                  }

                default:
                  /* No match. */
                }
              }
              break;
            }

            if (yyRepeated1) {

              yyValue = null;

              return new SemanticValue(yyValue, yyRepetition1, yyError);
            }
          }
          break;

        default:
          /* No match. */
        }
      }
    }

    // Done.
    yyError = yyError.select("hex numeral expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Character.octalNumeral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result poctalNumeral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
            {
              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyValue = null;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("octal numeral expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Character.characterChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcharacterChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\\':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '\"':
            case '\'':
            case '\\':
            case 'b':
            case 'f':
            case 'n':
            case 'r':
            case 't':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case 'u':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case 'A':
                        case 'B':
                        case 'C':
                        case 'D':
                        case 'E':
                        case 'F':
                        case 'a':
                        case 'b':
                        case 'c':
                        case 'd':
                        case 'e':
                        case 'f':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;

                              switch (yyC) {
                              case '0':
                              case '1':
                              case '2':
                              case '3':
                              case '4':
                              case '5':
                              case '6':
                              case '7':
                              case '8':
                              case '9':
                              case 'A':
                              case 'B':
                              case 'C':
                              case 'D':
                              case 'E':
                              case 'F':
                              case 'a':
                              case 'b':
                              case 'c':
                              case 'd':
                              case 'e':
                              case 'f':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;

                                    switch (yyC) {
                                    case '0':
                                    case '1':
                                    case '2':
                                    case '3':
                                    case '4':
                                    case '5':
                                    case '6':
                                    case '7':
                                    case '8':
                                    case '9':
                                    case 'A':
                                    case 'B':
                                    case 'C':
                                    case 'D':
                                    case 'E':
                                    case 'F':
                                    case 'a':
                                    case 'b':
                                    case 'c':
                                    case 'd':
                                    case 'e':
                                    case 'f':
                                      {
                                        yyValue = null;

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }

                                    default:
                                      /* No match. */
                                    }
                                  }
                                }
                                break;

                              default:
                                /* No match. */
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.
          { // Start scope for nested choice.

            final int yyChoice2 = yyChoice1;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
                {
                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;

                    switch (yyC) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;

                          switch (yyC) {
                          case '0':
                          case '1':
                          case '2':
                          case '3':
                          case '4':
                          case '5':
                          case '6':
                          case '7':
                            {
                              yyValue = null;

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }

                          default:
                            /* No match. */
                          }
                        }
                      }
                      break;

                    default:
                      /* No match. */
                    }
                  }
                }
                break;

              default:
                /* No match. */
              }
            }

            // Nested alternative 2.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
                {
                  final int yyChoice3 = yyIndex;

                  // Nested alternative 1.

                  yyC = character(yyChoice3);
                  if (-1 != yyC) {
                    yyIndex = yyChoice3 + 1;

                    switch (yyC) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                      {
                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }

                    default:
                      /* No match. */
                    }
                  }

                  // Nested alternative 2.

                  yyValue = null;

                  return new SemanticValue(yyValue, yyChoice3, yyError);
                }

              default:
                /* No match. */
              }
            }
          } // End scope for nested choice.
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\'':
      case '\\':
        /* No match. */
        break;

      default:
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("character char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Character.stringChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pstringChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\\':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '\"':
            case '\'':
            case '\\':
            case 'b':
            case 'f':
            case 'n':
            case 'r':
            case 't':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case 'u':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case 'A':
                        case 'B':
                        case 'C':
                        case 'D':
                        case 'E':
                        case 'F':
                        case 'a':
                        case 'b':
                        case 'c':
                        case 'd':
                        case 'e':
                        case 'f':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;

                              switch (yyC) {
                              case '0':
                              case '1':
                              case '2':
                              case '3':
                              case '4':
                              case '5':
                              case '6':
                              case '7':
                              case '8':
                              case '9':
                              case 'A':
                              case 'B':
                              case 'C':
                              case 'D':
                              case 'E':
                              case 'F':
                              case 'a':
                              case 'b':
                              case 'c':
                              case 'd':
                              case 'e':
                              case 'f':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;

                                    switch (yyC) {
                                    case '0':
                                    case '1':
                                    case '2':
                                    case '3':
                                    case '4':
                                    case '5':
                                    case '6':
                                    case '7':
                                    case '8':
                                    case '9':
                                    case 'A':
                                    case 'B':
                                    case 'C':
                                    case 'D':
                                    case 'E':
                                    case 'F':
                                    case 'a':
                                    case 'b':
                                    case 'c':
                                    case 'd':
                                    case 'e':
                                    case 'f':
                                      {
                                        yyValue = null;

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }

                                    default:
                                      /* No match. */
                                    }
                                  }
                                }
                                break;

                              default:
                                /* No match. */
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.
          { // Start scope for nested choice.

            final int yyChoice2 = yyChoice1;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
                {
                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;

                    switch (yyC) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;

                          switch (yyC) {
                          case '0':
                          case '1':
                          case '2':
                          case '3':
                          case '4':
                          case '5':
                          case '6':
                          case '7':
                            {
                              yyValue = null;

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }

                          default:
                            /* No match. */
                          }
                        }
                      }
                      break;

                    default:
                      /* No match. */
                    }
                  }
                }
                break;

              default:
                /* No match. */
              }
            }

            // Nested alternative 2.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
                {
                  final int yyChoice3 = yyIndex;

                  // Nested alternative 1.

                  yyC = character(yyChoice3);
                  if (-1 != yyC) {
                    yyIndex = yyChoice3 + 1;

                    switch (yyC) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                      {
                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }

                    default:
                      /* No match. */
                    }
                  }

                  // Nested alternative 2.

                  yyValue = null;

                  return new SemanticValue(yyValue, yyChoice3, yyError);
                }

              default:
                /* No match. */
              }
            }
          } // End scope for nested choice.
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\"':
      case '\\':
        /* No match. */
        break;

      default:
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("string char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Identifier.Id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pId(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Id", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Identifier.opchar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popchar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {
      if ((('\t' <= yyC) && (yyC <= '\n')) ||
          ('\r' == yyC) ||
          (' ' == yyC) ||
          ('\"' == yyC) ||
          ('$' == yyC) ||
          (('\'' <= yyC) && (yyC <= ')')) ||
          (',' == yyC) ||
          ('.' == yyC) ||
          (('0' <= yyC) && (yyC <= '9')) ||
          (';' == yyC) ||
          (('A' <= yyC) && (yyC <= '[')) ||
          (']' == yyC) ||
          (('_' <= yyC) && (yyC <= '{')) ||
          ('}' == yyC)) {

        yyPredMatched = true;
      }
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        if ((' ' <= yyC) && (yyC <= '\u007f')) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    } else {
      yyError = yyError.select("opchar expected", yyStart);
    }

    // Done.
    yyError = yyError.select("opchar expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Identifier.op.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pop(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popchar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      while (true) {

        yyResult = popchar(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Identifier.varid.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pvarid(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('a' <= yyC) && (yyC <= 'z')) {

        yyOption1  = yyIndex;

        yyResult = pidrest(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }

        yyValue = difference(yyStart, yyOption1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("varid expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Identifier.plainid.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pplainid(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pplainid$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyResult = pidrest(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }

      yyValue = null;

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('a' <= yyC) && (yyC <= 'z')) {

        yyOption1  = yyIndex;

        yyResult = pidrest(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }

        yyValue = null;

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Alternative 3.

    yyResult = popchar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      while (true) {

        yyResult = popchar(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("plainid expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.plainid$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pplainid$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('A' <= yyC) && (yyC <= 'Z')) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '$':
      case '_':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("plainid expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Identifier.id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pid(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pplainid$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyResult = pidrest(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }

      yyValue = difference(yyStart, yyOption1);

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('a' <= yyC) && (yyC <= 'z')) {

        yyOption1  = yyIndex;

        yyResult = pidrest(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }

        yyValue = difference(yyStart, yyOption1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Alternative 3.

    yyResult = popchar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      while (true) {

        yyResult = popchar(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('`' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      yyRepeated1   = false;
      while (true) {

        yyPredMatched = false;

        yyC = character(yyRepetition1);
        if ('`' == yyC) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyResult = pstringChar(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            yyRepeated1   = true;
            continue;
          }
        } else {
          yyError = yyError.select("id expected", yyStart);
        }
        break;
      }

      if (yyRepeated1) {

        yyC = character(yyRepetition1);
        if ('`' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("id expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Identifier.idrest.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidrest(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;
        if (('A' <= yyC) && (yyC <= 'Z')) {

          yyRepetition1 = yyIndex;
          yyRepeated1   = true;
          continue;
        }
      }

      // Nested alternative 2.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;
        if (('a' <= yyC) && (yyC <= 'z')) {

          yyRepetition1 = yyIndex;
          yyRepeated1   = true;
          continue;
        }
      }

      // Nested alternative 3.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyOption1  = yyRepetition1;

      yyC = character(yyOption1);
      if ('_' == yyC) {
        yyIndex = yyOption1 + 1;

        yyResult = pop(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }
      }

      yyValue = null;

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pop(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("idrest expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Keyword.Keyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pKeyword(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pkeyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Keyword", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Keyword.keyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pkeyword(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'a':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('b' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('s' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('t' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('r' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('a' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('c' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('t' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "abstract";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("keyword expected", yyStart);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'c':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'a':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 's':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('e' == yyC) {

                          yyPredMatched = false;

                          yyPredResult = pidrest(yyIndex);
                          if (yyPredResult.hasValue()) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyValue = "case";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          } else {
                            yyError = yyError.select("keyword expected", yyStart);
                          }
                        }
                      }
                    }
                    break;

                  case 't':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('c' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('h' == yyC) {

                              yyPredMatched = false;

                              yyPredResult = pidrest(yyIndex);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = "catch";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select("keyword expected", yyStart);
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'l':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('a' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('s' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('s' == yyC) {

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "class";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("keyword expected", yyStart);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'd':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'e':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('f' == yyC) {

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = "def";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("keyword expected", yyStart);
                    }
                  }
                }
              }
              break;

            case 'o':
              {
                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "do";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("keyword expected", yyStart);
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'l':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('s' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('e' == yyC) {

                        yyPredMatched = false;

                        yyPredResult = pidrest(yyIndex);
                        if (yyPredResult.hasValue()) {

                          yyPredMatched = true;
                        }

                        if (! yyPredMatched) {

                          yyValue = "else";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        } else {
                          yyError = yyError.select("keyword expected", yyStart);
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'x':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('t' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('e' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('n' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('d' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('s' == yyC) {

                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = "extends";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("keyword expected", yyStart);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'a':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('l' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('s' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('e' == yyC) {

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "false";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("keyword expected", yyStart);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'i':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('n' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('a' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('l' == yyC) {

                            final int yyChoice1 = yyIndex;

                            // Nested alternative 1.

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyChoice1);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "final";

                              return new SemanticValue(yyValue, yyChoice1, yyError);
                            } else {
                              yyError = yyError.select("keyword expected", yyStart);
                            }

                            // Nested alternative 2.

                            yyC = character(yyChoice1);
                            if (-1 != yyC) {
                              yyIndex = yyChoice1 + 1;
                              if ('l' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('y' == yyC) {

                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = "finally";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("keyword expected", yyStart);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'o':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('r' == yyC) {

                    final int yyChoice1 = yyIndex;

                    // Nested alternative 1.

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyChoice1);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = "for";

                      return new SemanticValue(yyValue, yyChoice1, yyError);
                    } else {
                      yyError = yyError.select("keyword expected", yyStart);
                    }

                    // Nested alternative 2.

                    yyC = character(yyChoice1);
                    if (-1 != yyC) {
                      yyIndex = yyChoice1 + 1;
                      if ('S' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('o' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('m' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('e' == yyC) {

                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = "forSome";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("keyword expected", yyStart);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'i':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'f':
              {
                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "if";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("keyword expected", yyStart);
                }
              }
              break;

            case 'm':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('p' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;

                      switch (yyC) {
                      case 'l':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('i' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('c' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('i' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('t' == yyC) {

                                          yyPredMatched = false;

                                          yyPredResult = pidrest(yyIndex);
                                          if (yyPredResult.hasValue()) {

                                            yyPredMatched = true;
                                          }

                                          if (! yyPredMatched) {

                                            yyValue = "implicit";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          } else {
                                            yyError = yyError.select("keyword expected", yyStart);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        break;

                      case 'o':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('r' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('t' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "import";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("keyword expected", yyStart);
                                  }
                                }
                              }
                            }
                          }
                        }
                        break;

                      default:
                        /* No match. */
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'l':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('z' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('y' == yyC) {

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = "lazy";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("keyword expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'm':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('t' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('c' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('h' == yyC) {

                          yyPredMatched = false;

                          yyPredResult = pidrest(yyIndex);
                          if (yyPredResult.hasValue()) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyValue = "match";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          } else {
                            yyError = yyError.select("keyword expected", yyStart);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'n':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'e':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('w' == yyC) {

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = "new";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("keyword expected", yyStart);
                    }
                  }
                }
              }
              break;

            case 'u':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('l' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('l' == yyC) {

                        yyPredMatched = false;

                        yyPredResult = pidrest(yyIndex);
                        if (yyPredResult.hasValue()) {

                          yyPredMatched = true;
                        }

                        if (! yyPredMatched) {

                          yyValue = "null";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        } else {
                          yyError = yyError.select("keyword expected", yyStart);
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'o':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'b':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('j' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('e' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('c' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('t' == yyC) {

                                yyPredMatched = false;

                                yyPredResult = pidrest(yyIndex);
                                if (yyPredResult.hasValue()) {

                                  yyPredMatched = true;
                                }

                                if (! yyPredMatched) {

                                  yyValue = "object";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                } else {
                                  yyError = yyError.select("keyword expected", yyStart);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'v':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('e' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('r' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('r' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('i' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('d' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('e' == yyC) {

                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "override";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("keyword expected", yyStart);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'p':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'a':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('c' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('k' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('a' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('g' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('e' == yyC) {

                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = "package";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("keyword expected", yyStart);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'r':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'i':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('v' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('a' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('t' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('e' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "private";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("keyword expected", yyStart);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'o':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('t' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('e' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('c' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('t' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('e' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('d' == yyC) {

                                              yyPredMatched = false;

                                              yyPredResult = pidrest(yyIndex);
                                              if (yyPredResult.hasValue()) {

                                                yyPredMatched = true;
                                              }

                                              if (! yyPredMatched) {

                                                yyValue = "protected";

                                                return new SemanticValue(yyValue, yyIndex, yyError);
                                              } else {
                                                yyError = yyError.select("keyword expected", yyStart);
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'r':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('e' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;

                switch (yyC) {
                case 'q':
                  {
                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('u' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('i' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('r' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('e' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('s' == yyC) {

                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "requires";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("keyword expected", yyStart);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  break;

                case 't':
                  {
                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('u' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('r' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('n' == yyC) {

                                yyPredMatched = false;

                                yyPredResult = pidrest(yyIndex);
                                if (yyPredResult.hasValue()) {

                                  yyPredMatched = true;
                                }

                                if (! yyPredMatched) {

                                  yyValue = "return";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                } else {
                                  yyError = yyError.select("keyword expected", yyStart);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  break;

                default:
                  /* No match. */
                }
              }
            }
          }
        }
        break;

      case 's':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'e':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('a' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('l' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('e' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('d' == yyC) {

                                yyPredMatched = false;

                                yyPredResult = pidrest(yyIndex);
                                if (yyPredResult.hasValue()) {

                                  yyPredMatched = true;
                                }

                                if (! yyPredMatched) {

                                  yyValue = "sealed";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                } else {
                                  yyError = yyError.select("keyword expected", yyStart);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'u':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('p' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('e' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('r' == yyC) {

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "super";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("keyword expected", yyStart);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 't':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'h':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'i':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('s' == yyC) {

                          yyPredMatched = false;

                          yyPredResult = pidrest(yyIndex);
                          if (yyPredResult.hasValue()) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyValue = "this";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          } else {
                            yyError = yyError.select("keyword expected", yyStart);
                          }
                        }
                      }
                    }
                    break;

                  case 'r':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('o' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('w' == yyC) {

                              yyPredMatched = false;

                              yyPredResult = pidrest(yyIndex);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = "throw";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select("keyword expected", yyStart);
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'r':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'a':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('i' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('t' == yyC) {

                              yyPredMatched = false;

                              yyPredResult = pidrest(yyIndex);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = "trait";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select("keyword expected", yyStart);
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'y':
                    {
                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = "try";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("keyword expected", yyStart);
                      }
                    }
                    break;

                  case 'u':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('e' == yyC) {

                          yyPredMatched = false;

                          yyPredResult = pidrest(yyIndex);
                          if (yyPredResult.hasValue()) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyValue = "true";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          } else {
                            yyError = yyError.select("keyword expected", yyStart);
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            case 'y':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('p' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('e' == yyC) {

                        yyPredMatched = false;

                        yyPredResult = pidrest(yyIndex);
                        if (yyPredResult.hasValue()) {

                          yyPredMatched = true;
                        }

                        if (! yyPredMatched) {

                          yyValue = "type";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        } else {
                          yyError = yyError.select("keyword expected", yyStart);
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'v':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;

                switch (yyC) {
                case 'l':
                  {
                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = "val";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("keyword expected", yyStart);
                    }
                  }
                  break;

                case 'r':
                  {
                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = "var";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("keyword expected", yyStart);
                    }
                  }
                  break;

                default:
                  /* No match. */
                }
              }
            }
          }
        }
        break;

      case 'w':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'h':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('i' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('l' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('e' == yyC) {

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "while";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("keyword expected", yyStart);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'i':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('t' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('h' == yyC) {

                        yyPredMatched = false;

                        yyPredResult = pidrest(yyIndex);
                        if (yyPredResult.hasValue()) {

                          yyPredMatched = true;
                        }

                        if (! yyPredMatched) {

                          yyValue = "with";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        } else {
                          yyError = yyError.select("keyword expected", yyStart);
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'y':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('i' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('e' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('l' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('d' == yyC) {

                          yyPredMatched = false;

                          yyPredResult = pidrest(yyIndex);
                          if (yyPredResult.hasValue()) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyValue = "yield";

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          } else {
                            yyError = yyError.select("keyword expected", yyStart);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case '_':
        {
          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = "_";

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("keyword expected", yyStart);
          }
        }
        break;

      case ':':
        {
          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = ":";

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("keyword expected", yyStart);
          }
        }
        break;

      case '=':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyPredMatched = false;

          yyPredResult = pidrest(yyChoice1);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = "=";

            return new SemanticValue(yyValue, yyChoice1, yyError);
          } else {
            yyError = yyError.select("keyword expected", yyStart);
          }

          // Nested alternative 2.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('>' == yyC) {

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = "=>";

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("keyword expected", yyStart);
              }
            }
          }
        }
        break;

      case '<':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '-':
              {
                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "<-";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("keyword expected", yyStart);
                }
              }
              break;

            case ':':
              {
                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "<:";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("keyword expected", yyStart);
                }
              }
              break;

            case '%':
              {
                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "<%";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("keyword expected", yyStart);
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case '>':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (':' == yyC) {

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = ">:";

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("keyword expected", yyStart);
              }
            }
          }
        }
        break;

      case '#':
        {
          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = "#";

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("keyword expected", yyStart);
          }
        }
        break;

      case '@':
        {
          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = "@";

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("keyword expected", yyStart);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("keyword expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Literal.integerLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pintegerLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = phexNumeral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;

        switch (yyC) {
        case 'L':
        case 'l':
          {
            yyOption1  = yyIndex;
          }

        default:
          /* No match. */
        }
      }

      yyValue = difference(yyStart, yyOption1);

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Alternative 2.

    yyResult = poctalNumeral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;

        switch (yyC) {
        case 'L':
        case 'l':
          {
            yyOption1  = yyIndex;
          }

        default:
          /* No match. */
        }
      }

      yyValue = difference(yyStart, yyOption1);

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Alternative 3.

    yyResult = pdecimalNumeral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;

        switch (yyC) {
        case 'L':
        case 'l':
          {
            yyOption1  = yyIndex;
          }

        default:
          /* No match. */
        }
      }

      yyValue = difference(yyStart, yyOption1);

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    yyError = yyError.select("integer literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Literal.FloatingPointLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatingPointLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pfloatingPointLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("FloatingPointLiteral", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Literal.floatingPointLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfloatingPointLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyC = character(yyRepetition1);
      if ('.' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              {
                yyRepetition1 = yyIndex;
                continue;
              }

            default:
              /* No match. */
            }
          }
          break;
        }

        yyOption1  = yyRepetition1;

        yyResult = pexponent(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }


        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'D':
          case 'F':
          case 'd':
          case 'f':
            {
              yyOption1  = yyIndex;
            }

          default:
            /* No match. */
          }
        }

        yyValue = difference(yyStart, yyOption1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            {
              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyOption1  = yyRepetition1;

        yyResult = pexponent(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }


        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'D':
          case 'F':
          case 'd':
          case 'f':
            {
              yyOption1  = yyIndex;
            }

          default:
            /* No match. */
          }
        }

        yyValue = difference(yyStart, yyOption1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Alternative 3.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyResult = pexponent(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;

        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'D':
          case 'F':
          case 'd':
          case 'f':
            {
              yyOption1  = yyIndex;
            }

          default:
            /* No match. */
          }
        }

        yyValue = difference(yyStart, yyOption1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }

      // Nested alternative 2.

      yyOption1  = yyChoice1;

      yyResult = pexponent(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }

      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;

        switch (yyC) {
        case 'D':
        case 'F':
        case 'd':
        case 'f':
          {
            yyValue = difference(yyStart, yyIndex);

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        default:
          /* No match. */
        }
      }
    }

    // Done.
    yyError = yyError.select("floating point literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Literal.exponent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexponent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'E':
      case 'e':
        {
          yyOption1  = yyIndex;

          yyC = character(yyOption1);
          if (-1 != yyC) {
            yyIndex = yyOption1 + 1;

            switch (yyC) {
            case '+':
            case '-':
              {
                yyOption1  = yyIndex;
              }

            default:
              /* No match. */
            }
          }

          yyRepetition1 = yyOption1;
          yyRepeated1   = false;
          while (true) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
                {
                  yyRepetition1 = yyIndex;
                  yyRepeated1   = true;
                  continue;
                }

              default:
                /* No match. */
              }
            }
            break;
          }

          if (yyRepeated1) {

            yyValue = null;

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("exponent expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Literal.CharacterLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcharacterLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("CharacterLiteral", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Literal.characterLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcharacterLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\'' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pcharacterChar(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyC = character(yyResult.index);
        if ('\'' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("character literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Literal.StringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pstringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("StringLiteral", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Literal.stringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pstringLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      final int yyChoice1 = yyIndex;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if ('\"' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyC = character(yyIndex);
        if ('\"' == yyC) {
          yyIndex = yyIndex + 1;

          yyRepetition1 = yyIndex;
          while (true) {

            yyResult = pmultiLineChar(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              continue;
            }
            break;
          }

          yyC = character(yyRepetition1);
          if ('\"' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyC = character(yyIndex);
            if ('\"' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('\"' == yyC) {
                yyIndex = yyIndex + 1;

                yyValue = difference(yyStart, yyIndex);

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }
          }
        }
      }

      // Nested alternative 2.

      yyRepetition1 = yyChoice1;
      while (true) {

        yyResult = pstringChar(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }

      yyC = character(yyRepetition1);
      if ('\"' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("string literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Literal.multiLineChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmultiLineChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyC = character(yyOption1);
    if ('\"' == yyC) {
      yyIndex = yyOption1 + 1;

      yyOption1  = yyIndex;
    }


    yyC = character(yyOption1);
    if ('\"' == yyC) {
      yyIndex = yyOption1 + 1;

      yyOption1  = yyIndex;
    }

    yyC = character(yyOption1);
    if (-1 != yyC) {
      yyIndex = yyOption1 + 1;
      if ('\"' != yyC) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("multi line char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Literal.SymbolLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbolLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psymbolLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("SymbolLiteral", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Literal.symbolLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psymbolLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\'' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pplainid(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("symbol literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Spacing.Ws.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWs(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pws(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Ws", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Spacing.nl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pnl(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('\n' == yyC) {

              yyValue = "\r\n";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "\r";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\n':
        {
          yyValue = "\n";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("nl expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Spacing.ws.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pws(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("ws expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Symbol.Separator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSeparator(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pseparator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Separator", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Symbol.separator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pseparator(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '(':
        {
          yyValue = "(";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ')':
        {
          yyValue = ")";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyValue = "[";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = "]";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '{':
        {
          yyValue = "{";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = "}";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ',':
        {
          yyValue = ",";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ';':
        {
          yyValue = ";";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '.':
        {
          yyValue = ".";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("separator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.XmlElement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlElement(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pXmlEmptyElemTag(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("XmlElement", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pXmlSTag(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$2 = yyResult.semanticValue();

      yyResult = pXmlContent(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$3 = yyResult.semanticValue();

        yyResult = pXmlETag(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Node v$g$4 = yyResult.semanticValue();

          yyValue = GNode.create("XmlElement", v$g$2, v$g$3, v$g$4);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.XmlLt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlLt(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;
      String v$g$1 = "<";

      yyValue = GNode.create("XmlLt", v$g$1);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("xml lt expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.XmlGt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlGt(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;
      String v$g$1 = ">";

      yyValue = GNode.create("XmlGt", v$g$1);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("xml gt expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.XmlLtSlash.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlLtSlash(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;
        String v$g$1 = "</";

        yyValue = GNode.create("XmlLtSlash", v$g$1);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("xml lt slash expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.XmlSlashGt.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlSlashGt(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;
        String v$g$1 = "/>";

        yyValue = GNode.create("XmlSlashGt", v$g$1);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("xml slash gt expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.XmlEq.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlEq(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;
      String v$g$1 = "=";

      yyValue = GNode.create("XmlEq", v$g$1);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("xml eq expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Xml.XmlEmptyElemTag.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlEmptyElemTag(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pXmlLt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pXmlName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pXmlAttribute(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$3.
          Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyOption1  = yyRepetition1;
          yyOpValue1 = null;

          yyResult = pxmlWs(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
          { // Start scope for v$g$4.
            String v$g$4 = yyOpValue1;

            yyResult = pXmlSlashGt(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$g$5 = yyResult.semanticValue();

              yyValue = GNode.create("XmlEmptyElemTag", v$g$3.size() + 4).
                add(v$g$1).add(v$g$2).addAll(v$g$3).add(v$g$4).add(v$g$5);

              return yyResult.createValue(yyValue, yyError);
            }
          } // End scope for v$g$4.
        } // End scope for v$g$3.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.XmlSTag.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlSTag(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pXmlLt(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pXmlName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pXmlAttribute(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$3.
          Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyOption1  = yyRepetition1;
          yyOpValue1 = null;

          yyResult = pxmlWs(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
          { // Start scope for v$g$4.
            String v$g$4 = yyOpValue1;

            yyResult = pXmlGt(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Node v$g$5 = yyResult.semanticValue();

              yyValue = GNode.create("XmlSTag", v$g$3.size() + 4).
                add(v$g$1).add(v$g$2).addAll(v$g$3).add(v$g$4).add(v$g$5);

              return yyResult.createValue(yyValue, yyError);
            }
          } // End scope for v$g$4.
        } // End scope for v$g$3.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.XmlETag.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlETag(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pXmlLtSlash(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Node v$g$1 = yyResult.semanticValue();

      yyResult = pXmlName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pxmlWs(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$3.
          String v$g$3 = yyOpValue1;

          yyResult = pXmlGt(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$4 = yyResult.semanticValue();

            yyValue = GNode.create("XmlETag", v$g$1, v$g$2, v$g$3, v$g$4);

            return yyResult.createValue(yyValue, yyError);
          }
        } // End scope for v$g$3.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Xml.XmlAttribute.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlAttribute(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pxmlWs(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyResult = pXmlName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pxmlWs(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$3.
          String v$g$3 = yyOpValue1;

          yyResult = pXmlEq(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Node v$g$4 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pxmlWs(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$g$5.
              String v$g$5 = yyOpValue1;

              yyResult = pXmlAttValue(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Node v$g$6 = yyResult.semanticValue();

                yyValue = GNode.create("XmlAttribute", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5, v$g$6);

                return yyResult.createValue(yyValue, yyError);
              }
            } // End scope for v$g$5.
          }
        } // End scope for v$g$3.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.XmlContent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlContent(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    Pair<Object> yyRepValue1;
    Node         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pXmlContent$$Choice1(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Object v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Object>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$g$1.
      Pair<Object> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("XmlContent", v$g$1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.XmlContent$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlContent$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyPredIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (']' == yyC) {
      yyPredIndex = yyStart + 1;

      yyC = character(yyPredIndex);
      if (']' == yyC) {
        yyPredIndex = yyPredIndex + 1;

        yyC = character(yyPredIndex);
        if ('>' == yyC) {

          yyPredMatched = true;
        }
      }
    }

    if (! yyPredMatched) {

      yyRepetition1 = yyStart;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '&':
          case '<':
            /* No match. */
            break;

          default:
            {
              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            }
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    } else {
      yyError = yyError.select("xml content expected", yyStart);
    }

    // Alternative 2.

    yyResult = pXmlElement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pXmlEntityRef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = difference(yyStart, yyResult.index);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pXmlCharRef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = difference(yyStart, yyResult.index);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pXmlCDStart(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pXmlCData(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pXmlCDEnd(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 6.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('?' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pXmlPITarget(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyResult = pxmlWs(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyPredMatched = false;

            yyRepetition1 = yyResult.index;
            while (true) {

              yyPredResult = pxmlChar(yyRepetition1);
              if (yyPredResult.hasValue()) {

                yyRepetition1 = yyPredResult.index;
                continue;
              }
              break;
            }

            yyC = character(yyRepetition1);
            if ('?' == yyC) {
              yyPredIndex = yyRepetition1 + 1;

              yyC = character(yyPredIndex);
              if ('>' == yyC) {
                yyPredIndex = yyPredIndex + 1;

                yyRepetition1 = yyPredIndex;
                while (true) {

                  yyPredResult = pxmlChar(yyRepetition1);
                  if (yyPredResult.hasValue()) {

                    yyRepetition1 = yyPredResult.index;
                    continue;
                  }
                  break;
                }

                yyPredMatched = true;
              }
            }

            if (! yyPredMatched) {

              yyRepetition1 = yyResult.index;
              while (true) {

                yyResult = pxmlChar(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyRepetition1 = yyResult.index;
                  continue;
                }
                break;
              }

              yyOption1  = yyRepetition1;
            } else {
              yyError = yyError.select("xml content expected", yyStart);
            }
          }

          yyBase = yyOption1;
          yyC    = character(yyBase);
          if ('?' == yyC) {
            yyIndex = yyOption1 + 1;

            yyC = character(yyIndex);
            if ('>' == yyC) {
              yyIndex = yyIndex + 1;

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"?>\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"?>\" expected", yyBase);
          }
        }
      }
    }

    // Alternative 7.

    yyResult = pXmlComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("xml content expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.XmlName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlName(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pxmlName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("XmlName", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.xmlName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pxmlName(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pXmlNameStartChar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      while (true) {

        yyResult = pXmlNameChar(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Xml.XmlNameStartChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlNameStartChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('A' <= yyC) && (yyC <= 'Z')) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('a' <= yyC) && (yyC <= 'z')) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("xml name start char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Xml.XmlNameChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlNameChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('A' <= yyC) && (yyC <= 'Z')) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('a' <= yyC) && (yyC <= 'z')) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 5.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '-':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '.':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("xml name char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Xml.XmlAttValue.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlAttValue(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pxmlAttValue(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("XmlAttValue", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pscalaExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("XmlAttValue", v$g$2);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Xml.xmlAttValue.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pxmlAttValue(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    int        yyRepetition2;
    boolean    yyRepeated2;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\"':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            final int yyChoice1 = yyRepetition1;

            // Nested alternative 1.

            yyC = character(yyChoice1);
            if (-1 != yyC) {
              yyIndex = yyChoice1 + 1;

              switch (yyC) {
              case '\"':
              case '&':
              case '<':
                /* No match. */
                break;

              default:
                {
                  yyRepetition1 = yyIndex;
                  continue;
                }
              }
            }

            // Nested alternative 2.

            yyC = character(yyChoice1);
            if (-1 != yyC) {
              yyIndex = yyChoice1 + 1;
              if ('&' == yyC) {

                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyResult = pxmlName(yyChoice2);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyC = character(yyResult.index);
                  if (';' == yyC) {
                    yyIndex = yyResult.index + 1;

                    yyRepetition1 = yyIndex;
                    continue;
                  }
                }

                // Nested alternative 2.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;
                  if ('#' == yyC) {

                    final int yyChoice3 = yyIndex;

                    // Nested alternative 1.

                    yyRepetition2 = yyChoice3;
                    yyRepeated2   = false;
                    while (true) {

                      yyC = character(yyRepetition2);
                      if (-1 != yyC) {
                        yyIndex = yyRepetition2 + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                          {
                            yyRepetition2 = yyIndex;
                            yyRepeated2   = true;
                            continue;
                          }

                        default:
                          /* No match. */
                        }
                      }
                      break;
                    }

                    if (yyRepeated2) {

                      yyC = character(yyRepetition2);
                      if (';' == yyC) {
                        yyIndex = yyRepetition2 + 1;

                        yyRepetition1 = yyIndex;
                        continue;
                      }
                    }

                    // Nested alternative 2.

                    yyC = character(yyChoice3);
                    if (-1 != yyC) {
                      yyIndex = yyChoice3 + 1;
                      if ('x' == yyC) {

                        yyRepetition2 = yyIndex;
                        yyRepeated2   = false;
                        while (true) {

                          yyC = character(yyRepetition2);
                          if (-1 != yyC) {
                            yyIndex = yyRepetition2 + 1;

                            switch (yyC) {
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                            case 'A':
                            case 'B':
                            case 'C':
                            case 'D':
                            case 'E':
                            case 'F':
                            case 'a':
                            case 'b':
                            case 'c':
                            case 'd':
                            case 'e':
                            case 'f':
                              {
                                yyRepetition2 = yyIndex;
                                yyRepeated2   = true;
                                continue;
                              }

                            default:
                              /* No match. */
                            }
                          }
                          break;
                        }

                        if (yyRepeated2) {

                          yyC = character(yyRepetition2);
                          if (';' == yyC) {
                            yyIndex = yyRepetition2 + 1;

                            yyRepetition1 = yyIndex;
                            continue;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            break;
          }

          yyC = character(yyRepetition1);
          if ('\"' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyValue = difference(yyStart, yyIndex);

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
        break;

      case '\'':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            final int yyChoice1 = yyRepetition1;

            // Nested alternative 1.

            yyC = character(yyChoice1);
            if (-1 != yyC) {
              yyIndex = yyChoice1 + 1;

              switch (yyC) {
              case '&':
              case '\'':
              case '<':
                /* No match. */
                break;

              default:
                {
                  yyRepetition1 = yyIndex;
                  continue;
                }
              }
            }

            // Nested alternative 2.

            yyC = character(yyChoice1);
            if (-1 != yyC) {
              yyIndex = yyChoice1 + 1;
              if ('&' == yyC) {

                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyResult = pxmlName(yyChoice2);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyC = character(yyResult.index);
                  if (';' == yyC) {
                    yyIndex = yyResult.index + 1;

                    yyRepetition1 = yyIndex;
                    continue;
                  }
                }

                // Nested alternative 2.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;
                  if ('#' == yyC) {

                    final int yyChoice3 = yyIndex;

                    // Nested alternative 1.

                    yyRepetition2 = yyChoice3;
                    yyRepeated2   = false;
                    while (true) {

                      yyC = character(yyRepetition2);
                      if (-1 != yyC) {
                        yyIndex = yyRepetition2 + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                          {
                            yyRepetition2 = yyIndex;
                            yyRepeated2   = true;
                            continue;
                          }

                        default:
                          /* No match. */
                        }
                      }
                      break;
                    }

                    if (yyRepeated2) {

                      yyC = character(yyRepetition2);
                      if (';' == yyC) {
                        yyIndex = yyRepetition2 + 1;

                        yyRepetition1 = yyIndex;
                        continue;
                      }
                    }

                    // Nested alternative 2.

                    yyC = character(yyChoice3);
                    if (-1 != yyC) {
                      yyIndex = yyChoice3 + 1;
                      if ('x' == yyC) {

                        yyRepetition2 = yyIndex;
                        yyRepeated2   = false;
                        while (true) {

                          yyC = character(yyRepetition2);
                          if (-1 != yyC) {
                            yyIndex = yyRepetition2 + 1;

                            switch (yyC) {
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                            case 'A':
                            case 'B':
                            case 'C':
                            case 'D':
                            case 'E':
                            case 'F':
                            case 'a':
                            case 'b':
                            case 'c':
                            case 'd':
                            case 'e':
                            case 'f':
                              {
                                yyRepetition2 = yyIndex;
                                yyRepeated2   = true;
                                continue;
                              }

                            default:
                              /* No match. */
                            }
                          }
                          break;
                        }

                        if (yyRepeated2) {

                          yyC = character(yyRepetition2);
                          if (';' == yyC) {
                            yyIndex = yyRepetition2 + 1;

                            yyRepetition1 = yyIndex;
                            continue;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            break;
          }

          yyC = character(yyRepetition1);
          if ('\'' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyValue = difference(yyStart, yyIndex);

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("xml att value expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.scalaExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pscalaExpr(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        yyPredMatched = false;

        yyC = character(yyRepetition1);
        if ('}' == yyC) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;

            yyRepetition1 = yyIndex;
            continue;
          }
        } else {
          yyError = yyError.select("scala expr expected", yyStart);
        }
        break;
      }

      yyC = character(yyRepetition1);
      if ('}' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("scala expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.XmlComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlComment(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pxmlComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("XmlComment", v$g$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.xmlComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pxmlComment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('!' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('-' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('-' == yyC) {
            yyIndex = yyIndex + 1;

            yyRepetition1 = yyIndex;
            while (true) {

              final int yyChoice1 = yyRepetition1;

              // Nested alternative 1.

              yyPredMatched = false;

              yyC = character(yyChoice1);
              if ('-' == yyC) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyResult = pxmlChar(yyChoice1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyRepetition1 = yyResult.index;
                  continue;
                }
              } else {
                yyError = yyError.select("xml comment expected", yyStart);
              }

              // Nested alternative 2.

              yyC = character(yyChoice1);
              if ('-' == yyC) {
                yyIndex = yyChoice1 + 1;

                yyPredMatched = false;

                yyC = character(yyIndex);
                if ('-' == yyC) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyResult = pxmlChar(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyRepetition1 = yyResult.index;
                    continue;
                  }
                } else {
                  yyError = yyError.select("xml comment expected", yyStart);
                }
              }
              break;
            }

            yyBase = yyRepetition1;
            yyC    = character(yyBase);
            if ('-' == yyC) {
              yyIndex = yyRepetition1 + 1;

              yyC = character(yyIndex);
              if ('-' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('>' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyValue = difference(yyStart, yyIndex);

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("\"-->\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"-->\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"-->\" expected", yyBase);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("xml comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Xml.XmlEntityRef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlEntityRef(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pxmlName(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyC = character(yyResult.index);
        if (';' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("xml entity ref expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.XmlCharRef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlCharRef(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('&' == yyC) {

        yyC = character(yyIndex);
        if (-1 != yyC) {
          yyIndex = yyIndex + 1;
          if ('#' == yyC) {

            final int yyChoice1 = yyIndex;

            // Nested alternative 1.

            yyRepetition1 = yyChoice1;
            yyRepeated1   = false;
            while (true) {

              yyC = character(yyRepetition1);
              if (-1 != yyC) {
                yyIndex = yyRepetition1 + 1;

                switch (yyC) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  {
                    yyRepetition1 = yyIndex;
                    yyRepeated1   = true;
                    continue;
                  }

                default:
                  /* No match. */
                }
              }
              break;
            }

            if (yyRepeated1) {

              yyC = character(yyRepetition1);
              if (';' == yyC) {
                yyIndex = yyRepetition1 + 1;

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }

            // Nested alternative 2.

            yyC = character(yyChoice1);
            if (-1 != yyC) {
              yyIndex = yyChoice1 + 1;
              if ('x' == yyC) {

                yyRepetition1 = yyIndex;
                yyRepeated1   = false;
                while (true) {

                  yyC = character(yyRepetition1);
                  if (-1 != yyC) {
                    yyIndex = yyRepetition1 + 1;

                    switch (yyC) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case 'A':
                    case 'B':
                    case 'C':
                    case 'D':
                    case 'E':
                    case 'F':
                    case 'a':
                    case 'b':
                    case 'c':
                    case 'd':
                    case 'e':
                    case 'f':
                      {
                        yyRepetition1 = yyIndex;
                        yyRepeated1   = true;
                        continue;
                      }

                    default:
                      /* No match. */
                    }
                  }
                  break;
                }

                if (yyRepeated1) {

                  yyC = character(yyRepetition1);
                  if (';' == yyC) {
                    yyIndex = yyRepetition1 + 1;

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("xml char ref expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.XmlCDStart.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlCDStart(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('!' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('[' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('C' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('D' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('A' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('T' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('A' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('[' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("xml c d start expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.XmlCData.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlCData(final int yyStart) throws IOException {
    int        yyC;
    Result     yyResult;
    int        yyPredIndex;
    boolean    yyPredMatched;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (']' == yyC) {
      yyPredIndex = yyStart + 1;

      yyC = character(yyPredIndex);
      if (']' == yyC) {
        yyPredIndex = yyPredIndex + 1;

        yyC = character(yyPredIndex);
        if ('>' == yyC) {

          yyPredMatched = true;
        }
      }
    }

    if (! yyPredMatched) {

      yyRepetition1 = yyStart;
      while (true) {

        yyResult = pxmlChar(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } else {
      yyError = yyError.select("xml c data expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.XmlCDEnd.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlCDEnd(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (']' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (']' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("xml c d end expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * org.netbeans.modules.scala.editing.rats.Xml.XmlPITarget.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlPITarget(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pXmlPITarget$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyResult = pxmlName(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    } else {
      yyError = yyError.select("xml p i target expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.XmlPITarget$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlPITarget$$Choice2(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'X':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case 'x':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("xml p i target expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.XmlPITarget$$Choice3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlPITarget$$Choice3(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'M':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case 'm':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("xml p i target expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * org.netbeans.modules.scala.editing.rats.ParserScala.XmlPITarget$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pXmlPITarget$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pXmlPITarget$$Choice2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pXmlPITarget$$Choice3(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case 'L':
            {
              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }

          case 'l':
            {
              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }

          default:
            /* No match. */
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("xml p i target expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.xmlChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pxmlChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('\u0001' <= yyC) && (yyC <= '\ud7ff')) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('\ue000' <= yyC) && (yyC <= '\ufffd')) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("xml char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal org.netbeans.modules.scala.editing.rats.Xml.xmlWs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pxmlWs(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("xml ws expected", yyStart);
    return yyError;
  }

  // =========================================================================

  static {
    add(SCALA_KEYWORDS, new String[] {
      "abstract",
      "case",
      "catch",
      "class",
      "def",
      "do",
      "else",
      "extends",
      "false",
      "final",
      "finally",
      "for",
      "forSome",
      "if",
      "implicit",
      "import",
      "lazy",
      "match",
      "new",
      "null",
      "object",
      "override",
      "package",
      "private",
      "protected",
      "requires",
      "return",
      "sealed",
      "super",
      "this",
      "throw",
      "trait",
      "try",
      "true",
      "type",
      "val",
      "var",
      "while",
      "with",
      "yield",
      "_",
      ":",
      "=",
      "=>",
      "<-",
      "<:",
      "<%",
      ">:",
      "#",
      "@"
    });
  }

  // =========================================================================

  /**
   * Get the specified text.
   *
   * @param s The text.
   * @return The text.
   */
  protected static final String toText(String s) {
    return s;
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
