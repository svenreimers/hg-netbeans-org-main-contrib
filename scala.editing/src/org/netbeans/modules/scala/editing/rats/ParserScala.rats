/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 * 
 * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved.
 * 
 * The contents of this file are subject to the terms of either the GNU
 * General Public License Version 2 only ("GPL") or the Common
 * Development and Distribution License("CDDL") (collectively, the
 * "License"). You may not use this file except in compliance with the
 * License. You can obtain a copy of the License at
 * http://www.netbeans.org/cddl-gplv2.html
 * or nbbuild/licenses/CDDL-GPL-2-CP. See the License for the
 * specific language governing permissions and limitations under the
 * License.  When distributing the software, include this License Header
 * Notice in each file and include the License file at
 * nbbuild/licenses/CDDL-GPL-2-CP.  Sun designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Sun in the GPL Version 2 section of the License file that
 * accompanied this code. If applicable, add the following below the
 * License Header, with the fields enclosed by brackets [] replaced by
 * your own identifying information:
 * "Portions Copyrighted [year] [name of copyright owner]"
 * 
 * If you wish your version of this file to be governed by only the CDDL
 * or only the GPL Version 2, indicate your decision by adding
 * "[Contributor] elects to include this software in this distribution
 * under the [CDDL or GPL Version 2] license." If you do not indicate a
 * single choice of license, a recipient has the option to distribute
 * your version of this file under either the CDDL, the GPL Version 2 or
 * to extend the choice of license to its licensees as provided above.
 * However, if you add GPL Version 2 code and therefore, elected the GPL
 * Version 2 license, then the option applies only if the new code is
 * made subject to such option by the copyright holder.
 * 
 * Contributor(s):
 * 
 * Portions Copyrighted 2008 Sun Microsystems, Inc.
 */

/*
 * Definition of Scala lexical tokens.
 * 
 * @author Caoyuan Deng
 */
module org.netbeans.modules.scala.editing.rats.ParserScala;

import org.netbeans.modules.scala.editing.rats.Character;
import org.netbeans.modules.scala.editing.rats.Identifier;
import org.netbeans.modules.scala.editing.rats.Keyword;
import org.netbeans.modules.scala.editing.rats.Literal;
import org.netbeans.modules.scala.editing.rats.Spacing;
import org.netbeans.modules.scala.editing.rats.Symbol;
import org.netbeans.modules.scala.editing.rats.Xml;

transient generic XmlExpr =
  &( ' ' / "(" / "{" ) ( void:sep / IGNORE ) XmlElement ;

transient generic Literal =
  ( "-":Id )? FloatingPointLiteral IGNORE
/ ( "-":Id )? IntegerLiteral       IGNORE
/             BooleanLiteral       IGNORE
/             CharacterLiteral     IGNORE
/             StringLiteral        IGNORE
/             SymbolLiteral        IGNORE
;

transient generic BooleanLiteral = "true":key / "false":key;
transient generic NullLiteral = "null" ;

transient void SEMI = ";":sep n* / n+ ;

generic QualId = Id ( void:".":sep Id )* ;
generic Ids    = Id ( void:",":sep Id )* ;

generic Path =
  StableId
/ ( Id void:".":sep )? "this":key
;

generic StableId = 
  Id ( void:".":sep Id )*
/ ( Id void:".":sep )? "this" :key                 ( void:"." Id )*
/ ( Id void:".":sep )? "super":key ClassQualifier? ( void:"." Id )*
;

generic ClassQualifier = "[" Id "]";

generic Type = 
  InfixType void:"=>":key Type
/ InfixType ExistentialClause?
/ void:"(" ( void:"=>":key Type )? void:")" void:"=>":key Type
;

generic ExistentialClause = "forSome" void:"{" ExistentialDcl ( SEMI ExistentialDcl )* void:"}";

transient generic ExistentialDcl = 
  void:"type":key TypeDcl
/ void:"val" :key ValDcl
;

generic InfixType = CompoundType InfixTypeRest* ;
generic InfixTypeRest = Id void:n? CompoundType ;

generic CompoundType = 
  AnnotType ( void:"with":key AnnotType )* Refinement?
/ Refinement
;

generic AnnotType = Annotation* SimpleType ;

generic SimpleType = 
  StableId TypeArgs* ( void:"#":key Id )*
/ Path void:".":sep void:"type" TypeArgs* ( void:"#":key Id )*
/ void:"(" Types void:",":sep? void:")" TypeArgs* ( void:"#":key Id )*
;

transient generic TypeArgs = void:"[":sep Types void:"]":sep ;

transient generic Types = Type ( void:",":sep Type )* ;

transient generic Refinement = void:n? void:"{" RefineStat? ( SEMI RefineStat? )* void:"}" ;

generic RefineStat = 
  void:"type":key TypeDef
/ Dcl
;

generic TypePat = Type ;

generic Ascription = 
  void:":":key CompoundType
/ void:":":key Annotation Annotation*
/ void:":":key "_" "*"
;

generic Expr = 
  ( Bindings / Id ) void:"=>":key Expr
/ ExprNotFun;

generic ExprNotFun = 
  void:"if":key "(" Expr ")" void:n* Expr ( SEMI? void:"else":key Expr )?
/ void:"while":key "(" Expr ")" void:n* Expr
/ void:"try":key "{" Block "}" ( void:"catch" void:"{":sep CaseClauses void:"}" )? ( void:"finally":key Expr )?
/ void:"do":key Expr SEMI? void:"while" void:"(" Expr void:")"
/ void:"for":key ( void:"(" Enumerators void:")" / void:"{" Enumerators void:"}" ) void:n* void:"yield":key? Expr
/ void:"throw":key Expr
/ void:"return":key Expr?
/ ( SimpleExpr void:"." )? Id void:"=" Expr
/ SimpleExpr ArgumentExprs void:"=" Expr
/ PostfixExpr Ascription
/ PostfixExpr void:"match" void:"{" CaseClauses void:"}"
/ PostfixExpr
;

generic PostfixExpr = InfixExpr ( Id void:n? )? ;

generic InfixExpr = PrefixExpr InfixExprRest* ;
generic InfixExprRest = Id void:n? PrefixExpr;

generic PrefixExpr = ( "-" / "+" / "~" / "!" )? SimpleExpr ;

generic SimpleExpr = 
  SimplePathExpr
/ SimpleLiteralExpr
/ SimpleWildCardExpr
/ SimpleTupleExpr
/ SimpleBlockExpr
/ SimpleNewExpr
/ XmlExpr
;

transient generic SimplePathExpr     = Path      TypeArgs? SimpleExprRest*;
transient generic SimpleLiteralExpr  = Literal   TypeArgs? SimpleExprRest*;
transient generic SimpleWildCardExpr = "_"       TypeArgs? SimpleExprRest*;
transient generic SimpleTupleExpr    = ParenExpr TypeArgs? SimpleExprRest*;
transient generic SimpleBlockExpr    = BlockExpr TypeArgs? SimpleExprRest*;
transient generic SimpleNewExpr      = NewExpr   TypeArgs? SimpleExprRest*;

transient generic SimpleExprRest = 
  PathRest+
/ ArgumentExprs+
/ "_";

transient generic PathRest = void:".":sep Path TypeArgs? ;

transient generic NewExpr = void:"new":key ( ClassTemplate / TemplateBody ) ;

transient generic Exprs = Expr ( void:",":sep Expr )*;

generic ArgumentExprs =
  ParenExpr
/ n? BlockExpr
;

transient generic ParenExpr = void:"(" ( Exprs void:","? )? void:")";

generic BlockExpr = 
  void:"{":sep CaseClauses void:"}"
/ void:"{":sep Block void:"}"
;

generic Block = ( BlockStat SEMI )* ResultExpr? ;

transient generic BlockStat = 
  Import
/ void:"implicit":key? Def
/ LocalModifier* TmplDef
/ ExprNotFun
/
;

generic ResultExpr = 
  <ResultNotFun> ExprNotFun
/ <FunResult>    ( Bindings / ResultBinding ) void:"=>" Block
;

generic ResultBinding = Id void:":" CompoundType ;

transient generic Enumerators = Generator ( SEMI Enumerator )*;

transient generic Enumerator = 
  Generator
/ Guard
/ "val" Pattern1 "=" Expr
;

transient generic Generator = Pattern1 "<-" Expr Guard? ;

transient generic CaseClauses = CaseClause CaseClause* ;
transient generic CaseClause = void:"case" Pattern Guard? void:"=>" Block ;

transient generic Guard = void:"if" PostfixExpr;

transient generic Pattern = Pattern1 ( void:"|" Pattern1 )* ;

generic Pattern1 = 
  varid ":" TypePat
/ "_"   ":" TypePat
/ Pattern2
;

generic Pattern2 = 
  varid ( void:"@" Pattern3 )?
/ Pattern3
;

transient generic Pattern3 = 
  SimplePattern Pattern3Rest+
/ SimplePattern
;
transient generic Pattern3Rest = Id void:n? SimplePattern ;

transient generic SimplePattern = 
  "_":Keyword
/ Literal
/ TuplePattern
/ StableId TuplePattern
/ StableId
/ varid
;

transient generic TuplePattern = void:"(" Patterns? void:")" ;

transient generic Patterns = Pattern ( void:"," Pattern )* ( "," "_" "*" / "," )? ;

transient generic TypeParamClause = "[" VariantTypeParam ( void:"," VariantTypeParam )* "]" ;

transient generic FunTypeParamClause = "[" TypeParam ( void:"," TypeParam )* "]" ;

transient generic VariantTypeParam = ( "+" / "-" ) TypeParam ;

transient generic TypeParam = ( Id / "_" ) TypeParamClause? ( void:">:" Type )? ( void:"<:" Type )? ( void:"<%" Type )? ;

transient generic ParamClauses = ParamClause* ( void:n? void:"(" void:"implicit" Params void:")" )? ;

transient generic ParamClause = n? "(" Params? ")" ;

transient generic Params = Param ( void:"," Param )* ;

transient generic Param = Annotation* Id ( void:":" ParamType )? ;

transient generic ParamType = 
  Type void:"*"
/ Type
/ "=>" Type
;

generic ClassParamClauses = ClassParamClause* ( void:n? void:"(" void:"implicit" ClassParams void:")" )? ;

generic ClassParamClause = n? "(" ClassParams? ")" ;

generic ClassParams = ClassParam ( void:"," ClassParam )* ;

generic ClassParam = Annotation* ( Modifier* ( <Val> void:"val" / <Var> void:"var" ) )? Id ( void:":" ParamType )? ;

generic Bindings = void:"(" Binding ( void:"," Binding )* void:")" ;

transient generic Binding = Id ( void:":" Type )? ;

transient generic Modifier = 
  LocalModifier
/ AccessModifier
/ "override"
;

transient generic LocalModifier = 
  "abstract"
/ "final"
/ "sealed"
/ "implicit"
/ "lazy"
;

transient generic AccessModifier = ( "private" / "protected" ) AccessQualifier? ;

transient generic AccessQualifier = "[" ( Id / "this" ) "]" ;

generic Annotation = '@' AnnotationExpr n? ;

generic AnnotationExpr = Constr ( void:n? void:"{" NameValuePair* void:"}" )?;

generic NameValuePair = "val" Id "=" PrefixExpr;

generic TemplateBody = n? void:"{":sep SelfType?  ( TemplateStat SEMI )* "}" ;

transient generic TemplateStat = 
  Import
/ Annotation* Modifier* Def
/ Annotation* Modifier* Dcl
/ Expr
/ IGNORE
;

transient generic SelfType = 
  Id       ( void:":":key Type )? void:"=>":key
/ "this":key void:":":key Type    void:"=>":key
;

transient generic Import = "import" ImportExpr ( void:"," ImportExpr )* ;

transient generic ImportExpr = StableId "." ( Id / "_" / ImportSelectors );

transient generic ImportSelectors = "{" ( ImportSelector void:"," )* ( ImportSelector / "_" ) "}" ;

transient generic ImportSelector = Id ( void:"=>":key Id / void:"=>":key "_":key )? ;

generic Dcl = 
  "val" :key ValDcl
/ "var" :key VarDcl
/ "def" :key FunDcl
/ "type":key void:n* TypeDcl
;

generic ValDcl = Ids      void:":":key Type ;
generic VarDcl = Ids      void:":":key Type ;
generic FunDcl = FunSig ( void:":":key Type )? ;

generic FunSig = Id FunTypeParamClause? ParamClauses ;

generic TypeDcl = Id TypeParamClause? ( void:">:":key Type )? ( void:"<:":key Type )? ;

generic PatVarDef = 
  "val":key PatDef
/ "var":key VarDef
;

generic Def = 
  PatVarDef
/ void:"def" :key FunDef
/ void:"type":key void:n* TypeDef
/ TmplDef
;

generic PatDef = Pattern2 ( void:"," Pattern2 )* ( void:":" Type )? "=" Expr ;

generic VarDef = 
  PatDef
/ Ids ":" Type "=" "_"
;

generic FunDef = 
  FunSig ( void:":" Type )? "=" Expr
/ FunSig n? "{" Block "}"
/ "this" ParamClause ParamClauses ( void:"=" ConstrExpr / void:n? ConstrBlock ) 
;

generic TypeDef = Id TypeParamClause? void:"=" Type ;

generic TmplDef =
  ( "case":key )? void:"class" :key ClassDef
/ ( "case":key )? void:"object":key ObjectDef
/             void:"trait" :key TraitDef
;

transient generic ClassDef  = Id TypeParamClause? Annotation* AccessModifier? ClassParamClauses ClassTemplateOpt ;
transient generic TraitDef  = Id TypeParamClause? TraitTemplateOpt ;
transient generic ObjectDef = Id ClassTemplateOpt ;

transient generic ClassTemplateOpt = 
  Extends ClassTemplate 
/ ( ( <Extends> void:"extends":key )? TemplateBody 
  / ( <UBounds> void:"<:"     :key )? TemplateBody 
  )? 
;

transient generic TraitTemplateOpt =
  Extends TraitTemplate 
/ ( ( <Extends> void:"extends":key )? TemplateBody 
  / ( <UBounds> void:"<:"     :key )? TemplateBody 
  )? 
;

generic Extends = "extends":key / "<:":key ;

transient generic ClassTemplate = ( void:"{":sep EarlyDefs? void:"}":sep void:"with":key )? ClassParents TemplateBody? ;
transient generic TraitTemplate = ( void:"{":sep EarlyDefs? void:"}":sep void:"with":key )? TraitParents TemplateBody? ;

transient generic ClassParents = Constr    ( void:"with":key AnnotType )* ;
transient generic TraitParents = AnnotType ( void:"with":key AnnotType )* ;

transient generic Constr = AnnotType ArgumentExprs* ;

transient generic EarlyDefs = EarlyDef ( SEMI EarlyDef )* ;
transient generic EarlyDef = Annotation* Modifier* PatVarDef ;

transient generic ConstrExpr = 
  SelfInvocation
/ ConstrBlock
;

transient generic ConstrBlock = "{" SelfInvocation ( SEMI BlockStat )* "}" ;

transient generic SelfInvocation = void:"this" ArgumentExprs ArgumentExprs* ;

transient generic TopStatSeq = TopStat ( TopStat SEMI )* ;

transient generic TopStat = 
  Annotation* Modifier* TmplDef
/ Import
/ Packaging
/ IGNORE
;

transient generic Packaging = void:"package":key QualId void:n? void:"{" TopStatSeq void:"}" ;
transient generic Package   = void:"package":key QualId SEMI ;

public generic CompilationUnit = Package? TopStatSeq;

