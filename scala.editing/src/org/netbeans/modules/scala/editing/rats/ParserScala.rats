/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 * 
 * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved.
 * 
 * The contents of this file are subject to the terms of either the GNU
 * General Public License Version 2 only ("GPL") or the Common
 * Development and Distribution License("CDDL") (collectively, the
 * "License"). You may not use this file except in compliance with the
 * License. You can obtain a copy of the License at
 * http://www.netbeans.org/cddl-gplv2.html
 * or nbbuild/licenses/CDDL-GPL-2-CP. See the License for the
 * specific language governing permissions and limitations under the
 * License.  When distributing the software, include this License Header
 * Notice in each file and include the License file at
 * nbbuild/licenses/CDDL-GPL-2-CP.  Sun designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Sun in the GPL Version 2 section of the License file that
 * accompanied this code. If applicable, add the following below the
 * License Header, with the fields enclosed by brackets [] replaced by
 * your own identifying information:
 * "Portions Copyrighted [year] [name of copyright owner]"
 * 
 * If you wish your version of this file to be governed by only the CDDL
 * or only the GPL Version 2, indicate your decision by adding
 * "[Contributor] elects to include this software in this distribution
 * under the [CDDL or GPL Version 2] license." If you do not indicate a
 * single choice of license, a recipient has the option to distribute
 * your version of this file under either the CDDL, the GPL Version 2 or
 * to extend the choice of license to its licensees as provided above.
 * However, if you add GPL Version 2 code and therefore, elected the GPL
 * Version 2 license, then the option applies only if the new code is
 * made subject to such option by the copyright holder.
 * 
 * Contributor(s):
 * 
 * Portions Copyrighted 2008 Sun Microsystems, Inc.
 */

/*
 * Definition of Scala lexical tokens.
 * 
 * @author Caoyuan Deng
 */
module org.netbeans.modules.scala.editing.rats.ParserScala;

import org.netbeans.modules.scala.editing.rats.Character;
import org.netbeans.modules.scala.editing.rats.Identifier;
import org.netbeans.modules.scala.editing.rats.Keyword;
import org.netbeans.modules.scala.editing.rats.Literal;
import org.netbeans.modules.scala.editing.rats.Spacing;
import org.netbeans.modules.scala.editing.rats.Symbol;
import org.netbeans.modules.scala.editing.rats.Xml;

transient generic XmlExpr =
  &( ' ' / "(" / "{" ) ( void:sep / IGNORE ) XmlElement ;

transient generic Literal =
  ( "-":opid )? FloatingPointLiteral IGNORE
/ ( "-":opid )? IntegerLiteral       IGNORE
/               BooleanLiteral       IGNORE
/               CharacterLiteral     IGNORE
/               StringLiteral        IGNORE
/               SymbolLiteral        IGNORE
;

transient generic BooleanLiteral = "true":key / "false":key;
transient generic NullLiteral = "null" ;

transient void SEMI = ";":sep N* / N+ ;

generic QualId = Id ( void:".":sep Id )* ;
generic Ids    = Id ( void:",":sep Id )* ;

generic Path =
  StableId
/ ( Id void:".":sep )? "this":key
;

generic StableId = 
  Id ( void:".":sep Id )*
/ ( Id void:".":sep )? "this" :key                 ( void:".":key Id )*
/ ( Id void:".":sep )? "super":key ClassQualifier? ( void:".":key Id )*
;

generic ClassQualifier = void:"[":sep Id void:"]":sep;

generic Type = 
  InfixType void:"=>":key Type
/ InfixType ExistentialClause?
/ void:"(" ( void:"=>":key Type )? void:")" void:"=>":key Type
;

generic ExistentialClause = "forSome":key void:"{":sep ExistentialDcl ( SEMI ExistentialDcl )* void:"}":sep;

transient generic ExistentialDcl = 
  void:"type":key TypeDcl
/ void:"val" :key ValDcl
;

generic InfixType = CompoundType InfixTypeRest* ;
generic InfixTypeRest = Id N? CompoundType ;

generic CompoundType = 
  AnnotType ( void:"with":key AnnotType )* Refinement?
/ Refinement
;

generic AnnotType = Annotation* SimpleType ;

generic SimpleType = 
  StableId TypeArgs* ( void:"#":key Id )*
/ Path void:".":sep void:"type" TypeArgs* ( void:"#":key Id )*
/ void:"(":sep Types ( void:",":sep )? void:")":sep TypeArgs* ( void:"#":key Id )*
;

transient generic TypeArgs = void:"[":sep Types void:"]":sep ;

transient generic Types = Type ( void:",":sep Type )* ;

transient generic Refinement = N? void:"{":sep RefineStat? ( SEMI RefineStat? )* void:"}":sep ;

generic RefineStat = 
  void:"type":key TypeDef
/ Dcl
;

generic TypePat = Type ;

generic Ascription = 
  void:":":key CompoundType
/ void:":":key Annotation Annotation*
/ void:":":key "_":key "*"
;

generic Expr = 
  ( Bindings / Id ) void:"=>":key Expr
/ ExprNotFun;

generic ExprNotFun = 
  void:"if"    :key void:"(":sep Expr  void:")":sep N* Expr ( SEMI? void:"else":key Expr )?
/ void:"while" :key void:"(":sep Expr  void:")":sep N* Expr
/ void:"try"   :key void:"{":sep Block void:"}":sep ( void:"catch":key void:"{":sep CaseClauses void:"}":sep )? ( void:"finally":key Expr )?
/ void:"do"    :key Expr SEMI? void:"while":key void:"(":sep Expr void:")":sep
/ void:"for"   :key ( void:"(":sep Enumerators void:")":sep / void:"{":sep Enumerators void:"}":sep ) N* ( void:"yield":key) ? Expr
/ void:"throw" :key Expr
/ void:"return":key Expr?
/ ( SimpleExpr void:".":sep )? Id void:"=":key Expr
/ SimpleExpr ArgumentExprs void:"=":key Expr
/ PostfixExpr Ascription
/ PostfixExpr void:"match":key void:"{":sep CaseClauses void:"}":sep
/ PostfixExpr
;

generic PostfixExpr = InfixExpr ( Id ( N) ? )? ;

generic InfixExpr = PrefixExpr InfixExprRest* ;
generic InfixExprRest = Id N? PrefixExpr;

generic PrefixExpr = ( "-":opid / "+":opid / "~":opid / "!":opid )? SimpleExpr ;

generic SimpleExpr = 
  SimpleLiteralExpr
/ SimplePathExpr
/ SimpleWildCardExpr
/ SimpleTupleExpr
/ SimpleBlockExpr
/ SimpleNewExpr
/ XmlExpr
;

transient generic SimplePathExpr     = Path      TypeArgs? SimpleExprRest*;
transient generic SimpleLiteralExpr  = Literal   TypeArgs? SimpleExprRest*;
transient generic SimpleWildCardExpr = "_":key   TypeArgs? SimpleExprRest*;
transient generic SimpleTupleExpr    = ParenExpr TypeArgs? SimpleExprRest*;
transient generic SimpleBlockExpr    = BlockExpr TypeArgs? SimpleExprRest*;
transient generic SimpleNewExpr      = NewExpr   TypeArgs? SimpleExprRest*;

transient generic SimpleExprRest = 
  PathRest+
/ ArgumentExprs+
/ "_":key;

transient generic PathRest = void:".":sep Path TypeArgs? ;

transient generic NewExpr = void:"new":key ( ClassTemplate / TemplateBody ) ;

transient generic Exprs = Expr ( void:",":sep Expr )*;

generic ArgumentExprs =
  ParenExpr
/ N? BlockExpr
;

transient generic ParenExpr = void:"(":sep ( Exprs ( void:",":sep )? )? void:")":sep;

generic BlockExpr = 
  void:"{":sep CaseClauses void:"}":sep
/ void:"{":sep Block       void:"}":sep
;

generic Block = ( BlockStat SEMI )* ResultExpr? ;

transient generic BlockStat = 
  Import
/ ( void:"implicit":key )? Def
/ LocalModifier* TmplDef
/ ExprNotFun
/ IGNORE
;

generic ResultExpr = 
  <ResultNotFun> ExprNotFun
/ <FunResult>    ( Bindings / ResultBinding ) void:"=>":key Block
;

generic ResultBinding = Id void:":":sep CompoundType ;

transient generic Enumerators = Generator ( SEMI Enumerator )*;

transient generic Enumerator = 
  Generator
/ Guard
/ "val":key Pattern1 "=":key Expr
;

transient generic Generator = Pattern1 "<-":key Expr Guard? ;

transient generic CaseClauses = CaseClause CaseClause* ;
transient generic CaseClause = void:"case":key Pattern Guard? void:"=>":key Block ;

transient generic Guard = void:"if":key PostfixExpr;

transient generic Pattern = Pattern1 ( void:"|":sep Pattern1 )* ;

generic Pattern1 = 
  VarId   void:":":sep TypePat
/ "_":key void:":":sep TypePat
/ Pattern2
;

generic Pattern2 = 
  VarId ( void:"@":key Pattern3 )?
/ Pattern3
;

transient generic Pattern3 = 
  <CallPattern>   SimplePattern CallPatternTail+
/ <SimplePattern> SimplePattern;
transient generic CallPatternTail = Id N? SimplePattern ;

transient generic SimplePattern =
  "_":key
/ Literal
/ TuplePattern
/ StableId TuplePattern
/ StableId
;

transient generic TuplePattern = void:"(":sep Patterns? void:")":sep ;

transient generic Patterns = Pattern ( void:",":sep Pattern )* ( ",":sep "_":key "*" / ",":sep )? ;

transient generic TypeParamClause = void:"[":sep VariantTypeParam ( void:",":sep VariantTypeParam )* void:"]":sep ;

transient generic FunTypeParamClause = void:"[":sep TypeParam ( void:",":sep TypeParam )* void:"]":sep ;

transient generic VariantTypeParam = ( "+":opid / "-":opid ) TypeParam ;

transient generic TypeParam = ( Id / "_":sep ) TypeParamClause? ( void:">:":key Type )? ( void:"<:":key Type )? ( void:"<%":key Type )? ;

transient generic ParamClauses = ParamClause* ( N? void:"(":sep void:"implicit":sep Params void:")":sep )? ;

transient generic ParamClause = N? void:"(":sep Params? void:")":sep ;

transient generic Params = Param ( void:",":sep Param )* ;

transient generic Param = Annotation* Id ( void:":":key ParamType )? ;

transient generic ParamType = 
  Type "*"
/ Type
/ "=>":key Type
;

generic ClassParamClauses = ClassParamClause* ( N? void:"(":sep void:"implicit":key ClassParams void:")":sep )? ;

generic ClassParamClause = N? void:"(":sep ClassParams? void:")":sep ;

generic ClassParams = ClassParam ( void:",":sep ClassParam )* ;

generic ClassParam = Annotation* ( Modifier* ( <Val> void:"val":key / <Var> void:"var":key ) )? Id ( void:":":key ParamType )? ;
generic ValOrVar = ;

generic Bindings = void:"(":sep Binding ( void:",":sep Binding )* void:")":sep ;

transient generic Binding = Id ( void:":":key Type )? ;

transient generic Modifier = 
  LocalModifier
/ AccessModifier
/ "override":key
;

transient generic LocalModifier = 
  "abstract":key
/ "final"   :key
/ "sealed"  :key
/ "implicit":key
/ "lazy"    :key
;

transient generic AccessModifier = ( "private":key / "protected":key ) AccessQualifier? ;

transient generic AccessQualifier = void:"[":sep ( Id / "this":key ) void:"]":sep ;

generic Annotation = "@":key AnnotationExpr N? ;

generic AnnotationExpr = Constr ( N? void:"{":sep NameValuePair* void:"}":sep )?;

generic NameValuePair = void:"val":key Id void:"=":key PrefixExpr;

generic TemplateBody = N? void:"{":sep SelfType? ( TemplateStat SEMI )* void:"}":sep ;

transient generic TemplateStat = 
  Import
/ Annotation* Modifier* Def
/ Annotation* Modifier* Dcl
/ Expr
/
;

transient generic SelfType = 
  Id       ( void:":":key Type )? void:"=>":key
/ "this":key void:":":key Type    void:"=>":key
;

transient generic Import = "import":key ImportExpr ( void:",":sep ImportExpr )* ;

transient generic ImportExpr = StableId void:".":sep ( Id / "_":key / ImportSelectors );

transient generic ImportSelectors = void:"{":sep ( ImportSelector void:",":sep )* ( ImportSelector / "_":key ) void:"}":sep ;

transient generic ImportSelector = Id ( void:"=>":key Id / void:"=>":key "_":key )? ;

generic Dcl = 
  void:"val" :key ValDcl
/ void:"var" :key VarDcl
/ void:"def" :key FunDcl
/ void:"type":key N* TypeDcl
;

generic ValDcl = Ids      void:":":key Type ;
generic VarDcl = Ids      void:":":key Type ;
generic FunDcl = FunSig ( void:":":key Type )? ;

generic FunSig = Id FunTypeParamClause? ParamClauses ;

transient generic TypeDcl = Id TypeParamClause? ( void:">:":key Type )? ( void:"<:":key Type )? ;

generic PatVarDef = 
  void:"val":key PatDef
/ void:"var":key VarDef
;

generic Def = 
  PatVarDef
/ void:"def" :key FunDef
/ void:"type":key N* TypeDef
/ TmplDef
;

transient generic PatDef = Pattern2 ( void:",":sep Pattern2 )* ( void:":":key Type )? "=":key Expr ;

generic VarDef = 
  PatDef
/ Ids void:":":key Type "=":key "_":key
;

generic FunDef = 
  FunSig ( void:":":key Type )? "=":key Expr
/ FunSig N? void:"{":sep Block void:"}":sep
/ "this":key ParamClause ParamClauses ( void:"=":key ConstrExpr / N? ConstrBlock ) 
;

generic TypeDef = Id TypeParamClause? void:"=":key Type ;

generic TmplDef =
  ( "case":key )? void:"class" :key ClassDef
/ ( "case":key )? void:"object":key ObjectDef
/                 void:"trait" :key TraitDef
;

transient generic ClassDef  = Id TypeParamClause? Annotation* AccessModifier? ClassParamClauses ClassTemplateOpt ;
transient generic TraitDef  = Id TypeParamClause? TraitTemplateOpt ;
transient generic ObjectDef = Id ClassTemplateOpt ;

transient generic ClassTemplateOpt = 
  Extends ClassTemplate 
/ ( ( <Extends> void:"extends":key )? TemplateBody 
  / ( <UBounds> void:"<:"     :key )? TemplateBody 
  )? 
;

transient generic TraitTemplateOpt =
  Extends TraitTemplate 
/ ( ( <Extends> void:"extends":key )? TemplateBody 
  / ( <UBounds> void:"<:"     :key )? TemplateBody 
  )? 
;

generic Extends = "extends":key / "<:":key ;

transient generic ClassTemplate = ( void:"{":sep EarlyDefs? void:"}":sep void:"with":key )? ClassParents TemplateBody? ;
transient generic TraitTemplate = ( void:"{":sep EarlyDefs? void:"}":sep void:"with":key )? TraitParents TemplateBody? ;

transient generic ClassParents = Constr    ( void:"with":key AnnotType )* ;
transient generic TraitParents = AnnotType ( void:"with":key AnnotType )* ;

transient generic Constr = AnnotType ArgumentExprs* ;

transient generic EarlyDefs = EarlyDef ( SEMI EarlyDef )* ;
transient generic EarlyDef = Annotation* Modifier* PatVarDef ;

transient generic ConstrExpr = 
  SelfInvocation
/ ConstrBlock
;

transient generic ConstrBlock = void:"{":sep SelfInvocation ( SEMI BlockStat )* void:"}":sep ;

transient generic SelfInvocation = void:"this":key ArgumentExprs ArgumentExprs* ;

transient generic TopStatSeq = TopStat ( TopStat SEMI )* ;

transient generic TopStat = 
  Import
/ Packaging
/ Annotation* Modifier* TmplDef
/ IGNORE
;

transient generic Packaging = void:"package":key QualId N? void:"{":sep TopStatSeq void:"}":sep ;
transient generic Package   = void:"package":key QualId SEMI ;

public generic CompilationUnit = Package? TopStatSeq;

