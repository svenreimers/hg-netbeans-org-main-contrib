package org.netbeans.modules.erlang.console;

import java.awt.Color;
import java.awt.Font;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.io.InputStreamReader;
import java.io.PipedInputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.Reader;
import javax.swing.BorderFactory;
import javax.swing.JScrollPane;
import javax.swing.JTextPane;
import javax.swing.SwingUtilities;
import javax.swing.text.BadLocationException;
import java.io.Serializable;
import javax.swing.UIManager;
import javax.swing.text.Caret;
import org.netbeans.api.project.Project;
import org.netbeans.api.project.ui.OpenProjects;
import org.netbeans.modules.erlang.platform.api.RubyExecution;
import org.netbeans.modules.languages.execution.ExecutionDescriptor;
import org.netbeans.modules.languages.execution.console.TextAreaReadline;
import org.openide.ErrorManager;
import org.openide.filesystems.FileObject;
import org.openide.filesystems.FileUtil;
import org.openide.util.Exceptions;
import org.openide.util.NbBundle;
import org.openide.util.Task;
import org.openide.util.TaskListener;
import org.openide.windows.TopComponent;
import org.openide.windows.WindowManager;
import org.openide.util.Utilities;

/**
 * IRB window.
 * This class is heavily based on IRBConsole in the JRuby distribution,
 * but changed since IRBConsole extends from JFrame and we want to extend
 * TopComponent (which is a JPanel).
 *
 * @todo Use the equivalent of "jirb -rirb/completion" to get autocompletion?
 *    (include "irb/completion"). See http://jira.codehaus.org/browse/JRUBY-389?page=all
 * @todo It might be interesting to set the mime type of the embedded
 *   text pane to Ruby, and see if syntax highlighting works. Might
 *   need some tweaks, e.g. a derived mode for shell ruby.
 *   Also, if the TextAreaReadline messes with attributes in the StyledDocument,
 *   we're hosed. The NetBeans editor GuardedDocument implementation does not like that.
 * @todo Use output2's APIs: AbstractOutputTab - it has a lot of good
 *   logic for keeping the pane scrolled to track output, locking the caret on the
 *   last line, etc.
 */
final class ErlangConsoleTopComponent extends TopComponent {
    private boolean finished = true;
    private JTextPane textPane;
    private String mimeType = "text/x-console";
    
    private static ErlangConsoleTopComponent instance;
    /** path to the icon used by the component and its open action */
    static final String ICON_PATH = "org/netbeans/modules/languages/erlang/console/resources/erlang.png"; // NOI18N
    
    private static final String PREFERRED_ID = "ErlangConsoleTopComponent"; // NOI18N
    
    private ErlangConsoleTopComponent() {
        initComponents();
        setName(NbBundle.getMessage(ErlangConsoleTopComponent.class, "CTL_ErlangConsoleTopComponent"));
        setToolTipText(NbBundle.getMessage(ErlangConsoleTopComponent.class, "HINT_ErlangConsoleTopComponent"));
        setIcon(Utilities.loadImage(ICON_PATH, true));
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {

        setLayout(new java.awt.BorderLayout());
    }// </editor-fold>//GEN-END:initComponents
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    
    /**
     * Gets default instance. Do not use directly: reserved for *.settings files only,
     * i.e. deserialization routines; otherwise you could get a non-deserialized instance.
     * To obtain the singleton instance, use {@link findInstance}.
     */
    public static synchronized ErlangConsoleTopComponent getDefault() {
        if (instance == null) {
            instance = new ErlangConsoleTopComponent();
        }
        return instance;
    }
    
    /**
     * Obtain the IrbTopComponent instance. Never call {@link #getDefault} directly!
     */
    public static synchronized ErlangConsoleTopComponent findInstance() {
        TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);
        if (win == null) {
            ErrorManager.getDefault().log(ErrorManager.WARNING,
                    "Cannot find MyWindow component. It will not be located properly in the window system.");
            return getDefault();
        }
        if (win instanceof ErlangConsoleTopComponent) {
            return (ErlangConsoleTopComponent)win;
        }
        ErrorManager.getDefault().log(ErrorManager.WARNING,
                "There seem to be multiple components with the '" + PREFERRED_ID +
                "' ID. That is a potential source of errors and unexpected behavior.");
        return getDefault();
    }
    
    public int getPersistenceType() {
        return TopComponent.PERSISTENCE_ALWAYS;
    }
    
    public void componentOpened() {
        if (finished) {
            // Start a new one
            finished = false;
            removeAll();
            createTerminal();
        }
    }
    
    public void componentClosed() {
        // Leave the terminal session running
    }
    
    @Override
    public void componentActivated() {
        // Make the caret visible. See comment under componentDeactivated.
        if (textPane != null) {
            Caret caret = textPane.getCaret();
            if (caret != null) {
                caret.setVisible(true);
            }
        }
    }
    
    @Override
    public void componentDeactivated() {
        // I have to turn off the caret when the window loses focus. Text components
        // normally do this by themselves, but the TextAreaReadline component seems
        // to mess around with the editable property of the text pane, and
        // the caret will not turn itself on/off for noneditable text areas.
        if (textPane != null) {
            Caret caret = textPane.getCaret();
            if (caret != null) {
                caret.setVisible(false);
            }
        }
    }
    
    /** replaces this in object stream */
    public Object writeReplace() {
        return new ResolvableHelper();
    }
    
    protected String preferredID() {
        return PREFERRED_ID;
    }
    
    final static class ResolvableHelper implements Serializable {
        private static final long serialVersionUID = 1L;
        public Object readResolve() {
            return ErlangConsoleTopComponent.getDefault();
        }
    }
    
    public void createTerminal() {
        final PipedInputStream pipeIn = new PipedInputStream();
        
        textPane = new JTextPane();
        textPane.getDocument().putProperty("mimeType", mimeType);
	
        textPane.setMargin(new Insets(8,8,8,8));
        textPane.setCaretColor(new Color(0xa4, 0x00, 0x00));
        textPane.setBackground(new Color(0xf2, 0xf2, 0xf2));
        textPane.setForeground(new Color(0xa4, 0x00, 0x00));
        
        // From core/output2/**/AbstractOutputPane
        Integer i = (Integer) UIManager.get("customFontSize"); //NOI18N
        int size;
        if (i != null) {
            size = i.intValue();
        } else {
            Font f = (Font) UIManager.get("controlFont"); // NOI18N
            size = f != null ? f.getSize() : 11;
        }
        
        Font font = new Font("Monospaced", Font.PLAIN, size); //NOI18N
        if (font == null) {
            font = new Font("Lucida Sans Typewriter", Font.PLAIN, size);
        }
        textPane.setFont(font);
        
        setBorder(BorderFactory.createEmptyBorder());
        
        // Try to initialize colors from NetBeans properties, see core/output2
        Color c = UIManager.getColor("nb.output.selectionBackground"); // NOI18N
        if (c != null) {
            textPane.setSelectionColor(c);
        }

	
        //Object value = Settings.getValue(BaseKit.class, SettingsNames.CARET_COLOR_INSERT_MODE);
        //Color caretColor;
        //if (value instanceof Color) {
        //    caretColor = (Color)value;
        //} else {
        //    caretColor = SettingsDefaults.defaultCaretColorInsertMode;
        //}
        //text.setCaretColor(caretColor);
        //text.setBackground(UIManager.getColor("text")); //NOI18N
        //Color selectedFg = UIManager.getColor ("nb.output.foreground.selected"); //NOI18N
        //if (selectedFg == null) {
        //    selectedFg = UIManager.getColor("textText") == null ? Color.BLACK : //NOI18N
        //       UIManager.getColor("textText"); //NOI18N
        //}
        //
        //Color unselectedFg = UIManager.getColor ("nb.output.foreground"); //NOI18N
        //if (unselectedFg == null) {
        //    unselectedFg = selectedFg;
        //}
        //text.setForeground(unselectedFg);
        //text.setSelectedTextColor(selectedFg);
        //
        //Color selectedErr = UIManager.getColor ("nb.output.err.foreground.selected"); //NOI18N
        //if (selectedErr == null) {
        //    selectedErr = new Color (164, 0, 0);
        //}
        //Color unselectedErr = UIManager.getColor ("nb.output.err.foreground"); //NOI18N
        //if (unselectedErr == null) {
        //    unselectedErr = selectedErr;
        //}
        
        
        JScrollPane pane = new JScrollPane();
        pane.setViewportView(textPane);
        pane.setBorder(BorderFactory.createLineBorder(Color.darkGray));
        add(pane);
        validate();

        final TextAreaReadline taReadline = new TextAreaReadline(textPane, " " +  // NOI18N
                NbBundle.getMessage(ErlangConsoleTopComponent.class, "ErlangConsoleWelcome") + " \n\n",
                pipeIn); // NOI18N
        File pwd = getMainProjectWorkPath();
	String workPath = pwd.getPath();
        Reader in = new InputStreamReader(pipeIn);
        PrintWriter out = new PrintWriter(new PrintStream(taReadline));
        PrintWriter err = new PrintWriter(new PrintStream(taReadline));
        ExecutionDescriptor descriptor = new ExecutionDescriptor("Erlang Shell", pwd);
        descriptor.interactive(true).showProgress(false).showSuspended(false)
		.initialArgs("-sname erlybird " + "-pa " + workPath + File.separator + "ebin ");  
        RubyExecution executionService = new RubyExecution(descriptor);
        Task task = executionService.run(in, out, err);

        task.addTaskListener(new TaskListener() {
            public void taskFinished(Task task) {
                finished = true;
                textPane.setEditable(false);
                SwingUtilities.invokeLater(new Runnable() {
                    public void run() {
                        ErlangConsoleTopComponent.this.close();
                        ErlangConsoleTopComponent.this.removeAll();
                        textPane = null;
                    }
                });
            }
        });
        
        // [Issue 91208]  avoid of putting cursor in IRB console on line where is not a prompt
        textPane.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent ev) {
                final int mouseX = ev.getX();
                final int mouseY = ev.getY();
                // Ensure that this is done after the textpane's own mouse listener
                SwingUtilities.invokeLater(new Runnable() {
                    public void run() {
                        // Attempt to force the mouse click to appear on the last line of the text input
                        int pos = textPane.getDocument().getEndPosition().getOffset()-1;
                        if (pos == -1) {
                            return;
                        }
                        
                        try {
                            Rectangle r = textPane.modelToView(pos);
                            
                            if (mouseY >= r.y) {
                                // The click was on the last line; try to set the X to the position where
                                // the user clicked since perhaps it was an attempt to edit the existing
                                // input string. Later I could perhaps cast the text document to a StyledDocument,
                                // then iterate through the document positions and locate the end of the
                                // input prompt (by comparing to the promptStyle in TextAreaReadline).
                                r.x = mouseX;
                                pos = textPane.viewToModel(r.getLocation());
                            }
                            
                            textPane.getCaret().setDot(pos);
                        } catch (BadLocationException ble) {
                            Exceptions.printStackTrace(ble);
                        }
                    }
                });
            }
        }); 
    }
    
    @Override
    public void requestFocus() {
        if (textPane != null) {
            textPane.requestFocus();
        }
    }
    
    @Override
    public boolean requestFocusInWindow() {
        if (textPane != null) {
            return textPane.requestFocusInWindow();
        }
        
        return false;
    }
    
    private File getMainProjectWorkPath() {
        File pwd = null;
        Project mainProject = OpenProjects.getDefault().getMainProject();
        if (mainProject != null) {
            FileObject fo = mainProject.getProjectDirectory();
            if (! fo.isFolder()) {
                fo = fo.getParent();
            }
            pwd = FileUtil.toFile(fo);
        }
        if (pwd == null) {
            String userHome = System.getProperty("user.home");
            pwd = new File(userHome);
        }
        return pwd;
    }
}
